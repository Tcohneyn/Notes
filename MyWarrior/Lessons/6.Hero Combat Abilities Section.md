# è‹±é›„æˆ˜æ–—èƒ½åŠ›éƒ¨åˆ†

## å‰è¨€

æœ¬éƒ¨åˆ†æˆ‘ä»¬å°†ä¸“æ³¨äºä¸ºä¸»è§’åˆ›å»ºæ›´å¤šçš„æ¸¸æˆèƒ½åŠ›ã€‚

* **å®šå‘ç¿»æ»š(Directional Rolling)**
* **å®šå‘å‡»ä¸­ååº”(Directional Hit React)**
* **é˜²å¾¡æ ¼æŒ¡(Block/Parry)**
* **ç›®æ ‡é”å®š(Target Lock)**
* **è‹±é›„æ­»äº¡æœºåˆ¶(Hero Death)**

## **å®šå‘ç¿»æ»š(Directional Rolling)**

ç°åœ¨åˆ›å»ºç¬¬ä¸€ä¸ªèƒ½åŠ›ï¼Œä¹Ÿå°±æ˜¯è§’è‰²çš„æ–¹å‘ç¿»æ»šã€‚ä¸ºäº†å®ç°è¿™ä¸ªèƒ½åŠ›æˆ‘ä»¬éœ€è¦åšå‡ ä»¶äº‹ã€‚

ç¬¬ä¸€é¡¹æ˜¯è®¾ç½®ä¸€ä¸ª â€œåŒé”®è¾“å…¥â€ æ“ä½œã€‚

å’Œä¹‹å‰çš„èƒ½åŠ›ä¸åŒï¼Œè¦è§¦å‘ç¿»æ»šèƒ½åŠ›ï¼Œå¿…é¡»åŒæ—¶æŒ‰ä¸‹å¤šä¸ªæŒ‰é”®ã€‚é€šè¿‡ç©å®¶çš„è¾“å…¥ï¼Œæˆ‘ä»¬æ‰èƒ½å†³å®šç¿»æ»šçš„æ–¹å‘ã€‚é™¤äº†æ–¹å‘ï¼Œæˆ‘è¿˜Gameplay Ability ä¸­ç¡®å®šç¿»æ»šçš„è·ç¦»ã€‚å…ˆæ¥è°ˆè°ˆè¿™ä¸ªåŒé”®è¾“å…¥æ“ä½œã€‚å¯¹äºç¿»æ»šï¼Œåº”æ”¯æŒ 8 ä¸ªæ–¹å‘ä¾›ç©å®¶æ»šåŠ¨ã€‚è¿™ 8 ä¸ªæ–¹å‘å®Œå…¨å–å†³äºç”¨æˆ·çš„è¾“å…¥ã€‚ä¹Ÿå°±æ˜¯ Wã€Sã€Aã€D å››é”®ã€‚ç›®å‰æˆ‘ä»¬ç”¨è¿™äº›é”®æ§åˆ¶è§’è‰²ç§»åŠ¨ï¼ŒåŒæ—¶ä¹Ÿç”¨å®ƒä»¬åˆ¤æ–­ç¿»æ»šæ–¹å‘ã€‚ç¨åæˆ‘ä»¬ä¼šå±•ç¤ºå…·ä½“å¦‚ä½•å¤„ç†è¿™äº›æŒ‰é”®é€»è¾‘ã€‚é™¤äº†è¿™äº›æ–¹å‘é”®ï¼Œç©å®¶è¿˜éœ€è¦æŒ‰ä¸‹ç©ºæ ¼é”®æ¥è§¦å‘ç¿»æ»šèƒ½åŠ›ï¼Œè¿™æ‰æ˜¯åŒé”®è¾“å…¥çš„å®Œæ•´å½¢å¼ã€‚è¦è®¾ç½®è¿™ä¸€åˆ‡ï¼Œé¦–å…ˆéœ€è¦åˆ›å»ºè¿™ä¸ªèƒ½åŠ›ï¼Œæˆ‘ä»¬éœ€è¦å†æ¬¡ç»å†ä¸ºä¸»è§’åˆ›å»ºèƒ½åŠ›çš„æµç¨‹ã€‚åŒ…æ‹¬è®¾ç½®èƒ½åŠ›æ ‡ç­¾ã€Gameplay Ability Blueprintã€Montage ç»“æŸå¤„ç†èƒ½åŠ›è¾“å…¥æ“ä½œï¼Œä»¥åŠå°†èƒ½åŠ›èµ‹äºˆä¸»è§’ã€‚

![](./Lesson Images/6-1.png)

### â€œåŒé”®è¾“å…¥â€ æ“ä½œ

* èƒ½åŠ›æ ‡ç­¾

```c++
//WarriorGameplayTags.h
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(InputTag_Roll);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Ability_Roll);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Status_Rolling);
```

ä»¥WarriorHeroGameplayAbilityä¸ºçˆ¶ç±»åˆ›å»ºGA_Hero_Rollè“å›¾ç±»ï¼Œç±»è®¾ç½®ã€‚ç„¶ååœ¨DA_Heroå’ŒDA_InputConfigé…ç½®å¥½ã€‚

![](./Lesson Images/6-2.png)

### æ»šåŠ¨æ–¹å‘

åœ¨æœ¬è®²ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•é€šè¿‡è¾“å…¥ç¡®å®šç¿»æ»šæ–¹å‘ã€‚é¦–å…ˆåˆ›å»ºAM_Hero_RollåŠ¨ç”»è’™å¤ªå¥‡ã€‚å°† Slot æ”¹ä¸º Full Body Slotã€‚

é€šè¿‡è¾“å…¥ç¡®å®šç¿»æ»šæ–¹å‘ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Motion Morphing å®Œæˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦åœ¨è’™å¤ªå¥‡çš„ Notify track ä¸­æ·»åŠ  Motion Morphing è¿™ä¸ª Notify Stateã€‚è¿™ä¸ªçŠ¶æ€çš„å¼€å§‹å¸§åº”è®¾ä¸ºç¬¬ 0 å¸§ï¼Œç»“æŸå¸§æ‹–è‡³å¤§çº¦ç¬¬ 5 å¸§å·¦å³ã€‚è¿™æ ·æˆ‘ä»¬ä¸ä¼šå¤ªæ—©è®©è§’è‰²ä½ç§»ã€‚ç„¶åå±•å¼€ Root Motion Modifier çš„è®¾ç½®ã€‚Warp Target Name å¡«å…¥ â€œrolling directionâ€ï¼Œå–æ¶ˆå‹¾é€‰ Warp Translationï¼ˆæˆ‘ä»¬åªå…³æ³¨æ—‹è½¬ï¼‰ã€‚
Rotation ç±»å‹ä¿æŒé»˜è®¤å³å¯ï¼Œå› ä¸ºæˆ‘ä»¬ä¼šæ‰‹åŠ¨è®¡ç®—æœå‘ã€‚å…¶ä½™è®¾ç½®ä¿æŒé»˜è®¤ï¼Œä¿å­˜è’™å¤ªå¥‡ã€‚

**GA_Hero_Roll_Cç±»**

```lua
---@type GA_Hero_Roll_C
local M = UnLua.Class()

function M:K2_ActivateAbility()
    local world = self:GetWorld()
    -- æ¨¡ä»¿è“å›¾ä¸­ï¼Œå…ˆå»¶è¿Ÿ0.05ç§’ç­‰å¾…è¾“å…¥æ•è·ï¼ˆå¯¹åº”å­—å¹•é‡Œ delay åœ¨å¯åŠ¨ Compute Roll Direction ä¹‹å‰ï¼‰
    coroutine.resume(coroutine.create(function()
        UE.UKismetSystemLibrary.Delay(world, self.Duration)
        self:ComputeRollDirectionAndDistance()
        -- è®¾ç½®å¹¶æ’­æ”¾ç¿»æ»šçš„ Montageï¼ˆSubtitle ä¸­â€œPlay Montage and Waitâ€èŠ‚ç‚¹ï¼‰
        local PlayMontageTask = UE.UAbilityTask_PlayMontageAndWait.CreatePlayMontageAndWaitProxy(
            self, "PlayMontageTask", self.MontagetoPlay)
        PlayMontageTask.OnCompleted:Add(self, M.OnMontage)
        PlayMontageTask.OnBlendOut:Add(self, M.OnMontage)
        PlayMontageTask.OnInterrupted:Add(self, M.OnMontage)
        PlayMontageTask.OnCancelled:Add(self, M.OnMontage)
        PlayMontageTask:ReadyForActivation()
    end))
end

function M:OnMontage()
    -- Montage æ’­æ”¾ç»“æŸåç»“æŸ Abilityï¼ˆå¯¹åº”è“å›¾è¿æ¥ EndAbilityï¼‰
    self:K2_EndAbility()
end

function M:ComputeRollDirectionAndDistance()
    local Character = self:GetHeroCharacterFromActorInfo()
    if not Character then
        UE.UKismetSystemLibrary.PrintString(self, "Character is invalid!")
        return
    end
    -- è·å–æœ€åä¸€æ¬¡æœ‰æ•ˆç§»åŠ¨è¾“å…¥å‘é‡ï¼Œå¹¶å½’ä¸€åŒ–
    local vector = Character:GetLastMovementInputVector()
    self.CachedRollingDirection = UE.UKismetMathLibrary.Normal(vector)
    -- å¯åŠ¨ä¸¤ä¸ªé¡ºåºä»»åŠ¡ï¼šTask1 è®¾ç½® WarpTargetï¼ŒTask2/3 åç»­å¤„ç†
    self:RunSequence()
end

function M:RunSequence()
    -- å¯¹åº”å­—å¹•ä¸­â€œSequenceâ€èŠ‚ç‚¹çš„è¡Œä¸º
    local Delay1 = UE.UAbilityTask_WaitDelay.WaitDelay(self, 0.05)  -- å»¶è¿Ÿä¿è¯è¾“å…¥ä¸è§’è‰²æ–¹å‘å·²å‡†å¤‡
    Delay1.OnFinish:Add(self, function()
        self:Task1()
        local Delay2 = UE.UAbilityTask_WaitDelay.WaitDelay(self, 0.05)  -- ç­‰å¾…è®©WarpTargetåº”ç”¨å
        Delay2.OnFinish:Add(self, function()
            self:Task2()
        end)
        Delay2:ReadyForActivation()
    end)
    Delay1:ReadyForActivation()
end

-- Task1: è®¾ç½®ç¬¬ä¸€ä¸ª WarpTargetï¼Œä¸åŠ¨ç”»å†…çš„ Motion Morphing Notify å¯¹åº”
function M:Task1()
    local Character = self:GetHeroCharacterFromActorInfo()
    -- æ„å»ºæ—‹è½¬æœå‘ï¼šæ ¹æ®è¾“å…¥æ–¹å‘å†³å®šé¢å‘
    local rot = UE.UKismetMathLibrary.MakeRotFromX(self.CachedRollingDirection)
    -- é¢„è®¾ä½ç½® self.TargetLocationï¼Œå¯ä»¥æ˜¯èµ·ç‚¹æˆ–å°„çº¿æ£€æµ‹å‰çš„ä¼°ç®—ä½ç½®
    Character.MotionWarpingComponent:AddOrUpdateWarpTargetFromLocationAndRotation(
        self.WarpTargetName, self.TargetLocation, rot)
end

-- Task2: ä½¿ç”¨å°„çº¿æ£€æµ‹åŠ¨æ€æŸ¥æ‰¾åœ°é¢ä½ç½®ï¼Œè®¾ç½®ç¬¬äºŒ WarpTargetï¼ˆç”¨äºæ§åˆ¶ç¿»æ»šè½ç‚¹ï¼‰
function M:Task2()
    UE.UKismetSystemLibrary.PrintString(self, "ä»»åŠ¡2æ‰§è¡Œ")
end

return M

```

### **æ»šåŠ¨è·ç¦»**

ç°åœ¨å¤„ç†çš„ç¬¬ä¸‰ä¸ªé—®é¢˜å°±æ˜¯ç¿»æ»šè·ç¦»ã€‚ä¸ºäº†åŠ¨æ€è®¡ç®—è·ç¦»ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦ä¸€ä¸ª Motion Morphing çš„ Unnotified çŠ¶æ€ã€‚æ¥ç€ï¼Œæˆ‘å°†æ·»åŠ ä¸€ä¸ªæ–°çš„é€šçŸ¥è½¨é“ï¼Œå†å³é”®ç‚¹å‡»æ·»åŠ ä¸€ä¸ª Motion Morphing çš„ Unnotified çŠ¶æ€ã€‚ç¬¬äºŒä¸ª Unnotified çŠ¶æ€ç”¨äºæ§åˆ¶ç¿»æ»šè·ç¦»ã€‚ç„¶åæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹é…ç½®å®ƒçš„å±æ€§ã€‚è¿›å…¥ Details é¢æ¿ï¼Œå°† World Target Name è®¾ç½®ä¸ºï¼šâ€œRollTargetLocationâ€ï¼Œå¹¶å‹¾é€‰ Warp Translationï¼Œå–æ¶ˆå‹¾é€‰ Warp Rotationã€‚è¿™æ ·ç¬¬äºŒä¸ª Morphing å°±åªæ§åˆ¶ä½ç§»è€Œä¸æ”¹å˜æ—‹è½¬ã€‚è®¾ç½®å®Œæˆåç‚¹å‡»ä¿å­˜ã€‚ç„¶åè¿”å›æˆ‘ä»¬çš„ Gameplay Ability Blueprintï¼Œæ¥è®¡ç®—ç¿»æ»šè·ç¦»ã€‚

**GA_Hero_Roll_Cç±»**

```lua
function M:Task2()
    local Character = self:GetHeroCharacterFromActorInfo()
    --UE.UKismetSystemLibrary.PrintString(self, "ä»»åŠ¡2æ‰§è¡Œ")

    -- ä»è§’è‰²è·å–å½“å‰ä½ç½®
    local vec = Character:K2_GetActorLocation()

    -- æ ¹æ® Ability ç­‰çº§å–ç¿»æ»šè·ç¦»ï¼ˆScalable Floatï¼‰ï¼Œåç»­å¯æ›¿ä»£ç¡¬ç¼–ç 
    local levelfloat = UE.UWarriorFunctionLibrary.GetScalableFloatValueAtLevel(
        self.RollingDistanceScalableFloat, self:GetAbilityLevel())

    -- Start = actor location + direction * è·ç¦» ï¼ˆå­—å¹•ä¸­ç¡¬ç¼–ç  100ï¼Œæ­¤å¤„ç”± Scalable Float æ›¿æ¢ï¼‰
    local startvec = vec + self.CachedRollingDirection * levelfloat

    -- å‘ä¸‹æ–¹å‘å‘é‡ï¼ˆUpVector * -1ï¼‰ï¼Œç”¨äºç”Ÿæˆ End ç‚¹
    local vec2 = Character:GetActorUpVector()
    local endvec = startvec + vec2 * -1.0 * 500.0  -- ä¸‹æ¢ 500 å•ä½æŸ¥æ‰¾åœ°é¢ â€”â€” æ¥æºå­—å¹•è¯´æ˜

    -- æ‰§è¡Œ LineTraceSingleForObjects æŸ¥è¯¢åœ°é¢ ImpactPoint
    local HitResult = UE.FHitResult()
    UE.UKismetSystemLibrary.LineTraceSingleForObjects(
        self,
        startvec,
        endvec,
        self.ObjectTypes,       -- EObjectTypeQuery æ•°ç»„å˜é‡
        false,                  -- TraceComplex = falseï¼ˆåªéœ€è¦ç¢°æ’ä½“ï¼‰
        UE.TArray(UE.AActor),   -- å¿½ç•¥åˆ—è¡¨ä¸ºç©º
        self.DrawDebugType or UE.EDrawDebugTrace.Persistent,
        HitResult,
        true
    )

    -- å¦‚æœæ’å‡»æœ‰æ•ˆï¼Œç”¨ ImpactPoint æ›´æ–°ç¬¬äºŒä¸ª WarpTargetï¼ˆåªæ§åˆ¶ translationï¼‰
    if HitResult:HasBlockingHit() then
        local MotionWarpingComp = Character.MotionWarpingComponent
        -- AddOrUpdateWarpTargetFromLocation: åªæ›´æ–°ä½ç§»ï¼Œä¸æ—‹è½¬ï¼Œä¸ç¬¬äºŒä¸ª Unnotified WarpAlign åŒºå—ä¸€è‡´ :contentReference[oaicite:1]{index=1}
        MotionWarpingComp:AddOrUpdateWarpTargetFromLocation(
            self.WarpTargetName1,
            HitResult.ImpactPoint
        )
    end
end

```

**WarriorFunctionLibraryç±»**

```c++
//WarriorFunctionLibrary.h  
struct FScalableFloat;

UFUNCTION(BlueprintPure, Category = "Warrior|FunctionLibrary", meta = (CompactNodeTitle = "Get Value At Level"))
    static float GetScalableFloatValueAtLevel(const FScalableFloat& InScalableFloat, float InLevel = 1.f);
//WarriorFunctionLibrary.cpp
float UWarriorFunctionLibrary::GetScalableFloatValueAtLevel(const FScalableFloat& InScalableFloat, float InLevel)
{
    return InScalableFloat.GetValueAtLevel(InLevel);
}
```

![](./Lesson Images/6-3.png)

åé¢åœ¨è’™å¤ªå¥‡ä¸­åŠ å…¥å£°éŸ³æ•ˆæœã€‚

## **å®šå‘å‡»ä¸­ååº”(Directional Hit React)**

ä»æœ¬èŠ‚å¼€å§‹ï¼Œæˆ‘ä»¬å°†ç€æ‰‹å®ç°è§’è‰²çš„â€œæ–¹å‘æ€§å‡»ä¸­ååº”â€ï¼ˆdirectional hit react abilityï¼‰ã€‚åŸºæœ¬ä¸Šï¼Œä¸ºäº†è¿™ä¸ªåŠŸèƒ½æˆ‘ä»¬éœ€è¦å¤„ç†ä¸¤ä¸ªéƒ¨åˆ†ï¼šå‡»ä¸­ååº”èƒ½åŠ›æœ¬èº«ï¼Œä»¥åŠå¦‚ä½•è®¡ç®—å‡»ä¸­æ–¹å‘ã€‚

### å‡»ä¸­ååº”èƒ½åŠ›

é¦–å…ˆæ¥çœ‹å®ç°å‡»ä¸­ååº”èƒ½åŠ›æœ¬èº«éœ€è¦åšå“ªäº›å†…å®¹ã€‚æˆ‘ä»¬é¦–å…ˆéœ€è¦åˆ›å»ºä¸€ä¸ªå‡»ä¸­ååº”èƒ½åŠ›è“å›¾ï¼Œç„¶åä¸ºå‡»ä¸­ååº”å‡†å¤‡åŠ¨ç”»è’™å¤ªå¥‡ï¼ˆanim montagesï¼‰ã€‚æ¥ç€ï¼Œéœ€è¦å°†è¯¥èƒ½åŠ›æˆäºˆè‹±é›„è§’è‰²ï¼Œæœ€åè®¾è®¡è§¦å‘æ–¹å¼è§¦å‘å®ƒã€‚

* å‡»ä¸­ååº”èƒ½åŠ›è“å›¾
* å‡»ä¸­ååº”è’™å¤ªå¥‡
* æˆäºˆå‡»ä¸­ååº”èƒ½åŠ›
* è§¦å‘å‡»ä¸­ååº”èƒ½åŠ›

é¦–å…ˆåˆ›å»ºè“å›¾å’Œè’™å¤ªå¥‡ï¼Œé€‰æ‹© â€œWarrior Hero Gameplay Abilityâ€ ä½œä¸ºçˆ¶ç±»ï¼Œå°†å…¶é‡å‘½åä¸º `GA_Hero_HitReact`ã€‚

åˆ›å»ºè’™å¤ªå¥‡ï¼Œå°†å®ƒä»¬çš„ Slot Name ä» `DefaultSlot` æ”¹ä¸º `UpperBody`ï¼Œå› ä¸ºè§’è‰²å¯åœ¨å‡»ä¸­æ—¶ç§»åŠ¨ä¸‹åŠèº«ã€‚

![](./Lesson Images/6-4.png)

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬è¦å­¦ä¹ æ€æ ·æˆäºˆè¯¥èƒ½åŠ›ï¼Œå¹¶è§¦å‘â€™å‘½ä¸­ååº”â€™ï¼ˆhit react abilityï¼‰ã€‚

æˆ‘åˆ‡å› Content Browser â†’ æ‰“å¼€è§’è‰²æ•°æ®èµ„äº§ï¼Œåœ¨ ReactiveAbilities æ•°ç»„ä¸­æ·»åŠ  GA_Hero_HitReactã€‚å®Œæˆåä¿å­˜ã€‚è‡³æ­¤ï¼Œèƒ½åŠ›æˆäºˆå·²å®Œæˆã€‚ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬éœ€è¦è§¦å‘è§’è‰²çš„ hit react èƒ½åŠ›ã€‚è¿™ä¸ªè§¦å‘æ“ä½œæˆ‘ä»¬ä¼šæ”¾åœ¨æ•Œäººçš„è¿‘æˆ˜æ”»å‡»èƒ½åŠ›ä¸­ã€‚åˆ‡åˆ° Shared â†’ GameplayAbility â†’ æ‰“å¼€ GA_Warrior_Enemy_MeleeAttack_Base å‡½æ•° HandleApplyDamageã€‚åœ¨æ”¶åˆ° shared.event.meleehit å¹¶åº”ç”¨ä¼¤å®³åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œè§¦å‘è‹±é›„çš„ hit react èƒ½åŠ›ã€‚éšåæˆ‘ä»¬æ·»åŠ hit react çš„ç‰¹æ•ˆã€‚

æ·»åŠ å®Œç‰¹æ•ˆåè®¡ç®—â€œå‘½ä¸­ååº”æ–¹å‘â€ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“ä»æˆ‘ä»¬è§’è‰²æŒ‡å‘æ•Œäººçš„å‘é‡ä¸æˆ‘ä»¬è§’è‰²çš„å‘å‰å‘é‡ä¹‹é—´çš„è§’åº¦å·®ï¼Œæ ¹æ®åœ¨è¿™é‡Œå¾—åˆ°çš„è§’åº¦å·®ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“è¦æ’­æ”¾å“ªä¸ªè’™å¤ªå¥‡ã€‚

```lua
-- GA_Warrior_Enemy_MeleeAttack_Base_C.lua
-- UnLuaï¼šæ•Œäººè¿‘æˆ˜æ”»å‡»èƒ½åŠ›ä¸­çš„ Hit React / Block æµç¨‹é€»è¾‘ï¼ˆå¸¦å»¶è¿Ÿæ•ˆæœï¼‰

---@type GA_Warrior_Enemy_MeleeAttack_Base_C
local M = UnLua.Class()

-- å½“ Ability æ¥æ”¶åˆ° GameplayEvent æ—¶æ‰§è¡Œï¼ˆå®¢æˆ·ç«¯ã€æœåŠ¡å™¨å‡å¯æ‰§è¡Œï¼‰
-- @param Payloadï¼šåŒ…å« Instigatorã€Target ç­‰ä¸Šä¸‹æ–‡ä¿¡æ¯çš„ FGameplayEventData ç»“æ„ä½“
function M:OnEventReceived(Payload)
    -- åŸæ³¨é‡Šçš„è°ƒè¯•ä»£ç ç•¥å†™åœ¨è¿™é‡Œæ–¹ä¾¿æ—¥åå¯ç”¨ Debug
    --[[
    local instigatorName = "InvalidInstigator"
    local targetName = "InvalidTarget"
    if Payload.Instigator and Payload.Instigator:IsValid() then
        instigatorName = Payload.Instigator:GetName()
    end
    if Payload.Target and Payload.Target:IsValid() then
        targetName = Payload.Target:GetName()
    end
    UE.UKismetSystemLibrary.PrintString(self, string.format("OnEventReceived: %s -> %s", instigatorName, targetName))
    ]]

    -- 1. Payload ä¸åˆæ³•æ—¶ç›´æ¥é€€å‡º
    if not Payload then
        return
    end

    -- 2. è½¬å…¥å¤„ç† Apply Damage + åç»­åé¦ˆé€»è¾‘
    self:HandleApplyDamage(Payload)
end

-- æ ¸å¿ƒä¼¤å®³å¤„ç†æµç¨‹ï¼ŒåŒ…æ‹¬æ–½åŠ GE Effectã€æ’­æ”¾Cueã€å»¶è¿Ÿè¿‡ç¨‹ï¼Œæœ€åè§¦å‘æ•ˆæœäº‹ä»¶
-- @param InPayloadï¼šFGameplayEventData åŒ…å« Instigatorã€Targetã€Effect causer ç­‰ä¿¡æ¯
function M:HandleApplyDamage(InPayload)
    -- 2.4 åœ¨å®Œæˆ Effect åº”ç”¨åï¼Œå¼€å§‹é¡ºåºæµç¨‹æ¨¡æ‹Ÿ Blueprint ä¸­çš„ Sequence ç»“æ„
    self:RunSequence()
end

-- æ¨¡æ‹Ÿ BP Sequence å»¶è¿Ÿæ‰§è¡Œ Task1ã€Task2
function M:RunSequence()
    -- 3.1 åˆ›å»ºç¬¬ä¸€ä¸ª Delay AbilityTaskï¼ˆå»¶è¿Ÿ 0.1 ç§’ï¼‰
    local Delay1 = UE.UAbilityTask_WaitDelay.WaitDelay(self, 0.1)
    Delay1.OnFinish:Add(self, function()
        -- 3.1.1 å»¶è¿Ÿå®Œæˆåæ‰§è¡Œ Task1
        self:Task1()

        -- 3.2 åˆ›å»ºç¬¬äºŒä¸ª Delay Taskï¼ˆå†å»¶è¿Ÿ 0.1 ç§’æ‰§è¡Œ Task2ï¼‰
        local Delay2 = UE.UAbilityTask_WaitDelay.WaitDelay(self, 0.1)
        Delay2.OnFinish:Add(self, function()
            self:Task2()
        end)
        -- æ¿€æ´»ç¬¬äºŒä¸ª Delay
        Delay2:ReadyForActivation()
    end)
    -- æ¿€æ´»ç¬¬ä¸€ä¸ª Delay
    Delay1:ReadyForActivation()
end

-- ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼šæ’­æ”¾å‡»ä¸­éŸ³æ•ˆ Cueï¼ˆæ— çŸ­æš‚æ ¹è¿åŠ¨ï¼‰
function M:Task1()
    -- åˆ›å»º FGameplayEffectContextï¼ˆå¯åŒ…å« Instigatorã€SourceObject ç­‰ä¸Šä¸‹æ–‡ï¼‰
    local Context = UE.FGameplayEffectContextHandle()
    -- ä½¿ç”¨ Ability è‡ªå¸¦æ–¹æ³•é€šè¿‡ tag è§¦å‘å£°æ•ˆ Cue
    self:K2_ExecuteGameplayCue(self.WeaponHitSoundGameplayCueTag, Context)
end

-- ç¬¬äºŒä¸ªä»»åŠ¡ï¼šå‡»ä¸­ä¹‹åè§¦å‘ç©å®¶çš„ Hit React Ability
function M:Task2()
    -- å‘æ”¶ä»¶å®ä½“ Player å‘é€ Gameplay Eventï¼Œæ¿€æ´» Hit React Ability
    UE.UAbilitySystemBlueprintLibrary.SendGameplayEventToActor(self.Targetactor, self.EventTag1, self.Payload)
end

return M

```

### è®¡ç®—å‡»ä¸­æ–¹å‘

åˆ›å»ºä¸€ä¸ªæ–°çš„è¾…åŠ©å‡½æ•°ï¼Œç”¨äºè®¡ç®—å‘½ä¸­ååº”æ–¹å‘ã€‚

é¦–å…ˆæˆ‘ä»¬éœ€è¦ææ˜ç™½ï¼Œå‘é‡ç§¯ï¼šåœ¨å‘é‡ä»£æ•°ä¸­ï¼Œä¸¤ä¸ªå‘é‡çš„å‘é‡ç§¯è¢«ç§°ä¸ºâ€œcross productâ€ã€‚

- å®ƒæ˜¯ä¸¤ä¸ªå‘é‡çš„äºŒå…ƒè¿ç®—
- å®ƒå°†è¿”å›å¦ä¸€ä¸ªä¸ä¸¤è€…å‚ç›´çš„å‘é‡

![](./Lesson Images/6-5.png)

å½“æˆ‘ä»¬ç”¨å³æ‰‹è¡¨ç¤ºè¿™ä¸ªè¿‡ç¨‹çš„æ—¶å€™

- å½“æˆ‘ä»¬å¾—åˆ°ç¬¬ä¸‰ä¸ªå‘é‡æ˜¯æŒ‡å‘ä¸Šæ–¹çš„ï¼Œå°±çŸ¥é“äº†ç¬¬äºŒä¸ªå‘é‡bæ˜¯åœ¨ç¬¬äºŒä¸ªå‘é‡açš„å·¦ä¾§è¿˜æ˜¯å³ä¾§

ä½†æ˜¯åœ¨è™šå¹»å¼•æ“ä¸­ä½¿ç”¨çš„æ˜¯å·¦æ‰‹åæ ‡ç³»ï¼Œæˆ‘ä»¬å®é™…éœ€è¦ä½¿ç”¨å·¦æ‰‹ï¼Œè€Œä¸æ˜¯å³æ‰‹æ³•åˆ™æ¥è¡¨ç¤ºè¿™ä¸‰ä¸ªå‘é‡ï¼Œè¿™æ ·æˆ‘ä»¬çš„ç»“æœå°±æ˜¯å®Œå…¨ç›¸åçš„

- å½“ç¬¬äºŒä¸ªå˜é‡ä½äºç¬¬ä¸€ä¸ªå˜é‡çš„å³ä¾§æ—¶ï¼Œç¬¬ä¸‰ä¸ªå˜é‡å‘ä¸Šï¼Œå¦‚æœåœ¨å·¦ä¾§ï¼Œç¬¬ä¸‰ä¸ªå˜é‡å°±æŒ‡å‘ä¸‹

**WarriorGameplayTagsç±»**

```c++
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Shared_Status_HitReact_Front);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Shared_Status_HitReact_Back);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Shared_Status_HitReact_Right);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Shared_Status_HitReact_Left);
```

**UWarriorFunctionLibraryç±»**

```c++
USTRUCT(BlueprintType)
struct FHitReactResult
{
    GENERATED_BODY()
    UPROPERTY(BlueprintReadOnly)
    float Angle;
    UPROPERTY(BlueprintReadOnly)
    FGameplayTag Tag;
};


UFUNCTION(BlueprintCallable, Category = "Warrior|FunctionLibrary")
// â‘  å¯¼å‡ºç»™ Blueprint / UnLua è°ƒç”¨ï¼Œè¿”å›è‡ªå®šä¹‰çš„ FHitReactResultï¼ˆéœ€ç”¨ USTRUCT å®šä¹‰ï¼Œå¹¶åœ¨å­—æ®µåŠ  UPROPERTY(BlueprintReadWrite)ï¼‰
static FHitReactResult ComputeHitReactDirectionTag(
    AActor* InAttacker,
    AActor* InVictim
);
#include "Kismet/KismetMathLibrary.h"
FHitReactResult UWarriorFunctionLibrary::ComputeHitReactDirectionTag(
    AActor* InAttacker,
    AActor* InVictim
) {
    // âš ï¸ å¿…é¡»æå‰åœ¨cppå¼€å¤´ include "Kismet/KismetMathLibrary.h"

    check(InAttacker && InVictim);
    // â‘¡ ç¡®ä¿ä¼ å…¥çš„å¤´å‘æ”»å‡»è€…å’Œå—å‡»è€…éƒ½æœ‰æ•ˆï¼ˆUBT åšä¸ºç©ºåˆ¤æ–­åå†è°ƒç”¨ï¼‰

    // --------------------------------------------
    // å‘é‡è®¡ç®—ï¼šå—å‡»è€…æœå‘ & æ”»å‡»è€…ç›¸å¯¹å‘é‡
    // --------------------------------------------
    const FVector VictimForward = InVictim->GetActorForwardVector();
    // â‘¢ å—å‡»è€…å½“å‰çš„å‰æ–¹å‘é‡ï¼ˆå•ä½é•¿åº¦ï¼‰

    FVector Diff = InAttacker->GetActorLocation() - InVictim->GetActorLocation();
    const FVector VictimToAttackerNormalized = Diff.GetSafeNormal();
    // â‘£ æ”»å‡»è€…ç›¸å¯¹äºå—å‡»è€…çš„ä½ç½®å‘é‡å½’ä¸€åŒ–

    // --------------------------------------------
    // è®¡ç®—å¤¹è§’ â€”â€” use dot product + acos = å¾—åˆ° [0Â°,180Â°]
    // --------------------------------------------
    const float DotResult = FVector::DotProduct(VictimForward, VictimToAttackerNormalized);
    FHitReactResult HitReactResult;
    HitReactResult.Angle = UKismetMathLibrary::DegAcos(DotResult);
    // â‘¤ è®¡ç®—ä¸¤å‘é‡çš„ cos Î¸ï¼Œç„¶ååä½™å¼¦è½¬è§’åº¦ã€‚è¿™é‡Œè¿”å›çš„æ˜¯æ­£å€¼ï¼ˆç»å¯¹è§’åº¦ï¼‰

    // --------------------------------------------
    // ç”¨ cross product åˆ¤æ–­è§’åº¦ç¬¦å·ï¼šå·¦ä¸ºè´Ÿã€å³ä¸ºæ­£
    // æ³¨æ„ UE ä½¿ç”¨å·¦æ‰‹åæ ‡ç³»ï¼ˆä¸ DirectX / Unity åŒè½´å‘å®šä¹‰ï¼‰ï¼Œcross_product æ–¹å‘ä¸æ‰‹æŒ‡æ–¹å‘å¯¹åº”[Source]
    // --------------------------------------------
    const FVector CrossResult = FVector::CrossProduct(VictimForward, VictimToAttackerNormalized);
    if (CrossResult.Z < 0.f) {
        HitReactResult.Angle *= -1.f;
    }
    // â‘¥ UE/Unity ä½¿ç”¨å·¦æ‰‹åæ ‡ç³»ã€‚è‹¥ cross çš„ Z åˆ†é‡å°äº 0 â†’ æ”»å‡»è€…åœ¨è§’è‰²å·¦ä¾§ï¼Œå› æ­¤å°†è§’åº¦å–è´Ÿå€¼ :contentReference[oaicite:1]{index=1}

    // --------------------------------------------
    // æ ¹æ®è§’åº¦èŒƒå›´åˆ†æ”¯ï¼Œé€‰æ‹©å¯¹åº”çš„ GameplayTag
    // âš ï¸ è®°å¾—æå‰åˆå§‹åŒ–ï¼š
    // Shared_Status_HitReact_XXX éƒ½æ˜¯é™æ€ Tag å¸¸é‡ï¼Œå¿…é¡»åœ¨ .h ä¸­æå‰ç”¨ FGameplayTag::RequestGameplayTag() æˆ– GameplayTags ç®¡ç†å™¨é‡Œå»ºç«‹
    // --------------------------------------------
    float A = HitReactResult.Angle;
    if (A >= -45.f && A <= +45.f) {
        // -45Â° ~ +45Â° â†’ æ­£é¢ï¼ˆæ”»å‡»è€…åœ¨æ­£å‰æ–¹ï¼‰
        HitReactResult.Tag = WarriorGameplayTags::Shared_Status_HitReact_Front;
    }
    else if (A < -45.f && A >= -135.f) {
        // -45Â° ~ -135Â° â†’ å·¦ä¾§ï¼ˆæ”»å‡»æ¥è‡ªå·¦ï¼‰
        HitReactResult.Tag = WarriorGameplayTags::Shared_Status_HitReact_Left;
    }
    else if (A < -135.f || A > +135.f) {
        // è¶…è¿‡ Â±135Â° â†’ èƒŒé¢ï¼ˆæ”»å‡»æ¥è‡ªåæ–¹ï¼‰
        HitReactResult.Tag = WarriorGameplayTags::Shared_Status_HitReact_Back;
    }
    else /*A > 45 && A <= 135*/ {
        // +45Â° ~ +135Â° â†’ å³ä¾§ï¼ˆæ”»å‡»æ¥è‡ªå³ï¼‰
        HitReactResult.Tag = WarriorGameplayTags::Shared_Status_HitReact_Right;
    }

    return HitReactResult;
}

```



```lua
--[[ 
   GA_Hero_Hit_React_C.lua 
   æ–¹å‘æ€§ Hit React èƒ½åŠ›é€»è¾‘æµç¨‹è§£æ
--]]

---@type GA_Hero_Hit_React_C
local M = UnLua.Class()

-- èƒ½åŠ›é€šè¿‡ Gameplay Event æ¿€æ´»æ—¶è°ƒç”¨
function M:K2_ActivateAbilityFromEvent(EventData)
    -- [1] è·å–è¢«å‡»ä¸­ç›®æ ‡è§’è‰²
    local InVictim = self:GetHeroCharacterFromActorInfo()
    -- [2] è°ƒç”¨è‡ªå®šä¹‰å‡½æ•°è®¡ç®—å‡»ä¸­æ–¹å‘æ ‡ç­¾å’Œè§’åº¦
    local HitResult = UE.UWarriorFunctionLibrary.ComputeHitReactDirectionTag(EventData.Instigator, InVictim)
    -- å½“æ— æœ‰æ•ˆç»“æœæ—¶ç›´æ¥é€€å‡º
    if not HitResult then
        UE.UKismetSystemLibrary.PrintString(self, "HitResult is invalid!")
        return
    end

    -- [3] å°†è§’åº¦æ ¼å¼åŒ–ä¸ºä¸¤ä½å°æ•°ä¾¿äºè°ƒè¯•è¾“å‡º
    local s = string.format("%.2f", HitResult.Angle)
    -- è·å– GameplayTag çš„å­—ç¬¦ä¸²å½¢å¼
    local tag = UE.UBlueprintGameplayTagLibrary.GetDebugStringFromGameplayTag(HitResult.Tag)
    -- print å¯ä»¥åœ¨è°ƒè¯•æ—¶å¼€å¯
    -- UE.UKismetSystemLibrary.PrintString(self, "AngleDiff" .. s .. " " .. tag)

    -- [4] ä» MontageMapï¼ˆUnreal TMap< FGameplayTag, UAnimMontage* >ï¼‰ä¸­æŸ¥æ‰¾å¯¹åº”åŠ¨ç”»
    -- æ³¨æ„ï¼šLua ç«¯è¦ä½¿ç”¨ :Find() è€Œä¸æ˜¯ .Find
    local MontagetoPlay = self.MontageMap:Find(HitResult.Tag)

    -- [5] å¦‚æœ MontageMap ä¸­æ²¡æœ‰å¯¹åº”çš„åŠ¨ç”»ï¼Œå¯ä»¥é€‰ fallback
    -- if not MontagetoPlay then MontagetoPlay = self.DefaultMontage end

    -- [6] åˆ›å»ºå¹¶é…ç½® PlayMontageAndWait ä»»åŠ¡
    -- UAbilityTask_PlayMontageAndWait: ç”¨äºæ’­æ”¾ Montage ç„¶åç­‰å¾…å…¶ç»“æŸ  
    local PlayMontageTask = UE.UAbilityTask_PlayMontageAndWait.CreatePlayMontageAndWaitProxy(
        self,                     -- æ‰€å± Ability å¯¹è±¡
        "PlayMontageTask",        -- ä»»åŠ¡åç§°ï¼ˆè°ƒè¯•æ ‡è¯†ï¼‰
        MontagetoPlay             -- è¦æ’­æ”¾çš„åŠ¨ç”»èµ„æº
        -- é»˜è®¤çš„æœªæä¾›å¯é€‰å‚æ•°ï¼ˆé€Ÿç‡/å¼€å§‹ Section ç­‰ï¼‰
    )

    -- [7] ä¸ºå„ä¸ªé€šçŸ¥äº‹ä»¶ç»‘å®šå›è°ƒå‡½æ•° OnMontage
    PlayMontageTask.OnCompleted:Add(self, M.OnMontage)
    PlayMontageTask.OnBlendOut:Add(self, M.OnMontage)
    PlayMontageTask.OnInterrupted:Add(self, M.OnMontage)
    PlayMontageTask.OnCancelled:Add(self, M.OnMontage)
    -- å¤‡æ³¨ï¼šå¦‚æœä¸æƒ³è¢«æ‰“æ–­ï¼Œå¯ä»¥å»é™¤ OnInterrupted å›è°ƒ

    -- [8] æ¿€æ´» Montage æ’­æ”¾ä»»åŠ¡
    PlayMontageTask:ReadyForActivation()

    -- [9] æ’­æ”¾ Montage æ—¶æ‰“å¼€æè´¨å‡»ä¸­ç‰¹æ•ˆ
    local Target = self:GetOwningComponentFromActorInfo()
    Target:SetScalarParameterValueOnMaterials("HitFxSwitch", 1.0)
end

-- æ‰€æœ‰ Montage ç»“æŸæ—¶è°ƒç”¨ï¼Œç»Ÿä¸€ç»“æŸ Ability
function M:OnMontage()
    -- ç­‰åŒäº Blueprint ä¸­è¿æ¥äº† EndAbility èŠ‚ç‚¹
    self:K2_EndAbility()
end

-- Ability ç»“æŸæ—¶è°ƒç”¨ï¼ˆåŒ…æ‹¬ç”¨æˆ·å–æ¶ˆï¼‰
function M:K2_OnEndAbility()
    -- å…³é—­æè´¨å‡»ä¸­æ•ˆæœ
    local Target = self:GetOwningComponentFromActorInfo()
    Target:SetScalarParameterValueOnMaterials("HitFxSwitch", 0.0)
end

return M

```

æ’­æ”¾å—å‡»åŠ¨ä½œä¸æ˜æ˜¾æ˜¯å› ä¸ºæˆ‘ä»¬ä¹‹å‰è®¾ç½®äº†ä¸ŠåŠèº«æ’æ§½çš„è’™å¤ªå¥‡ä¸ä¸‹åŠèº«è¿›è¡Œäº†æ··åˆï¼Œæˆ‘ä»¬ç°åœ¨æ¥é‡å†™è®¾ç½®ä¸€ä¸‹ï¼Œåœ¨è§’è‰²é™æ­¢ä¸åŠ¨çš„æ—¶å€™å°±ä¸è¿›è¡Œæ··åˆ

![](./Lesson Images/6-6.png)

è¢«å‡»ä¸­éŸ³æ•ˆåœ¨è’™å¤ªå¥‡ä¸­æ·»åŠ ã€‚

## é˜²å¾¡æ ¼æŒ¡(Block/Parry)

ä»æœ¬èŠ‚å¼€å§‹ï¼Œæˆ‘ä»¬å°†ç€æ‰‹ä¸ºè‹±é›„è§’è‰²åˆ›å»ºâ€”â€”æ ¼æŒ¡èƒ½åŠ›ã€‚

- æµç¨‹ï¼š
  - æ·»åŠ æ–°èƒ½åŠ›
  - è§¦å‘è¿™ä¸ªçš„è¾“å…¥éœ€è¦ä¸€ç›´æŒ‰ç€ï¼Œæ¾å¼€å°±å–æ¶ˆè¯¥èƒ½åŠ›
  - è§¦å‘äº†è¿™ä¸ªèƒ½åŠ›å°±è¦ä¸€ç›´å¾ªç¯åŠ¨ç”»
  - æ’­æ”¾è¿™ä¸ªåŠ¨ç”»éœ€è¦æœ‰è§†è§‰åé¦ˆ
  - æ ¼æŒ¡çš„é€»è¾‘

### æ·»åŠ æ–°èƒ½åŠ›å’Œè§¦å‘è¿™ä¸ªçš„è¾“å…¥éœ€è¦ä¸€ç›´æŒ‰ç€ï¼Œæ¾å¼€å°±å–æ¶ˆè¯¥èƒ½åŠ›

é¦–å…ˆåˆ›å»ºéœ€è¦çš„èƒ½åŠ›æ ‡ç­¾

```c++
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(InputTag_MustBeHeld);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(InputTag_MustBeHeld_Block);
```

é¦–å…ˆåœ¨æˆ‘ä»¬è§’è‰²çš„ç±»ä¸­ä¹‹å‰æ²¡æœ‰å†™å…¥é€»è¾‘çš„å…³äºèƒ½åŠ›è¾“å…¥çš„é‡Šæ”¾å‡½æ•°ä¸­å»å†™å…¥é‡Šæ”¾æ ¼æŒ¡èƒ½åŠ›çš„é€»è¾‘

**WarriorAbilitySystemComponentç±»**

```c++
//WarriorAbilitySystemComponent.h
// è¾“å…¥é‡Šæ”¾æ—¶ï¼ˆä¾‹å¦‚ç©å®¶æ¾å¼€æŸä¸ªæŒ‰é”®ï¼‰è°ƒç”¨æœ¬å‡½æ•°
void OnAbilityInputReleased(const FGameplayTag& InInputTag);
//WarriorAbilitySystemComponent.cpp
void UWarriorAbilitySystemComponent::OnAbilityInputReleased(const FGameplayTag& InInputTag)
{
    // â‘  å¦‚æœæ ‡ç­¾æ— æ•ˆæˆ–ä¸å±äºæˆ‘ä»¬å…³å¿ƒçš„â€œå¿…é¡»æŒç»­æŒ‰ä¸‹æ‰èƒ½ç”Ÿæ•ˆâ€çš„è¾“å…¥
    if (!InInputTag.IsValid()
        || !InInputTag.MatchesTag(WarriorGameplayTags::InputTag_MustBeHeld))
    {
        return; // è·³è¿‡æ‰€æœ‰èƒ½åŠ›å–æ¶ˆé€»è¾‘
    }

    // â‘¡ éå†å½“å‰ ASC ç®¡ç†çš„æ‰€æœ‰ activatable ability specs
    for (const FGameplayAbilitySpec& AbilitySpec : GetActivatableAbilities())
    {
        // â‘¢ å¦‚æœè¿™ä¸ª spec çš„ DynamicAbilityTags ç²¾ç¡®åŒ…å«ä¼ å…¥çš„æ ‡ç­¾ï¼Œ
        //     å¹¶ä¸”è¯¥ Ability ç°åœ¨æ­£åœ¨è¿è¡Œï¼ˆIsActiveï¼‰
        if (AbilitySpec.DynamicAbilityTags.HasTagExact(InInputTag)
            && AbilitySpec.IsActive())
        {
            // â‘£ ä½¿ç”¨è¯¥ spec çš„ Handle å‘ ASC è¯·æ±‚å–æ¶ˆè¿™ä¸ªèƒ½åŠ›
            CancelAbilityHandle(AbilitySpec.Handle);
        }
    }
}

```

ç„¶åç»§ç»­å®šä¹‰ä¸¤ä¸ªæ ‡ç­¾ï¼Œç”¨æ¥è¡¨ç¤ºè§’è‰²çš„å­¦ä¹ çš„æ ¼æŒ¡èƒ½åŠ›ä¸å½“å‰èƒ½åŠ›çš„çŠ¶æ€

```c++
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Ability_Block);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Status_Blocking);
```

åˆ›å»ºæ ¼æŒ¡èƒ½åŠ›

![](./Lesson Images/6-7.png)

å°†è¿™ä¸ªèƒ½åŠ›ç»™åˆ°è§’è‰²ï¼Œè¿™ä¸ªèƒ½åŠ›å¿…é¡»è¦åœ¨è£…å¤‡äº†æ­¦å™¨ä¹‹åæ‰èƒ½ä½¿ç”¨

![](./Lesson Images/6-8.png)

![](./Lesson Images/6-9.png)

![](./Lesson Images/6-10.png)

### è§¦å‘äº†è¿™ä¸ªèƒ½åŠ›å°±è¦ä¸€ç›´å¾ªç¯åŠ¨ç”»å’Œè§†è§‰åé¦ˆ

* å¾ªç¯è’™å¤ªå¥‡ç‰‡æ®µ

![](./Lesson Images/6-11.png)

* æ ¼æŒ¡è’™å¤ªå¥‡çš„EndAbilityï¼Œåªéœ€è¦è¿æ¥ä¸­æ–­ä¸å–æ¶ˆå°±è¡Œï¼Œå› ä¸ºé˜»æŒ¡èƒ½åŠ›ä¸æ˜¯é˜»æŒ¡æ‰€æœ‰çš„æ”»å‡»ï¼Œæœ‰äº›ç‰¹åˆ«çš„æ”»å‡»æ˜¯ä¸å¯ä»¥é˜»æŒ¡çš„ã€‚

ä½¿ç”¨Add GameplayCueWithParams To OwnerèŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªæŒä¹…çš„GCè¿›è¡Œä»¥åŠæ¿€æ´»GC

**GA_Hero_Block_Cç±»**

```lua
---@type GA_Hero_Block_C
local M = UnLua.Class()

-- æ¿€æ´»æ ¼æŒ¡æŠ€èƒ½æ—¶è°ƒç”¨
function M:K2_ActivateAbility()
    -- è®°å½•æ ¼æŒ¡è§¦å‘æ—¶çš„ä¸–ç•Œæ—¶é—´ï¼Œç”¨ä»¥æ£€æµ‹â€œå®Œç¾æ ¼æŒ¡â€
    self.HeroBlockTime = UE.UGameplayStatics.GetTimeSeconds(self:GetWorld())

    -- æ’­æ”¾è’™å¤ªå¥‡ï¼ˆåŠ¨ç”»æ®µï¼‰ï¼Œå¹¶ç­‰å¾…å…¶ç»“æŸæˆ–è¢«æ‰“æ–­
    -- ä½¿ç”¨ CreatePlayMontageAndWaitProxy è¿”å›çš„ä»£ç† task
    local PlayMontageTask = UE.UAbilityTask_PlayMontageAndWait.CreatePlayMontageAndWaitProxy(
        self,
        "PlayMontageTask",     -- Task çš„åå­—ï¼Œç”¨äºå†…éƒ¨æ ‡è¯†
        self.MontagetoPlay     -- è¦æ’­æ”¾çš„åŠ¨ç”»è’™å¤ªå¥‡
    )
    -- OnInterrupted / OnCancelled éƒ½ç»‘å®šåˆ° M.OnMontage æ–¹æ³•
    PlayMontageTask.OnInterrupted:Add(self, M.OnMontage)
    PlayMontageTask.OnCancelled:Add(self, M.OnMontage)
    -- æ‰‹åŠ¨è°ƒç”¨ ReadyForActivation æ‰ä¼šå¯åŠ¨ taskï¼ˆLua ä¸ C++/BP å·®å¼‚ï¼‰
    PlayMontageTask:ReadyForActivation()

    -- æ‰‹åŠ¨è¿›å…¥ä¸‹ä¸€ä¸ªé€»è¾‘é˜¶æ®µï¼ˆåœ¨æ­¤ç”¨ RunSequence æ¨¡æ‹Ÿåç¨‹è¡Œä¸ºï¼‰
    self:RunSequence()
end

-- æ¨¡æ‹Ÿå¯ä¸²è¡Œçš„â€œåºåˆ—æ‰§è¡Œâ€ï¼šTask1 ç„¶å Task2
-- æ³¨æ„ï¼šæ­¤å¤„å¹¶ä¸æ˜¯ Await / Delayï¼Œè€Œæ˜¯ç«‹å³è§¦å‘ä¸¤ä¸ª task
function M:RunSequence(MyTarget, Parameters)
    -- Task1ï¼šç«‹å³æ‰§è¡Œ Gameplay Cue æç¤º
    self:Task1()
    -- Task2ï¼šç­‰å¾…å‘½ä¸­äº‹ä»¶
    self:Task2()
end

-- æ˜¾å¼è°ƒç”¨ä¸€æ¬¡ Gameplay Cue é€šçŸ¥ï¼Œé€šå¸¸ç”¨äºæ ¼æŒ¡è§†è§‰åé¦ˆ
function M:Task1()
    local GCvalue = self:MakeMakeGameplayCue()
    -- K2_AddGameplayCueWithParams ä¼šåœ¨ ASC ä¸­æŒç»­æ˜¾ç¤º cueï¼Œç›´åˆ°æŠ€èƒ½ç»“æŸ
    self:K2_AddGameplayCueWithParams(self.GameplayCueTag, GCvalue)
end

function M:OnMontage()
    -- Montage æ’­æ”¾ç»“æŸåç»“æŸ Abilityï¼ˆå¯¹åº”è“å›¾è¿æ¥ EndAbilityï¼‰
    self:K2_EndAbility()
    self:StartResetJumpToFinisherTimer()
end
```

è¿™æ¬¡æˆ‘ä»¬éœ€è¦åˆ›å»ºGCçš„ä¸‹åˆ’çº¿å¸¦Actorç‰ˆæœ¬ï¼Œè€Œä¸æ˜¯ä¹‹å‰çš„Staticç‰ˆæœ¬ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›è¿™ä¸ªGCåœ¨è¯¥èƒ½åŠ›å¤„äºæ´»åŠ¨çŠ¶æ€æ—¶ä¿æŒæ´»åŠ¨çŠ¶æ€ã€‚

![](./Lesson Images/6-12.png)

![](./Lesson Images/6-13.png)

* é‡å†™è¿™ä¸ªGCé‡Œé¢çš„While Activeå‡½æ•°ï¼Œæ’­æ”¾éŸ³æ•ˆä¸ç‰¹æ•ˆï¼Œä»¥åŠé‡å†™On Removeå‡½æ•°ï¼Œæ¥åˆ é™¤ç‰¹æ•ˆ

**GC_Hero_Magic_Shield_Cç±»**

```lua
--[[============================================================================
  ç¢ç‰‡è·¯å¾„ï¼šGC_Hero_Magic_Shield_C.lua
  è¯´æ˜ï¼šä¸ºâ€œé­”æ³•ç›¾ç‰Œâ€ç‰¹æ•ˆçš„ GameplayCue è„šæœ¬ï¼Œé‡‡ç”¨ UnLua å†™æ³•ã€‚
  è§¦å‘æ—¶æœºï¼šç”± GameplayEffect æˆäºˆå¯¹åº” GameplayTag æ—¶æ¿€æ´»ã€‚
============================================================================]]

---@type GC_Hero_Magic_Shield_C
local M = UnLua.Class()

--- å½“ Gameplay Cue è¢«æ¿€æ´»ï¼Œå¹¶ä¸” GamePlayEffect æŒç»­ç”Ÿæ•ˆæ—¶ï¼Œ
--- Unreal ä¼šå¤šæ¬¡è°ƒç”¨æ­¤å‡½æ•°ï¼ˆæ¯å¸§ä¸€æ¬¡ã€æˆ–æ¯æ¬¡ç‰¹æ•ˆé‡åº”ç”¨æ—¶ï¼‰
--- è¿”å› false è¡¨ç¤º â€œè‡ªå·±ä¸ä¼šå†é‡ç”Ÿâ€ ï¼ˆå¯¹åŒ tag çš„é‡å¤è°ƒç”¨ä¸é˜»å¡ï¼‰
--- WaitingForRemoval ç›´åˆ° trigger remove æ—¶æ­¤ Cue æ‰ clean upã€‚
function M:WhileActive(MyTarget, Parameters)
    self:RunSequence(MyTarget, Parameters)  -- å¯åŠ¨é¢„è®¾â€œä»»åŠ¡é“¾â€
    return false
end

--[[ ç”¨â€œé¡ºåºè°ƒç”¨â€æ¨¡æ‹Ÿè“å›¾ä¸­ Sequence -> Delay çš„è¡Œä¸ºã€‚
   ä½†ç›®å‰ç¼ºå°‘å»¶è¿Ÿæœºåˆ¶ï¼ŒTask1 å’Œ Task2 å°†åœ¨åŒä¸€å¸§ç«‹å³æ‰§è¡Œã€‚ ]]
function M:RunSequence(MyTarget, Parameters)
    -- å»¶è¿Ÿ 0.1 ç§’åæ‰§è¡Œ Task1ï¼ˆæ³¨ï¼šæ­¤æ³¨é‡Šæ˜¯é¢„æœŸï¼ŒLua ä¸è‡ªåŠ¨å»¶è¿Ÿï¼‰
    self:Task1(MyTarget)

    -- å»¶è¿Ÿ 0.2 ç§’åæ‰§è¡Œ Task2ï¼ˆæ³¨ï¼šä»åœ¨åŒä¸€å¸§æ‰§è¡Œï¼‰
    self:Task2(Parameters)
end

--- Task1ï¼šæ’­æ”¾å£°éŸ³ï¼ˆå¯å‚è€ƒå®æ—¶éŸ³æ•ˆåé¦ˆï¼‰
function M:Task1(MyTarget)
    local location = MyTarget:K2_GetActorLocation()
    UE.UGameplayStatics.PlaySoundAtLocation(self, self.Sound, location)
end

--- Task2ï¼šç”Ÿæˆ Niagara ç‰¹æ•ˆå¹¶é™„åŠ åˆ°ç›®æ ‡ç»„ä»¶çš„ MagicShieldSocket æ’æ§½
function M:Task2(Parameters)
    -- SpawnSystemAttached çš„ç­¾åï¼š
    -- (NiagaraSystem, AttachToComponent, SocketName, ...)
    self.Magicsystem =
      UE.UNiagaraFunctionLibrary.SpawnSystemAttached(
        self.SystemTemplate,
        Parameters.TargetAttachComponent,
        "MagicShieldSocket"
    )
end

--- OnRemoveï¼šå½“ GameplayCue è¢«ç§»é™¤æ—¶è°ƒç”¨ï¼ˆå³ GameplayEffect ç»“æŸï¼‰
--- åˆ‡å‹¿æ¼æ‰æ¸…ç†ç‰¹æ•ˆç»„ä»¶ï¼Œä»¥å…æ®‹ç•™å†…å­˜æˆ–è§†è§‰åƒåœ¾
function M:OnRemove(MyTarget, Parameters)
    -- å¦‚æœ Niagara ç»„ä»¶ç¡®å®å­˜åœ¨ï¼Œå°†å…¶é”€æ¯
    if self.Magicsystem then
        self.Magicsystem:K2_DestroyComponent(self)
        self.Magicsystem = nil  -- é˜²æ­¢é‡é”€æ¯
    end

    -- è¿”å› false è¡¨ç¤ºç»§ç»­æ‰§è¡Œæ ‡å‡† Cleanupï¼ˆä¸é˜»æ­¢é»˜è®¤å›æ”¶æœºåˆ¶ï¼‰
    return false
end

return M

```

### æ ¼æŒ¡é€»è¾‘

æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨å¦‚ä½•**å¤„ç†æ ¼æŒ¡é€»è¾‘**ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬éœ€è¦å®Œæˆçš„é€»è¾‘åˆ¤æ–­ã€‚

* ç©å®¶å½“å‰æ˜¯å¦å¤„äºæ ¼æŒ¡çŠ¶æ€ï¼Ÿ
* åˆ¤æ–­æ ¼æŒ¡æ˜¯å¦æœ‰æ•ˆ
* æ‰§è¡Œâ€œæˆåŠŸæ ¼æŒ¡â€çš„åç»­æ“ä½œ
* å®Œç¾æ ¼æŒ¡

åœ¨æ ¼æŒ¡çš„èƒ½åŠ›ä¸­ï¼Œæˆ‘ä»¬è®¾ç½®äº†è§¦å‘æ­¤èƒ½åŠ›å°±ä¼šæ¿€æ´»Player_Status_Blockingè¿™ä¸ªæ ‡ç­¾çŠ¶æ€ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦æ£€æŸ¥è¿™ä¸ªæ ‡ç­¾æ˜¯å¦å­˜åœ¨å°±èƒ½çŸ¥é“ç©å®¶æ˜¯å¦åœ¨æ ¼æŒ¡çŠ¶æ€ä¸­

å…³äºæ˜¯å¦é˜»æŒ¡æœ‰æ•ˆé—®é¢˜ï¼Œæˆ‘ä»¬åªéœ€è¦æ£€æŸ¥æ•Œäººä¸è§’è‰²çš„å‘å‰å‘é‡ï¼Œå¦‚æœå‘å‰å‘é‡å½¼æ­¤æŒ‡å‘ï¼Œé‚£ä¹ˆè¿™ä¸ªé˜»æŒ¡å°±æ˜¯æœ‰æ•ˆçš„

![](./Lesson Images/6-14.png)

å¦‚æœï¼Œæ•Œäººä¸è§’è‰²çš„å‘å‰å‘é‡æ˜¯å½¼æ­¤å‚ç›´çš„è¯ï¼Œé‚£å°±è¯´æ˜è¿™ä¸ªé˜»æŒ¡æ˜¯æ— æ•ˆçš„

![](./Lesson Images/6-15.png)

* åœ¨æˆ‘ä»¬çš„å‡½æ•°åº“é‡Œé¢æ–°å»ºä¸€ä¸ªè¾…åŠ©å‡½æ•°ç”¨æ¥åˆ¤æ–­æ˜¯å¦æ˜¯æœ‰æ•ˆæ ¼æŒ¡
* æ€è·¯ï¼šè®¡ç®—ç‚¹ç§¯ï¼Œå¾—åˆ°æ”»å‡»è€…ä¸é˜²å¾¡è€…çš„å‘å‰å‘é‡ï¼Œè¿›è¡Œç‚¹ç§¯è®¡ç®—
  * ç‚¹ç§¯ç»“æœå¯ä»¥ç”¨äºåˆ¤æ–­ä¸¤ä¸ªå‘é‡ä¹‹é—´çš„å¤¹è§’å…³ç³»ï¼š
    * å¦‚æœç‚¹ç§¯ä¸ºæ­£æ•°ï¼Œè¡¨ç¤ºä¸¤ä¸ªå‘é‡ä¹‹é—´çš„å¤¹è§’å°äº90åº¦ï¼Œæ–¹å‘ç›¸ä¼¼
    * å¦‚æœç‚¹ç§¯ä¸ºé›¶ï¼Œè¡¨ç¤ºä¸¤ä¸ªå‘é‡å‚ç›´
    * å¦‚æœç‚¹ç§¯ä¸ºè´Ÿæ•°ï¼Œè¡¨ç¤ºä¸¤ä¸ªå‘é‡ä¹‹é—´çš„å¤¹è§’å¤§äº90åº¦ï¼Œæ–¹å‘ç›¸å

**WarriorFunctionLibraryç±»**

```c++
// WarriorFunctionLibrary.h
UFUNCTION(BlueprintPure, Category = "Warrior|FunctionLibrary")
static bool IsValidBlock(AActor* InAttacker, AActor* InDenfender);

// WarriorFunctionLibrary.cpp
bool UWarriorFunctionLibrary::IsValidBlock(AActor* InAttacker, AActor* InDenfender)
{
    // å¦‚æœä¼ å…¥æŒ‡é’ˆéæ³•ï¼ˆnullptrï¼‰ï¼Œä¼šè§¦å‘æ–­è¨€å´©æºƒç”¨äºè°ƒè¯•æ—¶ç«‹å³åé¦ˆé—®é¢˜ã€‚
    // check å®åœ¨ Debug æ¨¡å¼æœ‰æ•ˆï¼Œshipping builds ä¼šå¿½ç•¥ã€‚
    check(InAttacker && InDenfender);

    // è®¡ç®—æ”»å‡»è€…å’Œé˜²å¾¡è€…æ­£æ–¹å‘forward vectorï¼ˆå•ä½å‘é‡ï¼‰çš„ç‚¹ä¹˜ã€‚
    // FVector::DotProduct è¿”å›èŒƒå›´ [-1,1]ï¼Œä¸¤å‘é‡å®Œå…¨å¯¹ç«‹ï¼ˆ180Â°ï¼‰æ—¶ä¸º -1ï¼Œ
    // ç›¸åŒæ–¹å‘æ—¶ä¸º +1ï¼Œçº¦ä¸º â€œcoså¤¹è§’ Ã— magnitudesâ€ã€‚
    const float DotResult =
        FVector::DotProduct(
            InAttacker->GetActorForwardVector(),
            InDenfender->GetActorForwardVector()
        );

    // ä»¥ä¸‹æ˜¯ç”¨äºè°ƒè¯•çš„å­—ç¬¦ä¸²æ„é€ ï¼Œå½“å‰è¢«æ³¨é‡Šï¼šå¯è¾“å‡º DotResult å€¼æ–¹ä¾¿è°ƒè¯•
    // const FString DebugString =
    //     FString::Printf(TEXT("DotResult: %f %s"), DotResult,
    //         DotResult < -0.1f ? TEXT("Valid Block") : TEXT("Invalid Block"));
    // Debug::Print(DebugString, DotResult < -0.1f ? FColor::Green : FColor::Red);

    // å¦‚æœä¸¤ä¸ª forward å‘é‡çš„ç‚¹ä¹˜å°äº -0.1ï¼ˆçº¦å¤¹è§’ > ~96Â°ï¼‰ï¼Œåˆ¤æ–­ä¸ºæœ‰æ•ˆæ ¼æŒ¡
    return DotResult < -0.1f;
}

```

* ç„¶ååœ¨æˆ‘ä»¬ä¹‹å‰çš„æ•Œäººçš„æˆ˜æ–—ç»„ä»¶ç±»ä¸­æ²¡æœ‰å¤„ç†æ ¼æŒ¡çš„é€»è¾‘é‡Œé¢å†™ä¸Šé€»è¾‘

![](./Lesson Images/6-16.png)



* æ–°å»ºä¸€ä¸ªæ ‡ç­¾ç”¨æ¥ä¼ é€’ä¿¡æ¯

```c++
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Event_SuccessfulBlock);
```

* æ ¼æŒ¡æˆåŠŸå°±å‘é€è¿™ä¸ªæ ‡ç­¾

**EnemyCombatComponentç±»**

```c++
    if (IsValidBlock)
    {   //å¤„ç†æ ¼æŒ¡æˆåŠŸ
        UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(HitActor, WarriorGameplayTags::Player_Event_SuccessfulBlock, EventData);
    }
    else
    {
        UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(GetOwningPawn(), WarriorGameplayTags::Shared_Event_MeleeHit, EventData);
    }
```

* åœ¨æ ¼æŒ¡èƒ½åŠ›ä¸­æ¥æ”¶è¿™ä¸ªäº‹ä»¶ï¼Œåç»­åšé€»è¾‘å¤„ç†

**GA_Hero_Block_Cç±»**

```lua
---@type GA_Hero_Block_C
local M = UnLua.Class()

--- å‚ç›´ Entry Pointï¼šå½“ Ability è¢«ç³»ç»Ÿè°ƒç”¨æ¿€æ´»æ—¶æ‰§è¡Œ
function M:K2_ActivateAbility()
    -- âœ… è®°å½•æ ¼æŒ¡è§¦å‘ç¬é—´çš„ä¸–ç•Œæ—¶é—´æˆ³ï¼Œç”¨äºåˆ¤æ–­å®Œç¾æ ¼æŒ¡
    self.HeroBlockTime = UE.UGameplayStatics.GetTimeSeconds(self:GetWorld())  -- GetGameTimeInSeconds, ä¼šå— slomo å½±å“ :contentReference[oaicite:1]{index=1}

    -- ğŸ¬ å¯åŠ¨ PlayMontageAndWait ä»»åŠ¡
    local PlayMontageTask = UE.UAbilityTask_PlayMontageAndWait.CreatePlayMontageAndWaitProxy(
        self,                     -- æ‰€å± Ability
        "PlayBlockMontage",       -- Task åç§°
        self.MontagetoPlay        -- è¦æ’­æ”¾çš„ Animation Montage
    )
    -- ğŸ¯ å¼ºçƒˆæ¨èç»‘å®šæ‰€æœ‰å¯èƒ½ç»“æŸè·¯å¾„å›è°ƒï¼š
    PlayMontageTask.OnInterrupted:Add(self, M.OnMontage)
    PlayMontageTask.OnCancelled:Add(self, M.OnMontage)
    -- è‹¥é—æ¼ OnBlendOut æˆ– OnCompletedï¼ŒMontage ç»“æŸä¹Ÿå¯èƒ½ä¸ä¼šç»ˆç»“ Abilityâ€‚:contentReference[oaicite:2]{index=2}
    PlayMontageTask:ReadyForActivation()

    -- ğŸ§© å¯åŠ¨ Capability çš„é€»è¾‘é“¾ï¼ˆåŒæ—¶ Task1 & Task2ï¼‰
    self:RunSequence()
end

--- æ¨¡æ‹Ÿè“å›¾ä¸­ Sequence + Delay èŠ‚ç‚¹çš„æ„å›¾ï¼ŒLua ä¸­åºåˆ—é¡ºåºä¸ºç«‹å³æ‰§è¡Œ
function M:RunSequence()
    -- ğŸ“Œ è¿™é‡Œæ³¨é‡Šä¸­å†™äº†â€œå»¶è¿Ÿ 0.1sâ€ï¼Œä½† Lua ä¼šç«‹å³æ‰§è¡Œï¼Œè‹¥éœ€å»¶è¿Ÿåº”å¦è¡Œä½¿ç”¨ WaitDelay æˆ– Timer Delegate
    self:Task1()  -- æ˜¾ç¤ºæŒç»­æ€§ visual cue
    self:Task2()  -- æ„é€ äº‹ä»¶ç›‘å¬ä»»åŠ¡
end

--- Task1ï¼šæ’­æ”¾æŒç»­çš„æ ¼æŒ¡è§†è§‰åé¦ˆï¼ˆä¾‹å¦‚æŒç»­å…‰ç¯ã€é¥°å“æç¤ºç­‰ï¼‰
function M:Task1()
    local GCvalue = self:MakeMakeGameplayCue()
    -- AddCueï¼šæŒç»­çŠ¶æ€å‹ Cueï¼Œä¼šéš Ability ç”Ÿå‘½å‘¨æœŸç»“æŸè‡ªåŠ¨æ¸…é™¤â€‚:contentReference[oaicite:3]{index=3}
    self:K2_AddGameplayCueWithParams(self.GameplayCueTag, GCvalue)
end

--- Task2ï¼šè®¾ç½®ç›‘å¬ GameplayEventTag çš„ä»»åŠ¡ï¼Œç­‰å¾…å‘½ä¸­æ—¶è§¦å‘å›è°ƒ
function M:Task2()
    -- åˆ›å»º WaitGameplayEvent ä»»åŠ¡ç›‘å¬ self.EventTagï¼ŒOnlyTriggerOnce=false å¯å¤šæ¬¡å“åº”
    local WaitEventTask = UE.UAbilityTask_WaitGameplayEvent.WaitGameplayEvent(
        self,
        self.EventTag
    )
    WaitEventTask.EventReceived:Add(self, M.OnEventReceived)
    WaitEventTask:ReadyForActivation()
end

--- å½“ Payload.EventReceived è§¦å‘æ—¶æ‰§è¡Œï¼šå¤„ç†è½¬å‘ã€å‡»é€€ä¸æ ¼æŒ¡åé¦ˆ
function M:OnEventReceived(Payload)
    -- ğŸ† å®Œç¾æ ¼æŒ¡åˆ¤å®šï¼šè§¦å‘æ—¶é—´ä¸è®°å½•æ—¶é—´é—´éš”å°äºç­‰äº 0.25 ç§’
    local bPerfectBlock =
        UE.UGameplayStatics.GetTimeSeconds(self:GetWorld()) - self.HeroBlockTime <= 0.25

    -- â€”â€” è½¬å‘æ”»å‡»æ¥æº Actorï¼Œè®©è§’è‰²é¢å‘å‘½ä¸­è€…
    local character = self:GetHeroCharacterFromActorInfo()
    local Start = character:K2_GetActorLocation()
    local Target = Payload.Instigator:K2_GetActorLocation()
    local Rot = UE.UKismetMathLibrary.FindLookAtRotation(Start, Target)
    character:K2_SetActorRotation(Rot, false)

    -- â€”â€” åˆ©ç”¨æ ¹è¿åŠ¨æ¨è¿›è§’è‰²åé€€
    local fv = character:GetActorForwardVector() * -1.0
    local Task_RM = UE.UAbilityTask_ApplyRootMotionConstantForce.ApplyRootMotionConstantForce(
        self,
        "RollRootMotion",
        fv,
        80.0,
        0.2,
        false,
        nil,
        UE.ERootMotionFinishVelocityMode.MaintainLastRootMotionVelocity,
        UE.FVector(0,0,0),
        0.0,
        true
    )
    Task_RM:ReadyForActivation()  -- å¯åŠ¨ root-motion ä»»åŠ¡ :contentReference[oaicite:4]{index=4}

    -- â€”â€” æ’­æ”¾ä¸€æ¬¡æ€§æ ¼æŒ¡åé¦ˆ Cue ï¼ˆéŸ³æ•ˆ/ç‰¹æ•ˆï¼‰
    local GCvalue1 = self:MakeMakeGameplayCue()
    self:K2_ExecuteGameplayCueWithParams(self.GameplayCueTag1, GCvalue1)

    if bPerfectBlock then
        -- â€”â€” å®Œç¾æ ¼æŒ¡åˆ†æ”¯å¤„ç†
        UE.UWarriorFunctionLibrary.AddGameplayTagToActorIfNone(character, self.PerfectBlockTag)
        local GCvalue2 = self:MakeMakeGameplayCue()
        self:K2_ExecuteGameplayCueWithParams(self.GameplayCueTag2, GCvalue2)

        local world = self:GetWorld()
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 0.2)  -- è®¾ç½®æ…¢åŠ¨ä½œæ•ˆæœ :contentReference[oaicite:5]{index=5}

        -- ä½¿ç”¨ Lua coroutine + Delay åšçŸ­æš‚å»¶è¿Ÿæ¢å¤æ—¶é—´è†¨èƒ€ï¼ˆä½†ä¸ç»‘å®š Ability ç”Ÿå‘½å‘¨æœŸï¼Œè¾ƒè„†å¼±ï¼‰
        coroutine.resume(coroutine.create(function()
            UE.UKismetSystemLibrary.Delay(world, 0.08)  -- è°ƒç”¨ Latent Delayï¼Œé Ability ç»“æŸç»‘å®š :contentReference[oaicite:6]{index=6}
            UE.UGameplayStatics.SetGlobalTimeDilation(world, 1.0)
        end))
    end
end

--- Montage çš„ä¸­æ–­æˆ–å–æ¶ˆå…±åŒè·¯å¾„å¤„ç†ï¼šç»“æŸèƒ½åŠ›å¹¶è§¦å‘ tag æ¸…ç† timer
function M:OnMontage()
    self:K2_EndAbility()
    self:StartResetJumpToFinisherTimer()
end

--- è‹¥ Ability åœ¨å…¶å®ƒè·¯å¾„é€€å‡ºï¼Œç¡®ä¿ä¸–ç•Œæ—¶é—´è¢«å¤ä½
function M:K2_OnEndAbility()
    local world = self:GetWorld()
    if UE.UGameplayStatics.GetGlobalTimeDilation(world) ~= 1.0 then
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 1.0)
    end
end

--- Timer Delegate è®¾ç½®ï¼Œç”¨äºå»¶è¿Ÿæ¸…é™¤ PerfectBlockTag
function M:StartResetJumpToFinisherTimer()
    UE.UKismetSystemLibrary.K2_SetTimerDelegate({self, self.ResetJumpToFinisherState}, 0.3)
end

--- Timer å›è°ƒï¼šç§»é™¤ PerfectBlockTag
function M:ResetJumpToFinisherState()
    UE.UWarriorFunctionLibrary.RemoveGameplayTagFromActor(self:GetHeroCharacterFromActorInfo(), self.PerfectBlockTag)
    return
end

--- å·¥å…·å‡½æ•°ï¼šæ„é€ ä¸€ä¸ªé»˜è®¤çš„ GameplayCueParameters ç»“æ„ä½“
function M:MakeMakeGameplayCue()
    local SkeletalMeshComp = self:GetOwningComponentFromActorInfo()
    local zeroVec = UE.FVector(0, 0, 0)
    local zeroTag = UE.FGameplayTag()
    local zeroTagContainer = UE.FGameplayTagContainer()
    local context = UE.FGameplayEffectContextHandle()
    return UE.UAbilitySystemBlueprintLibrary.MakeGameplayCueParameters(
        0.0, 0.0,
        context,
        zeroTag, zeroTag,
        zeroTagContainer, zeroTagContainer,
        zeroVec, zeroVec,
        nil, nil, nil, nil,
        1, 1,
        SkeletalMeshComp,
        false
    )
end

return M

```

**Hero_LightAttackMasterç±»**

```c++
void UHero_LightAttackMaster::BlockJumpToFinisher()
{ 
    if (UWarriorFunctionLibrary::NativeDoesActorHaveTag(GetHeroCharacterFromActorInfo(), JumpTag))
        {
            CurrentLightAttackComboCount = AttackMontagesMap.Num();
        }
}
```

## **ç›®æ ‡é”å®š(Target Lock)**

ä»æœ¬èŠ‚å¼€å§‹ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢ç©¶è‹±é›„è§’è‰²çš„â€œé”å®šç›®æ ‡ï¼ˆTarget Lockï¼‰â€èƒ½åŠ›ã€‚

* è¾“å…¥æœºåˆ¶ï¼šæ‹¥æœ‰å¯åˆ‡æ¢çš„åŸºç¡€èƒ½åŠ›
* æŸ¥æ‰¾å€™é€‰ç›®æ ‡ï¼Œåœ¨ç›®æ ‡é”å®šä¹‹å‰è¦è·å–å…³å¡ä¸­æ‰€æœ‰å¯ç”¨çš„ç›®æ ‡ç„¶åè¿›è¡Œå…¶ä¸­çš„ä¸€ä¸ªé”æ•Œ
* è¦å°†é”æ•Œçš„å°éƒ¨ä»¶ç»˜åˆ¶åˆ°å±å¹•ä¸Šï¼Œæ¯å¸§æ›´æ–°åœ¨å…¶è§†å£çš„ä½ç½®ï¼Œå¹¶ä¸”è¿˜è¦æ›´æ–°ç©å®¶çš„æ—‹è½¬ä½ç½®è¦å®šå‘åœ¨ç›®æ ‡
* å½“å‰åˆ‡æ¢åˆ°é”å®šçš„åŠŸèƒ½åï¼Œåº”è¯¥åˆ‡æ¢åŠ¨ç”»åˆ°é”æ•Œçš„åŠ¨ç”»
* é”å®šç›®æ ‡æ˜¯å¯ä»¥åˆ‡æ¢çš„

### å¯åˆ‡æ¢çš„åŸºç¡€èƒ½åŠ›

æ–°å»ºä¸€ä¸ªç»§æ‰¿ Hero GameplayAbility çš„ç±»ï¼Œå‘½åä¸º HeroGameplayAbility_TargetLock

* é¦–å…ˆåˆ›å»ºæ ‡ç­¾

```c++
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(InputTag_Toggleable);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(InputTag_Toggleable_TargetLock);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Ability_TargetLock);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Status_TargetLock);
```

* ç„¶åé‡å†™æ¿€æ´»èƒ½åŠ›ä¸é‡Šæ”¾èƒ½åŠ›çš„å‡½æ•°

```c++
protected:
    //~ Begin UGameplayAbility Interface
    virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
    virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;
    //~ End UGameplayAbility Interface
```

* åˆ›å»ºé”æ•Œè¿™ä¸ªèƒ½åŠ›

![](./Lesson Images/6-17.png)



* æ¥ä¸‹æ¥è§£å†³å¦‚ä½•æˆäºˆå’Œæ¿€æ´»æ­¤èƒ½åŠ›ï¼Œä¿®æ”¹ä¹‹å‰UWarriorAbilitySystemComponentç±»ä¸­çš„OnAbilityInputPressedä¸­æ¿€æ´»èƒ½åŠ›çš„é€»è¾‘

```c++
// UWarriorAbilitySystemComponent.cpp

void UWarriorAbilitySystemComponent::OnAbilityInputPressed(
    const FGameplayTag& InputTag)
{
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // 1. é¦–å…ˆæ£€æŸ¥ä¼ å…¥çš„ InputTag æ˜¯å¦æœ‰æ•ˆï¼ˆé˜²ç©º/é˜² Crashï¼‰
    if (!InputTag.IsValid())
    {
        return;           // æ— æ•ˆæ ‡ç­¾ç›´æ¥è·³è¿‡
    }

    // 2. éå†æ‰€æœ‰å¯æ¿€æ´»çš„ ABILITY SPECï¼ˆFGameplayAbilitySpecï¼‰ï¼Œè¿™æ˜¯ GAS çš„æ ¸å¿ƒæ•°æ®ç»“æ„
    for (const FGameplayAbilitySpec& AbilitySpec :
         GetActivatableAbilities())
    {
        // 3. ç­›é€‰å‡ºä¸è¾“å…¥æ ‡ç­¾å®Œå…¨åŒ¹é…ï¼ˆHasTagExactï¼‰çš„èƒ½åŠ›
        //    DynamicAbilityTags æ˜¯åœ¨ GiveAbility æ—¶åŠ¨æ€èµ‹å€¼çš„ä¸€ç»„ TAG
        if (!AbilitySpec.DynamicAbilityTags.HasTagExact(InputTag))
        {
            continue;       // æ²¡æœ‰å…³è”æ­¤è¾“å…¥æ ‡ç­¾çš„ ability è·³è¿‡
        }

        // 4. å¦‚æœè¿™ä¸ªæ ‡ç­¾å±äº â€œå¯åˆ‡æ¢ï¼toggle ç±»å‹â€ çš„è¾“å…¥
        if (InputTag.MatchesTag(
                WarriorGameplayTags::InputTag_Toggleable))
        {
            // â€”â€” Toggleable ç±»å‹çš„ ability é‡åˆ°åŒæ ·æ ‡ç­¾å†æ¬¡æŒ‰ä¸‹æ—¶è§†ä½œå–æ¶ˆ
            if (AbilitySpec.IsActive())
            {
                // 5a. å¦‚æœè¯¥èƒ½åŠ›å·²æ¿€æ´»ï¼Œåˆ™å–æ¶ˆå®ƒ
                CancelAbilityHandle(AbilitySpec.Handle);
            }
            else
            {
                // 5b. å¦åˆ™å°è¯•æ¿€æ´»èƒ½åŠ›
                TryActivateAbility(AbilitySpec.Handle);
            }
        }
        else
        {
            // 6. è‹¥ä¸æ˜¯å¯åˆ‡æ¢ç±»å‹ï¼Œå°±ä¸€å¾‹å°è¯•æ¿€æ´»
            TryActivateAbility(AbilitySpec.Handle);
        }
    }
}

```

* æ·»åŠ èƒ½åŠ›

![](./Lesson Images/6-18.png)

### æŸ¥æ‰¾å€™é€‰ç›®æ ‡

* æ€è·¯ï¼šä½¿ç”¨ç›’å­ç¢°æ’è¿›è¡Œæ£€æµ‹èŒƒå›´å†…çš„Actors

**HeroGameplayAbility_TargetLockç±»**

```c++
// HeroGameplayAbility_TargetLock.h
private:
    /** ä¿å­˜æœ‰æ•ˆçš„å¯é”å®š Actor åˆ—è¡¨ */
    UPROPERTY()
    TArray<AActor*> AvailableActorsToLock;

    /** å½“å‰é€‰å®šçš„é”å®šç›®æ ‡ï¼Œç”¨äºæ¯å¸§æ—‹è½¬æˆ– UI ç»˜åˆ¶ */
    UPROPERTY()
    AActor* CurrentLockedActor = nullptr;

    /** Trace æœ€å¤§æ£€æµ‹è·ç¦»ï¼Œç”±ç¼–è¾‘å™¨é…ç½® */
    UPROPERTY(EditDefaultsOnly, Category = "TargetLock")
    float BoxTraceDistance = 5000.f;

    /** Trace åŠå°ºå¯¸ç›’å‹å¤§å°ï¼ŒZ è½´ç¼©çª„å¯é¿å…æ£€æµ‹åœºæ™¯åœ°æ¿ */
    UPROPERTY(EditDefaultsOnly, Category = "TargetLock")
    FVector TraceBoxSize = FVector(5000.f, 5000.f, 300.f);

    /** æŒ‡å®šæœ¬æ¬¡ trace æ£€æµ‹çš„ç¢°æ’é€šé“ï¼ˆå¦‚ Pawn å¯¹è±¡ï¼‰ */
    UPROPERTY(EditDefaultsOnly, Category = "TargetLock")
    TArray<TEnumAsByte<EObjectTypeQuery>> BoxTraceChannel;

    /** æ˜¯å¦åœ¨æ¸¸æˆä¸­æŒç»­æ˜¾ç¤ºè°ƒè¯•ç”¨ç›’å­å½¢çŠ¶ */
    UPROPERTY(EditDefaultsOnly, Category = "TargetLock")
    bool bShowPersistentDebugShape = false;

    /** åœ¨ Ability æ¿€æ´»æ—¶ç¬¬ä¸€ä¸ªè¿è¡Œæ–¹æ³•ï¼šæ”¶é›†å¯é”å®šç›®æ ‡ */
    void TryLockOnTarget();

    /** ä½¿ç”¨ BoxTraceMulti è·å–æ‰€æœ‰å¯é”å®š Actor å¹¶å¡«å……æ•°ç»„ AvailableActorsToLock */
    void GetAvailableActorsToLock();

    /** ä» AvailableActorsToLock ä¸­è¿”å›è·ç¦»ç©å®¶æœ€è¿‘çš„ç›®æ ‡ */
    AActor* GetNearestTargetFromAvailableActors(const TArray<AActor*>& InAvailable);

    /** å¦‚æœæ²¡æœ‰ç›®æ ‡æˆ–éœ€è¦å–æ¶ˆèƒ½åŠ›æ—¶è°ƒç”¨ */
    void CancelTargetLockAbility();

    /** èƒ½åŠ›ç»“æŸæ—¶æ¸…ç†çŠ¶æ€ï¼ŒåŒ…æ‹¬æ¸…ç©ºå½“å‰ç›®æ ‡å’Œå€™é€‰åˆ—è¡¨ */
    void Cleanup();

// HeroGameplayAbility_TargetLock.cpp
#include "HeroGameplayAbility_TargetLock.h"
#include "Kismet/KismetSystemLibrary.h"
#include "Kismet/GameplayStatics.h"
#include "Characters/WarriorHeroCharacter.h"
#include "WarriorDebugHelper.h" 
void UHeroGameplayAbility_TargetLock::ActivateAbility(
    const FGameplayAbilitySpecHandle Handle,
    const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo,
    const FGameplayEventData* TriggerEventData)
{
    // ä¸€æ—¦æ¿€æ´»æœ¬èƒ½åŠ›ï¼Œå°±ç«‹å³å°è¯•é”å®šç›®æ ‡
    TryLockOnTarget();

    Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
}

void UHeroGameplayAbility_TargetLock::EndAbility(
    const FGameplayAbilitySpecHandle Handle,
    const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo,
    bool bReplicateEndAbility,
    bool bWasCancelled)
{
    // èƒ½åŠ›ç»“æŸæ—¶æ¸…ç†ä¸´æ—¶çŠ¶æ€
    Cleanup();
    Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

void UHeroGameplayAbility_TargetLock::TryLockOnTarget()
{
    // ä»å‰æ–¹èŒƒå›´å†…è·å–æ‰€æœ‰å¯é€‰é”å®šå¯¹è±¡
    GetAvailableActorsToLock();

    if (AvailableActorsToLock.IsEmpty())
    {
        // æ— ç›®æ ‡å¯é”ï¼Œå–æ¶ˆæœ¬èƒ½åŠ›
        CancelTargetLockAbility();
        return;
    }

    // é€‰æ‹©æœ€è¿‘çš„ä½œä¸ºé”å®šç›®æ ‡
    CurrentLockedActor = GetNearestTargetFromAvailableActors(AvailableActorsToLock);
    if (CurrentLockedActor)
    {
        Debug::Print(CurrentLockedActor->GetActorNameOrLabel());
    }
    else
    {
        CancelTargetLockAbility();
    }
}

void UHeroGameplayAbility_TargetLock::GetAvailableActorsToLock()
{
    // ç¡®ä¿æ¯æ¬¡é‡å»ºç›®æ ‡åˆ—è¡¨
    AvailableActorsToLock.Empty();

    TArray<FHitResult> BoxTraceHits;
    auto* Hero = GetHeroCharacterFromActorInfo();
    FVector HeroLoc = Hero->GetActorLocation();
    FVector HeroForward = Hero->GetActorForwardVector();

    // æ‰§è¡Œ BoxTraceMultiForObjects æ£€æµ‹å‰æ–¹æ‰€æœ‰å¯ç”¨ç›®æ ‡
    // æ­¤å‡½æ•°æ²¿çº¿ç§»åŠ¨ä¸€ä¸ª box å¹¶è¿”å›æ‰€æœ‰å‡»ä¸­å¯¹è±¡ï¼Œå…¶ä¸­ä»…æ£€æµ‹ ObjectTypes æŒ‡å®šçš„ç±»å‹
    // Epic å®˜æ–¹è¯´æ˜ï¼šæ‰«è¿‡ box åè¿”å›æ‰€æœ‰å‡»ä¸­çš„ hit ç»“æœï¼Œé˜»æŒ¡ç¢°æ’ä½äº hits æ•°ç»„æœ€åé¡¹:contentReference[oaicite:1]{index=1}
    bool bHit = UKismetSystemLibrary::BoxTraceMultiForObjects(
        Hero,                                             // world context
        HeroLoc,                                         // trace start
        HeroLoc + HeroForward * BoxTraceDistance,       // trace end
        TraceBoxSize / 2.f,                              // åŠå°ºå¯¸
        HeroForward.ToOrientationRotator(),              // box æœå‘
        BoxTraceChannel,                                 // æŒ‡å®šæ£€æµ‹çš„å¯¹è±¡ç±»å‹
        false,                                           // ä½¿ç”¨ç®€åŒ–ç¢°æ’ï¼Œä¸æ£€æŸ¥å¤æ‚æ¨¡å‹
        TArray<AActor*>(),                               // å¿½ç•¥çš„ actor åˆ—è¡¨ï¼ˆè¿™é‡Œä¸ºç©ºï¼‰
        bShowPersistentDebugShape
            ? EDrawDebugTrace::Persistent
            : EDrawDebugTrace::None,                     // è°ƒè¯•æ¨¡å¼ï¼ˆæŒç»­æ˜¾ç¤ºæˆ–ä¸æ˜¾ç¤ºï¼‰
        BoxTraceHits,                                    // è¾“å‡ºçš„ FHitResult æ•°ç»„
        true                                             // å¿½ç•¥è‡ªèº«ï¼ˆä¸»è§’ï¼‰
    );

    for (const FHitResult& Hit : BoxTraceHits)
    {
        if (AActor* HitActor = Hit.GetActor())
        {
            // æ’é™¤ä¸»è§’è‡ªèº«
            if (HitActor != Hero)
            {
                // AddUnique ç¡®ä¿ actor åœ¨åˆ—è¡¨ä¸­å”¯ä¸€
                AvailableActorsToLock.AddUnique(HitActor);
                // Debug::Print(HitActor->GetActorNameOrLabel());
            }
        }
    }
}

AActor* UHeroGameplayAbility_TargetLock::GetNearestTargetFromAvailableActors(
    const TArray<AActor*>& InAvailableActors)
{
    float ClosestDistance = 0.f;
    // UGameplayStatics::FindNearestActor ä»ç»™å®šæ•°ç»„ä¸­è¿”å›æœ€è¿‘çš„ Actor
    // å®˜æ–¹æ–‡æ¡£å®šä¹‰ï¼šæ ¹æ® Origin ä¸ ActorsToCheck ä¸­è·ç¦»æœ€å°è¿”å› Actor å’Œè·ç¦»:contentReference[oaicite:2]{index=2}
    return UGameplayStatics::FindNearestActor(
        GetHeroCharacterFromActorInfo()->GetActorLocation(),
        InAvailableActors,
        ClosestDistance);
}

void UHeroGameplayAbility_TargetLock::CancelTargetLockAbility()
{
    // è°ƒç”¨ GameplayAbility çš„ CancelAbility æ¥å–æ¶ˆæœ¬èƒ½åŠ›
    // å®˜æ–¹è¯´æ˜ï¼šCancelAbility ä¼šå¹¿æ’­ OnGameplayAbilityCancelledï¼Œå¹¶æœ€ç»ˆè°ƒç”¨ EndAbility
    // æ³¨æ„ï¼šè‹¥è°ƒç”¨è€…è®¾ç½®äº† CanBeCanceled ä¸º falseï¼Œå–æ¶ˆå¤±è´¥æ—¶è¿˜ä¼šæ”¶åˆ°è­¦å‘Šæç¤º:contentReference[oaicite:3]{index=3}
    CancelAbility(
        GetCurrentAbilitySpecHandle(),
        GetCurrentActorInfo(),
        GetCurrentActivationInfo(),
        true
    );
}

void UHeroGameplayAbility_TargetLock::Cleanup()
{
    AvailableActorsToLock.Empty();
    CurrentLockedActor = nullptr;
}
```

* æµ‹è¯•ä¸€ä¸‹

![](./Lesson Images/6-19.png)

### **ç»˜åˆ¶/æ›´æ–°ç›®æ ‡é”å®šæ§ä»¶**

* è¿™èŠ‚è¯¾æ¥å¤„ç†é”æ•Œä¹‹ååœ¨æ•Œäººèº«ä¸Šæ·»åŠ ä¸€ä¸ªè§†è§‰UI

![](./Lesson Images/6-20.png)

* ç»§ç»­æ·»åŠ é€»è¾‘ï¼Œæ–°å»ºç»˜åˆ¶é”å®šç›®æ ‡å›¾æ ‡çš„å‡½æ•°å’Œåˆ›å»ºçš„UIçš„å˜é‡

**HeroGameplayAbility_TargetLockç±»**

```c++
//HeroGameplayAbility_TargetLock.h  
    /** å¦‚æœªåˆ›å»ºåˆ™ç”Ÿæˆ Widget å®ä¾‹ï¼Œç”¨äºæ˜¾ç¤ºç›®æ ‡é”å®š UI */
    void DrawTargetLockWidget();

    /** å°†å½“å‰é”å®šç›®æ ‡è½¬æ¢ä¸ºå±å¹•ä½ç½®ï¼Œè°ƒæ•´ Widget åæ ‡ */
    void SetTargetLockWidgetPosition();

    /** Blueprint ä¸­è®¾ç½®æ‰€è¦å®ä¾‹åŒ–çš„ Widget Blueprint ç±»ç±»å‹ */
    UPROPERTY(EditDefaultsOnly, Category = "TargetLock")
    TSubclassOf<UWarriorWidgetBase> TargetLockWidgetClass;

    /** å½“å‰åˆ›å»ºçš„ Widget å®ä¾‹æŒ‡é’ˆ */
    UPROPERTY()
    UWarriorWidgetBase* DrawnTargetLockWidget;

    /** ç¼“å­˜ Widget çš„å°ºå¯¸ï¼ˆåƒç´ ï¼‰ä»¥ä¾¿å±…ä¸­å¯¹é½è°ƒæ•´ */
    UPROPERTY()
    FVector2D TargetLockWidgetSize = FVector2D::ZeroVector;
//HeroGameplayAbility_TargetLock.cpp
void UHeroGameplayAbility_TargetLock::TryLockOnTarget()
{
    GetAvailableActorsToLock();
    if (AvailableActorsToLock.IsEmpty())
    {
        CancelTargetLockAbility();
        return;
    }
    CurrentLockedActor = GetNearestTargetFromAvailableActors(AvailableActorsToLock);

    if (CurrentLockedActor)
    {
        // åˆ›å»ºå¹¶æ·»åŠ é”å®š UI åˆ°å±å¹•
        DrawTargetLockWidget();

        // ç«‹å³æ›´æ–°ç›®æ ‡ Widget çš„å±å¹•ä½ç½®
        SetTargetLockWidgetPosition();
    }
    else
    {
        CancelTargetLockAbility();
    }
}

void UHeroGameplayAbility_TargetLock::DrawTargetLockWidget()
{
    if (!DrawnTargetLockWidget)
    {
        checkf(TargetLockWidgetClass, TEXT("é¡»åœ¨ Blueprint ä¸­ä¸º TargetLockWidgetClass æŒ‡å®š Widget Blueprint ç±»ï¼"));
        // ä½¿ç”¨ CreateWidget åˆ›å»º Widget å®ä¾‹ï¼Œç”±å¯¹åº” PlayerController æ‹¥æœ‰
        DrawnTargetLockWidget = CreateWidget<UWarriorWidgetBase>(
            GetHeroControllerFromActorInfo(),
            TargetLockWidgetClass
        );
        check(DrawnTargetLockWidget);

        // å°† Widget æ·»åŠ åˆ°å±å¹•ä¸Šï¼šAddToViewportï¼Œæ˜¾ç¤ºç»™ç©å®¶ã€‚åç»­å¯åœ¨ Cleanup ä¸­ RemoveFromParentï¼›
        DrawnTargetLockWidget->AddToViewport();
        // å®˜æ–¹æ–‡æ¡£è¯´æ˜ï¼šCreateWidget + AddToViewport æ˜¯ UMG æ˜¾ç¤º Widget çš„æ ‡å‡†æµç¨‹ :contentReference[oaicite:1]{index=1}
    }
}

void UHeroGameplayAbility_TargetLock::SetTargetLockWidgetPosition()
{
    if (!DrawnTargetLockWidget || !CurrentLockedActor)
    {
        CancelTargetLockAbility();
        return;
    }

    // ä½¿ç”¨ WidgetLayoutLibrary å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸º Widget çš„å±å¹•åæ ‡
    // bPlayerViewportRelative = true æ„å‘³ç€è½¬æ¢ç»“æœå·²ç»è€ƒè™‘ Viewportã€DPI ç¼©æ”¾ç­‰å› ç´ ï¼Œ
    // å¯ç›´æ¥ç”¨äº SetPositionInViewport()
    FVector2D ScreenPosition;
    UWidgetLayoutLibrary::ProjectWorldLocationToWidgetPosition(
        GetHeroControllerFromActorInfo(),
        CurrentLockedActor->GetActorLocation(),
        ScreenPosition,
        true
    );
    // å®˜æ–¹ API æ–‡æ¡£ï¼šProjectWorldLocationToWidgetPosition å°† 3D ä¸–ç•Œä½ç½®æ˜ å°„ä¸º 2D Widget åæ ‡ :contentReference[oaicite:2]{index=2}

    if (TargetLockWidgetSize == FVector2D::ZeroVector)
    {
        // ç¬¬ä¸€æ¬¡è·å–å½“å‰ Widget å†… USizeBox çš„å®½/é«˜ï¼Œç”¨ä½œåç»­å±…ä¸­å¯¹é½
        DrawnTargetLockWidget->WidgetTree->ForEachWidget(
            [this](UWidget* FoundWidget)
            {
                if (USizeBox* SB = Cast<USizeBox>(FoundWidget))
                {
                    TargetLockWidgetSize.X = SB->GetWidthOverride();
                    TargetLockWidgetSize.Y = SB->GetHeightOverride();
                }
            }
        );
    }

    // å°†å±å¹•åæ ‡åç§»ä¸º Widget çš„å·¦ä¸Šè§’ä½ç½®ï¼Œä»¥ Widget å¤§å°å±…ä¸­äºç›®æ ‡ç‚¹
    ScreenPosition -= (TargetLockWidgetSize / 2.f);

    DrawnTargetLockWidget->SetPositionInViewport(ScreenPosition, false);
}

void UHeroGameplayAbility_TargetLock::Cleanup()
{
    AvailableActorsToLock.Empty();
    CurrentLockedActor = nullptr;

    if (DrawnTargetLockWidget)
    {
        // ä»çˆ¶ Widget æˆ– Viewport ä¸­ç§»é™¤ï¼Œè¯¥ Widget ä¸å†å¯è§
        DrawnTargetLockWidget->RemoveFromParent();
        // æ³¨æ„ï¼šRemoveFromParent ä¸ä¼šç«‹å³é”€æ¯ UObjectï¼Œä»…ä»è§†å›¾ä¸­ç§»é™¤ï¼Œ
        // GC å›æ”¶ä¾èµ–å¼•ç”¨æ¸…ç†ï¼Œå»ºè®®ä¹‹åæ˜¾å¼å°†æŒ‡é’ˆç½®ç©º :contentReference[oaicite:3]{index=3}
    }
    DrawnTargetLockWidget = nullptr;
    TargetLockWidgetSize = FVector2D::ZeroVector;
}
```

* å°†WBP_TargetLockIndicatoræ·»åŠ åˆ°èƒ½åŠ›ä¸Š



**è‡ªå®šä¹‰ `GameplayAbilityTask` æ”¯æŒæ¯å¸§æ‰§è¡Œï¼ˆTakingï¼‰é€»è¾‘**

ç”±äºé»˜è®¤ `GameplayAbility` Blueprint ä¸æä¾› Tickï¼ˆæ¯å¸§æ‰§è¡Œï¼‰èŠ‚ç‚¹ï¼Œè¦å®ç° UI å°éƒ¨ä»¶è·Ÿéšå’Œè§’è‰²æœå‘æ›´æ–°ï¼Œéœ€è¦åœ¨ Ability ä¸­æ¯å¸§æ‰§è¡Œé€»è¾‘ã€‚

**è§£å†³æ€è·¯**ï¼šè‡ªå®šä¹‰ `AbilityTask`ï¼Œå¼€å¯ Taking æ¨¡å¼ï¼Œæ”¯æŒæ¯å¸§è°ƒç”¨

**æ„å»ºæ­¥éª¤**ï¼š

1. **åˆ›å»º C++ ç±»ç»§æ‰¿ `UAbilityTask`**
    å‘½åå¦‚ `AbilityTask_ExecuteTaskOnTake`ï¼›
2. **å£°æ˜é™æ€å·¥å‚å‡½æ•°**
    `UFUNCTION(BlueprintCallable)` è¿”å›æŒ‡é’ˆï¼Œç”¨äºåœ¨è“å›¾ä¸­åˆ›å»º Taskï¼›
    ä½¿ç”¨ `meta=()` è®¾ç½®éšè—è¾“å…¥ã€é»˜è®¤è‡ªèº«ã€ä»… Blueprint å†…éƒ¨ä½¿ç”¨ï¼›
3. **è®¾ç½® `bIsRequestingTick = true`**
    åœ¨æ„é€ å‡½æ•°ä¸­å¯ç”¨ Taking æ¨¡å¼ï¼Œä»è€Œè§¦å‘ `TakeTask()`ï¼›
4. **é‡å†™ `TakeTask()` æ–¹æ³•**
   - è°ƒç”¨ `Super::TakeTask()`ï¼›
   - æ£€æŸ¥ `ShouldBroadcastAbilityTaskDelegates()`ï¼›
   - è‹¥ä»»åŠ¡ä»æœ‰æ•ˆï¼Œåˆ™å¹¿æ’­å§”æ‰˜ï¼›å¦åˆ™æ‰§è¡Œ `EndTask()`ï¼›
5. **å£°æ˜ Delegate è¾“å‡ºå˜é‡**
    `DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAbilityTaskTakeDelegate, float, DeltaTime);`
    `UPROPERTY(BlueprintAssignable)` expose Blueprint è¾“å‡ºã€‚
6. **è“å›¾ä¸­ä½¿ç”¨ç¤ºä¾‹**
   - åœ¨ Ability çš„ Event Graph ä¸­æ·»åŠ  `ExecuteTaskOnTake` èŠ‚ç‚¹ï¼›
   - è¿æ¥åˆ° `OnTake` Delegate â†’ `PrintString("Taking")` æµ‹è¯•æ¯å¸§è¾“å‡ºï¼›
   - è¿è¡Œæ—¶éªŒè¯ï¼šä¸æ–­çœ‹åˆ°å¤§é‡ â€œTakingâ€ ä¿¡æ¯æ‰“å°ï¼Œè¡¨ç¤º Taking æœºåˆ¶æœ‰æ•ˆã€‚

```c++
//AbilityTask_ExecuteTaskOnTick.h
#pragma once

#include "CoreMinimal.h"
#include "Abilities/Tasks/AbilityTask.h"
#include "AbilityTask_ExecuteTaskOnTick.generated.h"

// Blueprint å¯ç»‘å®šçš„ OnTick å§”æ‰˜ï¼Œä¼ å…¥æ¯å¸§çš„ DeltaTime
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAbilityTaskTickDelegate, float, DeltaTime);

UCLASS()
class MYWARRIOR_API UAbilityTask_ExecuteTaskOnTick : public UAbilityTask
{
    GENERATED_BODY()

public:
    // æ„é€ å‡½æ•°ï¼šå¼€å¯ bTickingTask ä»¥å…è®¸æ¯å¸§ TickTask() è¢«è°ƒç”¨
    UAbilityTask_ExecuteTaskOnTick();

    // åœ¨è“å›¾ä¸­åˆ›å»ºæœ¬ä»»åŠ¡èŠ‚ç‚¹çš„é™æ€å·¥å‚å‡½æ•°
    UFUNCTION(BlueprintCallable, Category = "Warrior|AbilityTasks",
        meta = (
            HidePin = "OwningAbility",
            DefaultToSelf = "OwningAbility",
            BlueprintInternalUseOnly = "true"
        ))
    static UAbilityTask_ExecuteTaskOnTick* ExecuteTaskOnTick(UGameplayAbility* OwningAbility);

    //~ Begin UGameplayTask interface
    virtual void TickTask(float DeltaTime) override;
    //~ End UGameplayTask interface

    // è¾“å‡ºçš„ Blueprint å§”æ‰˜ï¼Œåœ¨æ¯å¸§ Tick é‡Œå¹¿æ’­ DeltaTime
    UPROPERTY(BlueprintAssignable)
    FOnAbilityTaskTickDelegate OnAbilityTaskTick;
};


//AbilityTask_ExecuteTaskOnTick.cpp
// æ„é€ å‡½æ•°ä¸­è®¾ç½® bTickingTask = trueï¼Œç¡®ä¿ TickTask() è¢«å¼•æ“é©±åŠ¨æ¯å¸§è°ƒç”¨
UAbilityTask_ExecuteTaskOnTick::UAbilityTask_ExecuteTaskOnTick()
{
    bTickingTask = true;
}

UAbilityTask_ExecuteTaskOnTick* UAbilityTask_ExecuteTaskOnTick::ExecuteTaskOnTick(UGameplayAbility* OwningAbility)
{
    // ä½¿ç”¨ GAS æä¾›çš„æ¨¡æ¿å‡½æ•°åˆ›å»ºä»»åŠ¡å®ä¾‹
    UAbilityTask_ExecuteTaskOnTick* Node = NewAbilityTask<UAbilityTask_ExecuteTaskOnTick>(OwningAbility);
    return Node;
}

void UAbilityTask_ExecuteTaskOnTick::TickTask(float DeltaTime)
{
    Super::TickTask(DeltaTime);

    // åªæœ‰å½“ä»»åŠ¡ä»åœ¨æ¿€æ´»ï¼ˆbroadcast å…è®¸æ—¶ï¼‰ï¼Œæ‰å¹¿æ’­å§”æ‰˜ï¼Œå¦åˆ™ç»“æŸä»»åŠ¡
    if (ShouldBroadcastAbilityTaskDelegates())
    {
        OnAbilityTaskTick.Broadcast(DeltaTime);
    }
    else
    {
        EndTask();
    }
}

```

* åœ¨é”æ•Œèƒ½åŠ›ç±»ä¸­æ·»åŠ ä¸€ä¸ªå‡½æ•°ç”¨æ¥ç»˜åˆ¶çš„é”æ•Œå›¾æ ‡å®æ—¶æ›´æ–°å…¶ä½ç½®

```c++
//HeroGameplayAbility_TargetLock.h
UFUNCTION(BlueprintCallable)
void OnTargetLockTick(float DeltaTime);

 UPROPERTY(EditDefaultsOnly, Category = "TargetLock")
 float TargetLockRotationInterpSpeed = 5.f;

 UPROPERTY(EditDefaultsOnly, Category = "Target Lock")
 float TargetLockCameraOffsetDistance = 20.f;

//HeroGameplayAbility_TargetLock.cpp
void UHeroGameplayAbility_TargetLock::OnTargetLockTick(float DeltaTime)
{
    // 1ï¸âƒ£ å¦‚æœé”å®šç›®æ ‡ä¸¢å¤±ï¼Œæˆ–è€…ç›®æ ‡å·²æ­»äº¡ï¼Œæˆ–è€…ç©å®¶è§’è‰²å·²æ­»äº¡ï¼Œå–æ¶ˆé”å®šèƒ½åŠ›
    if (!CurrentLockedActor ||
        UWarriorFunctionLibrary::NativeDoesActorHaveTag(CurrentLockedActor, WarriorGameplayTags::Shared_Status_Dead) ||
        UWarriorFunctionLibrary::NativeDoesActorHaveTag(GetHeroCharacterFromActorInfo(), WarriorGameplayTags::Shared_Status_Dead))
    {
        CancelTargetLockAbility();
        return;
    }

    // 2ï¸âƒ£ æ¯å¸§æ›´æ–° "ç›®æ ‡é”å®š" UI å°æŒ‚ä»¶çš„ä½ç½®
    SetTargetLockWidgetPosition();

    // 3ï¸âƒ£ åˆ¤æ–­æ˜¯å¦å…è®¸è¦†ç›–ç©å®¶çš„æœå‘ï¼ˆè·³è·ƒä¸æ ¼æŒ¡æ—¶ä¸æ—‹è½¬ï¼‰
    const bool bShouldOverrideRotation =
        !UWarriorFunctionLibrary::NativeDoesActorHaveTag(GetHeroCharacterFromActorInfo(), WarriorGameplayTags::Player_Status_Rolling) &&
        !UWarriorFunctionLibrary::NativeDoesActorHaveTag(GetHeroCharacterFromActorInfo(), WarriorGameplayTags::Player_Status_Blocking);

    if (bShouldOverrideRotation)
    {
        // 4ï¸âƒ£ è®¡ç®—è§’è‰²æ­£é¢æœå‘é”å®šç›®æ ‡çš„ç†æƒ³æ—‹è½¬
        // â­ FindLookAtRotation() è¿”å›çš„ rotator æ˜¯ä»å½“å‰åæ ‡çœ‹å‘ç›®æ ‡çš„æ—‹è½¬è§’åº¦
        //    API æ–‡æ¡£è¯´æ˜æ­¤å‡½æ•°æ¥å—èµ·å§‹ç‚¹å’Œç›®æ ‡ç‚¹å‚æ•° :contentReference[oaicite:1]{index=1}
        FRotator LookAtRot = UKismetMathLibrary::FindLookAtRotation(
            GetHeroCharacterFromActorInfo()->GetActorLocation(),
            CurrentLockedActor->GetActorLocation());

        // 5ï¸âƒ£ æ·»åŠ æ‘„åƒæœºåç§»ï¼ˆé€šå¸¸ç”¨äºå¾®è°ƒ pitchï¼‰ï¼Œä»¥ä¾¿ç”»é¢å…ˆæŠ¬æˆ–åä»°è‹¥å¹²åº¦
        LookAtRot -= FRotator(TargetLockCameraOffsetDistance, 0.f, 0.f);

        // 6ï¸âƒ£ è·å–ç©å®¶æ§åˆ¶å™¨å½“å‰çš„æ§åˆ¶æ—‹è½¬ï¼ˆé€šå¸¸æ˜¯è§†è§’çš„ pitch + yawï¼‰
        const FRotator CurrentControlRot = GetHeroControllerFromActorInfo()->GetControlRotation();

        // 7ï¸âƒ£ å¹³æ»‘åœ°æœç›®æ ‡æ—‹è½¬ï¼šä½¿ç”¨ FMath::RInterpToï¼ˆé€å¸§æ’å€¼ç±»å‹çš„ä¸€ç§ï¼‰ï¼Œèåˆå½“å‰æ–¹å‘ â†’ ç›®æ ‡æ–¹å‘
        //    RInterpTo çš„å‚æ•°åŒ…æ‹¬ï¼šå½“å‰å€¼ã€ç›®æ ‡å€¼ã€deltaTimeã€æ’å€¼é€Ÿåº¦
        //    InterpSpeed è¶Šå¤§ï¼Œæ—‹è½¬è¶Šâ€œå¿«â€è€Œé€¼è¿‘ç›®æ ‡ã€‚ç®—æ³•å‚è€ƒ FMathå®ç°ä¸ä½¿ç”¨è¯´æ˜ :contentReference[oaicite:2]{index=2}
        const FRotator TargetRot = FMath::RInterpTo(CurrentControlRot, LookAtRot, DeltaTime, TargetLockRotationInterpSpeed);

        // 8ï¸âƒ£ è®¾ç½®æ§åˆ¶å™¨çš„è§†è§’æ—‹è½¬ï¼Œåªä¿ç•™ pitch/yawï¼ˆroll ç½® 0 ç¨³å®šç”»é¢ï¼‰
        GetHeroControllerFromActorInfo()->SetControlRotation(FRotator(TargetRot.Pitch, TargetRot.Yaw, 0.f));

        // 9ï¸âƒ£ åŒæ­¥è§’è‰²æœ¬ä½“æ–¹å‘ï¼ˆä»…åŒæ­¥ yawï¼Œä»¥ç¡®ä¿è§’è‰²èº«ä½“ä¸è§†è§’æ–¹å‘ä¸€è‡´ï¼‰
        GetHeroCharacterFromActorInfo()->SetActorRotation(FRotator(0.f, TargetRot.Yaw, 0.f));
    }
}
```



* åœ¨é”æ•Œèƒ½åŠ›ç±»ä¸­æ·»åŠ ä¸€ä¸ªå‡½æ•°ç”¨æ¥ç»˜åˆ¶çš„é”æ•Œå›¾æ ‡å®æ—¶æ›´æ–°å…¶ä½ç½®

**HeroGameplayAbility_TargetLockç±»**

```c++
//HeroGameplayAbility_TargetLock.h
// åœ¨è· Ability Tick ç±»å‹çš„ UFUNCTION ä¸­å®šä¹‰ï¼š
 UFUNCTION(BlueprintCallable)
 void OnTargetLockTick(float DeltaTime);

 UPROPERTY(EditDefaultsOnly, Category = "TargetLock")
 float TargetLockRotationInterpSpeed = 5.f;
//HeroGameplayAbility_TargetLock.cpp
void UHeroGameplayAbility_TargetLock::OnTargetLockTick(float DeltaTime)
{
    // âŒ å¦‚æœå½“å‰é”å®šç›®æ ‡ä¸å­˜åœ¨ï¼Œæˆ–ç›®æ ‡å·²æ­»äº¡ï¼Œæˆ–è€…è‹±é›„è‡ªèº«å·²æ­»äº¡ï¼š
    if (!CurrentLockedActor ||
        UWarriorFunctionLibrary::NativeDoesActorHaveTag(CurrentLockedActor, WarriorGameplayTags::Shared_Status_Dead) ||
        UWarriorFunctionLibrary::NativeDoesActorHaveTag(GetHeroCharacterFromActorInfo(), WarriorGameplayTags::Shared_Status_Dead))
    {
        // å–æ¶ˆç›®æ ‡é”å®šæŠ€èƒ½ï¼Œè®© Ability/Task æå‰é€€å‡º
        CancelTargetLockAbility();
        return;
    }

    // ğŸ’¡ æ›´æ–° UI å°ç»„ä»¶åœ¨å±å¹•ä¸Šçš„ä½ç½® â€”â€” åŒæ—¶è´´åˆç›®æ ‡
    SetTargetLockWidgetPosition();

    // åˆ¤æ–­æ˜¯å¦å…è®¸æ—‹è½¬ â€” è¦æ±‚ç©å®¶è§’è‰²å½“å‰ä¸åœ¨â€œç¿»æ»šâ€æˆ–â€œæ ¼æŒ¡â€ç­‰çŠ¶æ€
    const bool bShouldOverrideRotation =
        !UWarriorFunctionLibrary::NativeDoesActorHaveTag(GetHeroCharacterFromActorInfo(), WarriorGameplayTags::Player_Status_Rolling) &&
        !UWarriorFunctionLibrary::NativeDoesActorHaveTag(GetHeroCharacterFromActorInfo(), WarriorGameplayTags::Player_Status_Blocking);

    if (bShouldOverrideRotation)
    {
        // ğŸ“Œ è·å–è‹±é›„ä½ç½®ä¸é”å®šç›®æ ‡ä½ç½®çš„ Lookâ€‘at æ–¹å‘
        FRotator LookAtRot = UKismetMathLibrary::FindLookAtRotation(
            GetHeroCharacterFromActorInfo()->GetActorLocation(),
            CurrentLockedActor->GetActorLocation()
        );

        // âœï¸ å‘ LookAtRot é¡¶éƒ¨æ·»åŠ ä¸€ä¸ªæ‘„åƒæœºå‚ç›´åç§»ï¼ˆPitch åç§»ï¼‰
        LookAtRot.Pitch -= TargetLockCameraOffsetDistance;  

        // ğŸŒª è·å–å½“å‰æ§åˆ¶å™¨çš„æœå‘
        const FRotator CurrentControlRot = GetHeroControllerFromActorInfo()->GetControlRotation();

        // ğŸª„ ç”¨ FMath::RInterpTo å¹³æ»‘æ—‹è½¬åˆ°ç›®æ ‡æ–¹å‘ï¼š
        //    - DeltaTimeï¼šå½“å‰å¸§é—´éš”  
        //    - InterpSpeedï¼šæ—‹è½¬é€Ÿåº¦ï¼ˆå¯è®¾ä¸º 5.0 / 10.0 ç­‰ï¼‰
        const FRotator TargetRot =
            FMath::RInterpTo(CurrentControlRot, LookAtRot, DeltaTime, TargetLockRotationInterpSpeed);

        /************************************************************************************************
         * å…³äº FMath::RInterpTo çš„è§£é‡Šï¼š
         * å®ƒä¼šè¿”å›ä»‹äº CurrentRot å’Œ TargetRot ä¹‹é—´çš„æ’å€¼è§’åº¦ï¼Œå¹¶ä¸”æ ¹æ®å½“å‰è§’åº¦å·®å¼‚ç¼©æ”¾ï¼Œåˆé€Ÿè¾ƒå¿«ï¼Œæœ«å°¾ç¼“åŠ¨æ”¶å°¾ã€‚
         * è¿™ç§å¹³æ»‘æ’å€¼è¡Œä¸ºéå¸¸é€‚åˆæ§åˆ¶äººç‰©æˆ–æ‘„åƒæœºå¹³æ»‘è½¬å‘ç›®æ ‡ï¼Œè€Œä¸ä¼šç¬é—´â€œè·³è½¬â€ï¹£ï¹£è¯¦è§å¼•æ“æ–‡æ¡£ã€‚ 
         * :contentReference[oaicite:3]{index=3}
         ************************************************************************************************/

        // âœ¨ è®¾ç½®æ§åˆ¶å™¨çš„æœå‘ï¼ˆåªä½¿ç”¨ Pitch å’Œ Yawï¼Œä¸ä½œç”¨äº Rollï¼‰
        GetHeroControllerFromActorInfo()->SetControlRotation(FRotator(TargetRot.Pitch, TargetRot.Yaw, 0.f));

        // ğŸ‘¤ è¿˜éœ€åŒæ­¥æ›´æ¢ Hero Character æœ¬èº«çš„ Yawï¼ˆæ¤ç‰©é¢å‘æ–¹å‘ï¼‰
        GetHeroCharacterFromActorInfo()->SetActorRotation(FRotator(0.f, TargetRot.Yaw, 0.f));
    }
}
```



**GA_Hero_TargetLock_Cç±»**

```lua
--
-- DESCRIPTION
--
-- @COMPANY **
-- @AUTHOR **
-- @DATE ${date} ${time}
--

---@type GA_Hero_TargetLock_C
local M = UnLua.Class()

function M:K2_ActivateAbility()
    local Task = UE.UAbilityTask_ExecuteTaskOnTick.ExecuteTaskOnTick(self)
    if(not Task) then
        print("[ERROR] Task is nil!")
        return
    end
    Task.OnAbilityTaskTick:Add(self,M.Run)
    Task:ReadyForActivation()
 end


 function M:Run(DeltaTime)
    self:OnTargetLockTick(DeltaTime)
 end
return M
```

### **åˆ‡æ¢åŠ¨ç”»å§¿åŠ¿**

1. **åˆ›å»º Blend Space èµ„äº§**

åœ¨ç¼–è¾‘å™¨ä¸­ï¼Œä¸ºè‹±é›„è§’è‰²éª¨éª¼ï¼ˆä¾‹å¦‚ `SK_Hero`ï¼‰åˆ›å»ºåä¸º `BS_DirectionalLocomotion_Axe` çš„ 2D Blend Spaceã€‚

2. **é…ç½®è¾“å…¥è½´ / Axis Setup**

Horizontal è½´è®¾ä¸º **Locomotion_Direction**ï¼ˆèŒƒå›´ -180 åˆ° +180åº¦ï¼Œ8 åˆ†æ¡£ï¼Œå¹³æ»‘æ—¶é—´ 0.5ï¼Œç±»å‹ KBâ€”å³ç¼“å†²æ’å€¼ï¼‰ï¼›Vertical è½´è®¾ä¸º **Ground Speed**ï¼ˆèŒƒå›´ 0ï½100ï¼Œå…¼å®¹ä½é€ŸçŠ¶æ€ï¼‰ã€‚

3. **å¡«å……åŠ¨ç”»ç‚¹ / Add Anim Samples**

æ‹–å…¥ï¼š`Idle`â†’(0,0)ï¼›`Walk_Forward`â†’(0Â°)ï¼›`Walk_Left`â†’(-90Â°)ï¼›`Walk_Right`â†’(90Â°)ï¼›`Walk_Backward`â†’(Â±180Â°)ã€‚

4. **ä¿®å¤äº¤å‰è…¿ / Antiâ€‘Crossover Fix**

å¯¹äº Â±45Â° ä¸ 135Â° ç­‰è§’åº¦ï¼Œä½¿ç”¨ `Forward_Left` ä¸ `Backward_Right` åŠ¨ç”»æ›¿ä»£ï¼Œä»¥ä¿®æ­£è…¿éƒ¨æ‰­æ›²é—®é¢˜ã€‚

5. **ä½¿ç”¨ Animation Blueprint**

æ‰“å¼€ä¸»é¢„æµ‹å±‚ Animation Blueprintï¼Œä½¿ç”¨æ–‡ä»¶çš„ Plane Spaceï¼ˆBlend Spaceï¼‰æ’­æ”¾å™¨èŠ‚ç‚¹ã€‚é€šè¿‡ `Blend Poses by Bool` â†’ è‹¥è§’è‰²å…·å¤‡ `Player_Status_TargetLock` Tagï¼Œåˆ™åˆ‡æ¢åˆ°è‡ªå®šä¹‰ Blend Spaceï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤åŠ¨ä½œã€‚

6. **ç»‘å®šè¾“å…¥å˜é‡ / Expose Input**

å°† Blend Space çš„å‚æ•° (Direction Xã€Speed Y) æš´éœ²ä¸ºå˜é‡ï¼Œå¹¶ä» `GetHeroNMInstance().LocalMotionDirection` å’Œé€Ÿåº¦å±æ€§è¿æ¥è¾“å…¥ã€‚

7. **ä¿å­˜æµ‹è¯• / Test & Fix Next**

ç¼–è¯‘å¹¶ä¿å­˜åï¼Œè¿›å…¥å…³å¡ Play â†’ æ¿€æ´»ç›®æ ‡é”å®šèƒ½åŠ›ï¼Œç¡®è®¤åŠ¨ç”»åˆ‡æ¢æ­£å¸¸ã€‚

![](./Lesson Images/6-21.png)

![](./Lesson Images/6-22.png)

![](./Lesson Images/6-23.png)

8. **ç”¨ C++ æ”¹è‰¯é”æ•Œæ—¶çš„ç§»åŠ¨é€Ÿåº¦**<br>

```c++
//HeroGameplayAbility_TargetLock.h   
   void InitTargetLockMovement();
   void ResetTargetLockMovement();
    // æ¿€æ´»Target Lockæ—¶æ‰€è®¾ç½®çš„æ–°æœ€å¤§è¡Œèµ°é€Ÿåº¦
    UPROPERTY(EditDefaultsOnly, Category = "Target Lock")
    float TargetLockMaxWalkSpeed = 150.f;

    // ä¸ºäº†åœ¨ç»“æŸèƒ½åŠ›æ—¶èƒ½æ¢å¤åŸå§‹é€Ÿåº¦ï¼Œéœ€è¦ç¼“å­˜åˆå§‹çš„ MaxWalkSpeed
    UPROPERTY()
    float CachedDefaultMaxWalkSpeed = 0.f;
//HeroGameplayAbility_TargetLock.cpp
void UHeroGameplayAbility_TargetLock::ActivateAbility(
    const FGameplayAbilitySpecHandle Handle,
    const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo,
    const FGameplayEventData* TriggerEventData)
{
    TryLockOnTarget();
    InitTargetLockMovement(); // â‘  æ¿€æ´»æ—¶è°ƒç”¨ â€” é™é€Ÿ
    Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
}

void UHeroGameplayAbility_TargetLock::EndAbility(
    const FGameplayAbilitySpecHandle Handle,
    const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo,
    bool bReplicateEndAbility, bool bWasCancelled)
{
    ResetTargetLockMovement(); // â‘¡ å–æ¶ˆèƒ½åŠ›ï¼ç»“æŸèƒ½åŠ›æ—¶æ¢å¤é€Ÿåº¦
    Cleanup();
    Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}
void UHeroGameplayAbility_TargetLock::InitTargetLockMovement()
{
    // ç¼“å­˜å½“å‰è§’è‰²çš„åŸå§‹ MaxWalkSpeed
    CachedDefaultMaxWalkSpeed = GetHeroCharacterFromActorInfo()
                                    ->GetCharacterMovement()
                                    ->MaxWalkSpeed;

    // è®¾ç½®æ–°çš„ MaxWalkSpeed ä»¥è¾¾åˆ°é”å®šæ—¶çš„æ…¢èµ°æ•ˆæœ
    GetHeroCharacterFromActorInfo()
        ->GetCharacterMovement()
        ->MaxWalkSpeed = TargetLockMaxWalkSpeed;
}
void UHeroGameplayAbility_TargetLock::Cleanup()
{
    AvailableActorsToLock.Empty();
    CurrentLockedActor = nullptr;
    if (DrawnTargetLockWidget)
    {
        DrawnTargetLockWidget->RemoveFromParent();
    }
    DrawnTargetLockWidget = nullptr;

    TargetLockWidgetSize = FVector2D::ZeroVector;

    CachedDefaultMaxWalkSpeed = 0.f;
}

void UHeroGameplayAbility_TargetLock::ResetTargetLockMovement()
{
    // ä»…å½“ä»ç¼“å­˜è¯»å–åˆ°æœ‰æ•ˆå€¼æ—¶æ‰æ¢å¤é€Ÿåº¦ï¼Œé¿å…é‡ç½®ä¸º 0
    if (CachedDefaultMaxWalkSpeed > 0.f)
    {
        GetHeroCharacterFromActorInfo()
            ->GetCharacterMovement()
            ->MaxWalkSpeed = CachedDefaultMaxWalkSpeed;
    }
}
```

**Blend Space ä¿®å¤æ–¹å‘åˆ‡æ¢æŠ–åŠ¨**
åœ¨ Directional Locomotion Blend Space ä¸­å¯ç”¨ `Wrap Input`ï¼Œè§£å†³ã€Œä»å·¦è½¬å³ã€çš„è…¿äº¤å‰é—®é¢˜ï¼Œè¿åŠ¨æ›´å¹³æ»‘ã€‚

### åˆ‡æ¢é”æ•Œç›®æ ‡

åœ¨ **TargetLock çŠ¶æ€**ä¸‹ï¼Œç¦ç”¨ç©å®¶åŸæœ¬çš„é•œå¤´è§†è§’è¾“å…¥ï¼Œä»¥é”®é¼ ç§»åŠ¨æ§åˆ¶ç›®æ ‡é”å®šæ–¹å‘ï¼ˆå·¦å³åˆ‡æ¢é”å®šç›®æ ‡ï¼‰ï¼Œè®©è¡Œä¸ºé€»è¾‘æ›´åŠ è‡ªç„¶å’Œæµç•…ã€‚

æµç¨‹å¦‚ä¸‹ï¼š

1. **åˆ›å»º Native Input Action**
   1. æ·»åŠ  Gameplayâ€¯Tag(è¡¥å……)

æ–°å»º `IA_SwitchTarget` ç±»å‹ä¸º **Axis2D** çš„ Input Action èµ„æºï¼Œç”¨äºæ•æ‰é¼ æ ‡å·¦å³å¹…åº¦å€¼

å®šä¹‰ `InputTag_SwitchTarget` Tagï¼Œç”¨äºæœªæ¥ç»‘å®šåˆ° Input Config èµ„æºä¸ä»£ç è°ƒç”¨ä¸­

2. **è¾“å…¥å›è°ƒ (Input Callbacks)**

åœ¨è§’è‰²ç±»æ·»åŠ ä¸¤ä¸ªå‡½æ•°ï¼š`Input_SwitchTarget_Triggered(â€¦)` å’Œ `â€¦_Completed(â€¦)`ï¼Œç”¨äºæ¥æ”¶å¹¶å¤„ç†é¼ æ ‡è¾“å…¥äº‹ä»¶

3. **åˆ›å»ºæ–°çš„ Mapping Context**

æ–°å»ºä¸“é—¨çš„ `IMC_SwitchTarget` MappingContextï¼Œå°† `IA_SwitchTarget` åŠ å…¥å…¶ä¸­ï¼Œ***åŒæ—¶å±è”½é»˜è®¤çš„ LookAxis***

4. **é€šçŸ¥åˆ‡æ¢ï¼ˆNotify Switch Targetï¼‰**

åœ¨å›è°ƒå‡½æ•°ä¸­ï¼Œæ£€æµ‹ `IA.GetValue().X`ï¼ˆ> +é˜ˆå€¼/ < -é˜ˆå€¼ï¼‰ï¼Œè°ƒç”¨ Ability å†…éƒ¨æ¥å£å¦‚ `TrySwitchTarget(DirectionTag)`

5. **å¤„ç†åˆ‡æ¢é€»è¾‘ï¼ˆHandle Switch Targetï¼‰**

åœ¨ Ability å†…è®¡ç®—å½“å‰æ‰€æœ‰å¯é”å®šç›®æ ‡çš„ Biased è§’åº¦ï¼Œå¹¶ä¿®æ”¹ `CurrentLockedActor`ï¼ŒåŒæ—¶åˆ·æ–°é”å®š UI ä½ç½®

#### **åˆ›å»º Native Input Action**å’Œ**åˆ›å»º Native Input Action**

é¦–å…ˆæ·»åŠ æ ‡ç­¾

```c++
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(InputTag_SwitchTarget);
```

**WarriorHeroCharacterç±»** æ·»åŠ ä¸¤ä¸ªè¾“å…¥å¤„ç†å‡½æ•°

```c++
//WarriorHeroCharacter.h
    void Input_SwitchTargetTriggered(const FInputActionValue& InputActionValue);
    void Input_SwitchTargetCompleted(const FInputActionValue& InputActionValue);

//WarriorHeroCharacter.cpp
    WarriorInputComponent->BindNativeInputAction(InputConfigDataAsset, WarriorGameplayTags::InputTag_SwitchTarget, ETriggerEvent::Triggered,this, &AWarriorHeroCharacter::Input_SwitchTargetTriggered);

    WarriorInputComponent->BindNativeInputAction(InputConfigDataAsset, WarriorGameplayTags::InputTag_SwitchTarget, ETriggerEvent::Triggered,
        this, &AWarriorHeroCharacter::Input_SwitchTargetCompleted);
```

#### **åˆ›å»ºæ–°çš„ Mapping Context**

**HeroGameplayAbility_TargetLockç±»**

```c++
//HeroGameplayAbility_TargetLock.h
    void InitTargetLockMappingContext();
    void ResetTargetLockMappingContext();
//HeroGameplayAbility_TargetLock.cpp
void UHeroGameplayAbility_TargetLock::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    TryLockOnTarget();
    InitTargetLockMovement();
    InitTargetLockMappingContext();
    Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
}

void UHeroGameplayAbility_TargetLock::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
    ResetTargetLockMovement();
    ResetTargetLockMappingContext();
    Cleanup();
    Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}
void UHeroGameplayAbility_TargetLock::InitTargetLockMappingContext()
{
    const ULocalPlayer* LocalPlayer = GetHeroControllerFromActorInfo()->GetLocalPlayer();

    UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(LocalPlayer);

    check(Subsystem);

    Subsystem->AddMappingContext(TargetLockMappingContext, 3);
}
void UHeroGameplayAbility_TargetLock::ResetTargetLockMappingContext()
{
    if (!GetHeroControllerFromActorInfo())
    {
        return;
    }

    const ULocalPlayer* LocalPlayer = GetHeroControllerFromActorInfo()->GetLocalPlayer();

    UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(LocalPlayer);

    check(Subsystem);

    Subsystem->RemoveMappingContext(TargetLockMappingContext);
}
```

* æ·»åŠ ä¸€ä¸ªå…¨æ–°çš„è¾“å…¥æ˜ å°„

![](./Lesson Images/6-24.png)

![](./Lesson Images/6-25.png)

* ç°åœ¨é”å®šè¾“å…¥ä¸å†ä¸æˆ‘ä»¬çš„ç›®æ ‡é”å®šèƒ½åŠ›ç«äº‰æ§åˆ¶æƒäº†

#### é€šçŸ¥åˆ‡æ¢ï¼ˆNotify Switch Targetï¼‰

ç°åœ¨è§£å†³é€šçŸ¥åˆ‡æ¢ç›®æ ‡ä¿¡æ¯

* æµç¨‹
  * æ•è·é¼ æ ‡çš„è¾“å…¥ä¿¡æ¯
  * é€šçŸ¥èƒ½åŠ›åˆ‡æ¢æ–¹å‘
  * æ”¶åˆ°äº‹ä»¶åï¼Œåœ¨èƒ½åŠ›ä¸­è¿›è¡Œåˆ‡æ¢

* æ–°å»ºä¸¤ä¸ªç”¨æ¥ä¼ é€’ä¿¡æ¯çš„æ ‡ç­¾

```c++
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Event_SwitchTarget_Left);
MYWARRIOR_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(Player_Event_SwitchTarget_Right);
```

* æ·»åŠ ä¸€ä¸ªç¼“å­˜é¼ æ ‡æ—‹è½¬æ–¹å‘çš„å˜é‡ï¼Œå‘é€æ•è·çš„é¼ æ ‡çš„è¾“å…¥

**WarriorHeroCharacterç±»**

```c++
//WarriorHeroCharacter.h
/** å½“å‰çš„é¼ æ ‡è¾“å…¥æ–¹å‘ï¼Œç”¨äºé€‰æ‹©åˆ‡æ¢ç›®æ ‡æ–¹å‘ */
FVector2D SwitchDirection = FVector2D::ZeroVector;
//WarriorHeroCharacter.cpp
/**
 *  æ•è·ç©å®¶æŒ‰ä¸‹é¼ æ ‡è¡Œä¸ºæ—¶çš„è¾“å…¥å€¼
 *  - Axis2D ç±»å‹çš„ Input Action å°†è¿”å› FVector2D
 *  - ä»ä¸­è¯»å– X è½´å€¼ï¼Œä»£è¡¨å·¦å³åç§»æ–¹å‘
 */
void AWarriorHeroCharacter::Input_SwitchTargetTriggered(const FInputActionValue& InputActionValue)
{
    // å°†å½“å‰å¸§é¼ æ ‡ç§»åŠ¨æ–¹å‘å­˜å‚¨ï¼Œä»¥ä¾›åç»­ä½¿ç”¨
    SwitchDirection = InputActionValue.Get<FVector2D>();
}

/**
 *  è§¦å‘å®Œè¾“å…¥åçš„ Completed å›è°ƒ
 *  - æ ¹æ® SwitchDirection.X çš„æ­£è´Ÿåˆ¤æ–­å¸Œæœ›åˆ‡æ¢æ–¹å‘
 *  - å‘é€ç›¸åº” GameplayEvent åˆ°è‡ªèº«èƒ½åŠ›ç³»ç»Ÿï¼Œé€šçŸ¥åˆ‡æ¢æ–¹å‘
 */
void AWarriorHeroCharacter::Input_SwitchTargetCompleted(const FInputActionValue& InputActionValue)
{
    // æ„å»º GameplayEventDataï¼ˆå¯æºå¸¦ AdditionalDataï¼Œä½†æ­¤å¤„ä¸ºç©ºæ•°æ®æµé‡æœ€ä½ï¼‰
    FGameplayEventData Data;

    // å‘é€ Gameplay Eventï¼Œè§¦å‘ Ability æ”¶åˆ° Switch Target äº‹ä»¶é€»è¾‘
    UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(
        this,
        SwitchDirection.X > 0.f
            ? WarriorGameplayTags::Player_Event_SwitchTarget_Right
            : WarriorGameplayTags::Player_Event_SwitchTarget_Left,
        Data);

    // å¯é€‰çš„è°ƒè¯•è¾“å‡ºï¼šæ‰“å°å½“å‰é¼ æ ‡æ–¹å‘å‘é‡
    // Debug::Print(TEXT("SwitchDirection: ") + SwitchDirection.ToString());
}
```

**GA_Hero_TargetLock_Cç±»**

```lua
---@type GA_Hero_TargetLock_C
local M = UnLua.Class()

function M:K2_ActivateAbility()
    -- æ¯å¸§ Tick çš„ä»»åŠ¡
    local Task = UE.UAbilityTask_ExecuteTaskOnTick.ExecuteTaskOnTick(self)
    if(not Task) then
        print("[ERROR] Task is nil!")
        return
    end
    Task.OnAbilityTaskTick:Add(self, M.Run)
    Task:ReadyForActivation()

    -- ç­‰å¾…ç›®æ ‡åˆ‡æ¢çš„ GameplayEvent,å¦‚æœ OnlyMatchExact è®¾ç½®ä¸º falseï¼Œé‚£ä¹ˆç»‘å®šçš„äº‹ä»¶ä¸ä»…åŒ¹é…å…·ä½“çš„ï¼ˆexactï¼‰æ ‡ç­¾ï¼Œè¿˜å¯ä»¥è§¦å‘æ‰€æœ‰ä»¥è¯¥æ ‡ç­¾ä¸ºå‰ç¼€çš„å­æ ‡ç­¾äº‹ä»¶ï¼ˆnested tagsï¼‰
    local WaitEventTask = UE.UAbilityTask_WaitGameplayEvent.WaitGameplayEvent(self, self.EventTag, nil, false, false)
    WaitEventTask.EventReceived:Add(self, M.OnEventReceived)
    WaitEventTask:ReadyForActivation()
end

 function M:Run(DeltaTime)
    self:OnTargetLockTick(DeltaTime)
 end

 function M:OnEventReceived(Payload)
    local returnvalue = UE.UBlueprintGameplayTagLibrary.GetDebugStringFromGameplayTag(Payload.EventTag)
    UE.UKismetSystemLibrary.PrintString(self, "Event Received: " .. returnvalue)
 end
return M
```

#### **å¤„ç†åˆ‡æ¢é€»è¾‘ï¼ˆHandle Switch Targetï¼‰**

ä¹‹å‰å·²é€šè¿‡é¼ æ ‡è¾“å…¥ç”Ÿæˆ `SwitchTarget.Left/Right` äº‹ä»¶å¹¶ä¼ è¾¾ç»™ **TargetLock Ability**ã€‚

æ¥ä¸‹æ¥**æ¥æ”¶åˆ°åˆ‡æ¢æ–¹å‘äº‹ä»¶åï¼Œå®Œæˆå®é™…ç›®æ ‡åˆ‡æ¢é€»è¾‘**ã€‚

åœ¨**UHeroGameplayAbility_TargetLock**ç±»ä¸­ç»§ç»­å†™é€»è¾‘ï¼Œæ–°å»ºä¸¤ä¸ªè¾…åŠ©å‡½æ•°

**HeroGameplayAbility_TargetLockç±»**

```c++
//HeroGameplayAbility_TargetLock.h
    UFUNCTION(BlueprintCallable)
    void SwitchTarget(const FGameplayTag& InSwitchDirectionTag);
    void GetAvailableActorsAroundTarget(TArray<AActor*>& OutActorsOnLeft, TArray<AActor*>& OutActorsOnRight);
//HeroGameplayAbility_TargetLock.cpp
void UHeroGameplayAbility_TargetLock::GetAvailableActorsAroundTarget(
    TArray<AActor*>& OutActorsOnLeft,
    TArray<AActor*>& OutActorsOnRight)
{
    // å¦‚æœå½“å‰æ²¡æœ‰é”å®šå¯¹è±¡ï¼Œæˆ–è€…å€™é€‰ç›®æ ‡åˆ—è¡¨ä¸ºç©ºï¼Œå°±å–æ¶ˆæœ¬æ¬¡ Target Lock æ•ˆæœ
    if (!CurrentLockedActor || AvailableActorsToLock.IsEmpty())
    {
        CancelTargetLockAbility();
        return;
    }

    // è·å¾—ç©å®¶ï¼ˆè‹±é›„ï¼‰å½“å‰ä¸–ç•Œä½ç½®
    const FVector PlayerLocation = GetHeroCharacterFromActorInfo()->GetActorLocation();

    // è®¡ç®— â€œç©å®¶æŒ‡å‘å½“å‰é”å®šç›®æ ‡â€çš„å½’ä¸€åŒ–æ–¹å‘å‘é‡
    const FVector PlayerToCurrentNormalized =
        (CurrentLockedActor->GetActorLocation() - PlayerLocation).GetSafeNormal();

    // éå†æ¯ä¸€ä¸ªå€™é€‰ Actor
    for (AActor* AvailableActor : AvailableActorsToLock)
    {
        // å¦‚æœè¿™ä¸ªå€™é€‰ Actor æ— æ•ˆï¼Œæˆ–è€…å®ƒæ°å¥½å°±æ˜¯å½“å‰é”å®šçš„ç›®æ ‡ï¼Œå°±è·³è¿‡
        if (!AvailableActor || AvailableActor == CurrentLockedActor)
            continue;

        // è®¡ç®—ç©å®¶æŒ‡å‘è¯¥å€™é€‰ Actor çš„å½’ä¸€åŒ–å‘é‡
        const FVector PlayerToAvailableNormalized =
            (AvailableActor->GetActorLocation() - PlayerLocation).GetSafeNormal();

        // è®¡ç®—ä¸¤ä¸ªæ–¹å‘å‘é‡çš„å‰ä¹˜ï¼ˆCross Productï¼‰
        const FVector CrossResult =
            FVector::CrossProduct(PlayerToCurrentNormalized, PlayerToAvailableNormalized);

        // Unreal å¼•æ“ä½¿ç”¨å·¦æ‰‹åæ ‡ç³» â€”â€” X=å‰, Y=å³, Z=ä¸Š :contentReference[oaicite:1]{index=1}
        // åœ¨è¯¥åæ ‡ç³»ä¸‹:
        //     Crossï¼ˆæŒ‡å‘å½“å‰ç›®æ ‡ï¼ŒæŒ‡å‘å€™é€‰ç›®æ ‡ï¼‰çš„ Z åˆ†é‡ > 0 â†’ å€™é€‰ç›®æ ‡ä½äºå³ä¾§ï¼›
        //     Z <= 0 â†’ ä½äºå·¦ä¾§æˆ–æ­£å‰åã€‚
        if (CrossResult.Z > 0.f)
        {
            OutActorsOnRight.AddUnique(AvailableActor);
        }
        else
        {
            OutActorsOnLeft.AddUnique(AvailableActor);
        }
    }

    /*
      æ€»é€»è¾‘ï¼šåŸºäºç©å®¶æœå‘å½“å‰é”å®šç›®æ ‡çš„æ–¹å‘ä½œä¸ºâ€œåŸºå‡†â€ï¼Œåˆ¤æ–­å€™é€‰ç›®æ ‡æ˜¯åœ¨å½“å‰ç›®æ ‡
      çš„å·¦ä¾§è¿˜æ˜¯å³ä¾§ï¼Œå¹¶åˆ†åˆ«æ”¶é›†åˆ°ä¸¤ä¸ªè¾“å‡ºæ•°ç»„é‡Œã€‚
    */
}

void UHeroGameplayAbility_TargetLock::SwitchTarget(
    const FGameplayTag& InSwitchDirectionTag)
{
    // å…ˆä¸»åŠ¨åˆ·æ–°å€™é€‰åˆ—è¡¨
    GetAvailableActorsToLock();

    // å‡†å¤‡å®¹å™¨å‚¨å­˜å·¦å³ä¾§å¯åˆ‡æ¢ç›®æ ‡
    TArray<AActor*> ActorsOnLeft;
    TArray<AActor*> ActorsOnRight;
    AActor* NewTargetToLock = nullptr;

    // æŒ‘é€‰å·¦å³ä¸¤ä¾§çš„ç›®æ ‡
    GetAvailableActorsAroundTarget(ActorsOnLeft, ActorsOnRight);

    // æ ¹æ®æ”¶åˆ°çš„ GameplayTagï¼ˆå·¦å³æ–¹å‘ï¼‰å†³å®šåˆ‡æ¢å“ªè¾¹
    if (InSwitchDirectionTag == WarriorGameplayTags::Player_Event_SwitchTarget_Left)
    {
        // å‘å·¦åˆ‡æ¢ï¼šä»å·¦ä¾§åˆ—è¡¨é‡Œé€‰æœ€è¿‘çš„ Actor
        NewTargetToLock = GetNearestTargetFromAvailableActors(ActorsOnLeft);
    }
    else
    {
        // å‘å³åˆ‡æ¢ï¼šä»å³ä¾§åˆ—è¡¨é‡Œé€‰æœ€è¿‘çš„ Actor
        NewTargetToLock = GetNearestTargetFromAvailableActors(ActorsOnRight);
    }

    // å¦‚æœæ‰¾åˆ°äº†æœ‰æ•ˆçš„æ–°ç›®æ ‡ï¼Œåˆ™æ›¿æ¢å½“å‰é”å®š Actor
    if (NewTargetToLock)
    {
        CurrentLockedActor = NewTargetToLock;
    }
    // Tick é‡Œè¿˜ä¼šæ¯å¸§æ›´æ–° Widget ä½ç½®å’Œè§’è‰²æœå‘
}

```

**GA_Hero_TargetLock_Cç±»**

```lua
 function M:OnEventReceived(Payload)
--[[     local returnvalue = UE.UBlueprintGameplayTagLibrary.GetDebugStringFromGameplayTag(Payload.EventTag)
    UE.UKismetSystemLibrary.PrintString(self, "Event Received: " .. returnvalue) ]]
    self:SwitchTarget(Payload.EventTag)
 end
```

* ç°åœ¨å°±å¯ä»¥å¼€å¯é”æ•ŒåŠŸèƒ½åç§»åŠ¨é¼ æ ‡å°±å¯ä»¥åˆ‡æ¢é”æ•Œç›®æ ‡ï¼Œå¦‚æœè§‰å¾—çµæ•åº¦å¤ªé«˜å¯ä»¥åœ¨è¿™é‡Œè°ƒæ•´

![](./Lesson Images/6-26.png)

## è‹±é›„æ­»äº¡æœºåˆ¶

â‘  åˆ›å»ºèƒ½åŠ›

æ–°å»º `GA_Hero_Death` Blueprintï¼Œç»§æ‰¿è‡ª `WarriorHeroGameplayAbility`ï¼ˆC++ï¼‰ã€‚

![](./Lesson Images/6-27.png)

â‘¡ è®¾ç½®è§¦å‘æ–¹å¼

ä½¿ç”¨ â€œOn Tag Addedâ€ è§¦å‘æœºåˆ¶ï¼Œå½“è§’è‰²è·å¾— `shared.status.dead` æ ‡ç­¾æ—¶è‡ªåŠ¨æ¿€æ´»æ­¤æ­»äº¡èƒ½åŠ›ï¼ˆåªéœ€æ¿€æ´»ä¸€æ¬¡ï¼Œä¿ç•™é»˜è®¤ Instancing Policyï¼‰ã€‚æ”¯æŒå“åº”è§’è‰²æ­»äº¡äº‹ä»¶ï¼Œæ— éœ€é¢å¤–æ´¾å‘ Gameplay Event

![](./Lesson Images/6-28.png)

â‘¢ éšæœºæ’­æ”¾æ­»äº¡åŠ¨ç”»å’Œâ‘£ Ability ç»“æŸåçš„å¤„ç†

ä½¿ç”¨ `Select Random` ä» `MontagesToPlay` æ•°ç»„ä¸­æŒ‘é€‰ä¸€ä¸ªåŠ¨ç”»è’™å¤ªå¥‡ã€‚ç„¶åæ¥å…¥å†…ç½®çš„ `Play Montage and Wait` ä»»åŠ¡ã€‚

åœ¨ `OnEndAbility` åˆ†æ”¯ä¸­ï¼šæš‚åœåŠ¨ç”»æ’­æ”¾ã€å–æ¶ˆç¢°æ’ç»„ä»¶ã€è®¾ç½® Input Mode ä¸º UI Only å¹¶æ˜¾ç¤ºé¼ æ ‡æŒ‡é’ˆã€‚

```lua
--=== GA_Hero_Death_C.lua (UnLua è„šæœ¬) ===
---@type GA_Hero_Death_C
local M = UnLua.Class()

function M:K2_ActivateAbility()
    -- ä» MontagesToPlay æ•°ç»„ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªåŠ¨ç”»
    local length = self.MontagetoPlay:Num()
    local choice = math.random(1, length)
    local MontagetoPlays = self.MontagetoPlay[choice]
    -- æ’­æ”¾ Montage å¹¶ç­‰å¾…å…¶ç»“æŸæˆ–è¢«å–æ¶ˆ
    local PlayMontageTask = UE.UAbilityTask_PlayMontageAndWait.CreatePlayMontageAndWaitProxy(self, "PlayMontageTask",MontagetoPlays)
    -- ç»‘å®šæ‰€æœ‰ç»“æŸæŒ‡ä»¤ï¼ˆå®Œæˆï¼æ‰“æ–­ï¼å–æ¶ˆï¼‰åˆ°åŒä¸€å¤„ç†å‡½æ•°
    PlayMontageTask.OnCompleted:Add(self, M.OnMontage)
    PlayMontageTask.OnBlendOut:Add(self, M.OnMontage)
    PlayMontageTask.OnInterrupted:Add(self, M.OnMontage)
    PlayMontageTask.OnCancelled:Add(self, M.OnMontage)
    PlayMontageTask:ReadyForActivation()
end

-- èƒ½åŠ›ç»“æŸç»Ÿä¸€å¤„ç†ï¼šæš‚åœåŠ¨ç”»ã€ç¦ç¢°æ’ã€åˆ‡æ¢è¾“å…¥æ¨¡å¼ä¸º UI onlyï¼Œå¹¶æ˜¾ç¤ºé¼ æ ‡
function M:K2_OnEndAbility(bWasCancelled)
    self:GetOwningComponentFromActorInfo().bPauseAnims = true
    local characterCap = self:GetHeroCharacterFromActorInfo().CapsuleComponent
    if characterCap then
        characterCap:SetCollisionEnabled(UE.ECollisionEnabled.NoCollision)
    end
    local controller = self:GetHeroControllerFromActorInfo()
    if controller and controller:IsValid() then
        UE.UWidgetBlueprintLibrary.SetInputMode_UIOnlyEx(controller)
        controller.bShowMouseCursor = true
    end
end

-- Montage æ’­æ”¾ç»“æŸåè§¦å‘ Ability æ­£å¼ç»“æŸ
function M:OnMontage()
    self:K2_EndAbility()
end
return M

```

â‘¤ åˆ¶ä½œæ­»äº¡è’™å¤ªå¥‡èµ„æº

ä»ä¸¤ä¸ªæ­»äº¡åŠ¨ç”»åºåˆ—ç”Ÿæˆ AnimMontagesã€‚
 \- æ·»åŠ ä¸€ä¸ª **Slow-Motion Notify**ï¼ˆTime Dilation = 0.2ï¼‰ã€‚
 \- æ·»åŠ ä¸¤ä¸ª **Play Sound Notify**ï¼š`character_expire`ï¼Œ`character_claps`ã€‚

â‘¥ èƒ½åŠ›æˆæƒä¸è°ƒè¯•

åœ¨ `DA_Hero` AbilitySet ä¸­å°† `GA_Hero_Death` æ·»åŠ åˆ° Reactive Abilities åˆ—è¡¨ï¼Œä½¿è§’è‰²åœ¨æ»¡è¶³æ¡ä»¶ï¼ˆæ­»äº¡æ ‡ç­¾ï¼‰æ—¶å¯è¢«è§¦å‘ã€‚

â‘¦ è¡Œä¸ºæ ‘æ¡ä»¶ä¼˜åŒ–

åœ¨æ•Œäººè¡Œä¸ºæ ‘ä¸­åŠ å…¥ Decorator æ£€æŸ¥ç›®æ ‡ Actor æ˜¯å¦æœ‰ `shared.status.dead` æ ‡ç­¾ï¼Œå¦‚æœ trueï¼Œåˆ™ä¸ç»§ç»­æ”»å‡»ã€‚
