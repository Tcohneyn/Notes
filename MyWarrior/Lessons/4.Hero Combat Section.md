# 4.è§’è‰²æˆ˜æ–—éƒ¨åˆ†

## å‰è¨€

è¿™éƒ¨åˆ†å†…å®¹ä¸»è¦å›´ç»•**é€ æˆä¼¤å®³(Deal Damage)**å’Œ**æˆ˜æ–—åé¦ˆ(Combat Feedback)**å±•å¼€ã€‚

**é€ æˆä¼¤å®³(Deal Damage)**åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªå†…å®¹ã€‚

* **æ•Œäººè§’è‰²ï¼ˆEnemy Characterï¼‰**
* **å±æ€§ï¼ˆAttributeï¼‰**
* **å‡»ä¸­æ£€æµ‹ï¼ˆHit Detectionï¼‰**
* **è‡ªå®šä¹‰è®¡ç®—ï¼ˆCustom Calculationï¼‰**
* **UI**

**æˆ˜æ–—åé¦ˆ(Combat Feedback)**åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªå†…å®¹ã€‚

* **å‡»ä¸­ååº”ï¼ˆHit Reactï¼‰**
* **å‡»ä¸­/å£°éŸ³ç‰¹æ•ˆï¼ˆHit/SoundFxï¼‰**
* **ç›¸æœºæŠ–åŠ¨ï¼ˆCamera Shakeï¼‰**
* **æ­»äº¡æ•ˆæœï¼ˆDeathï¼‰**

## è®¾ç½®æ•Œäººè§’è‰²

è®¾ç½®æ•Œäººè§’è‰²åˆ†ä¸ºä»¥ä¸‹å‡ ç‚¹

- è§’è‰²ç±»åˆ«ï¼ˆEnemy Character Classï¼‰
- å¯åŠ¨æ•°æ®ï¼ˆEnemy Start Up Dataï¼‰
- æ¸¸æˆèƒ½åŠ›ç±»åˆ«ï¼ˆEnemy Gameplay Abilityï¼‰
- æˆ˜æ–—ç»„ä»¶ï¼ˆEnemy Combat Componentï¼‰

åˆ›å»ºWarriorEnemyCharacter,DataAsset_EnemyStartUpData,WarriorEnemyGameplayAbility,EnemyCombatComponentç±»å¹¶åˆå§‹åŒ–ã€‚

**WarriorEnemyCharacterç±»**

```c++
//WarriorEnemyCharacter.h 

#pragma once

#include "CoreMinimal.h"
#include "Characters/WarriorBaseCharacter.h"
#include "WarriorEnemyCharacter.generated.h"

class UEnemyCombatComponent;


UCLASS()
class MYWARRIOR_API AWarriorEnemyCharacter : public AWarriorBaseCharacter
{
    GENERATED_BODY()

public:
    AWarriorEnemyCharacter();// æ„é€ å‡½æ•°å£°æ˜
protected:    
    UPROPERTY(VisibleAnywhere, Category = "Combat")
    TObjectPtr<UEnemyCombatComponent> EnemyCombatComponent;    // â†’ æ ¸å¿ƒæˆå‘˜ï¼šæ•Œäººä¸“å±çš„æˆ˜æ–—é€»è¾‘ç»„ä»¶

public:
    FORCEINLINE UEnemyCombatComponent* GetEnemyCombatComponent() const { return EnemyCombatComponent; }
     // â†’ å†…è”å‡½æ•°ï¼šæä¾›ç»„ä»¶è®¿é—®æ¥å£
    // â†’ FORCEINLINEå¼ºåˆ¶ç¼–è¯‘å™¨å†…è”ä¼˜åŒ–
    // â†’ constç¡®ä¿ä¸ä¿®æ”¹å¯¹è±¡çŠ¶æ€
};


//WarriorEnemyCharacter.cpp
#include "Characters/WarriorEnemyCharacter.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/Combat/EnemyCombatComponent.h"
AWarriorEnemyCharacter::AWarriorEnemyCharacter()
{
    AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;//è§’è‰²åœ¨åœºæ™¯ä¸­æ”¾ç½®æˆ–ç¨‹åºç”Ÿæˆæ—¶ï¼Œè‡ªåŠ¨ç»‘å®š AI æ§åˆ¶å™¨
    //ç¦æ­¢è§’è‰²è·Ÿéšæ§åˆ¶å™¨çš„æ—‹è½¬æ–¹å‘
    bUseControllerRotationPitch = false;
    bUseControllerRotationYaw = false;
    bUseControllerRotationRoll = false;
    //ç§»åŠ¨ç»„ä»¶é…ç½®
    GetCharacterMovement()->bUseControllerDesiredRotation = false;//ç¦ç”¨æ§åˆ¶å™¨æœŸæœ›çš„æ—‹è½¬æ–¹å‘ï¼ˆé¿å…ä¸ç§»åŠ¨æ–¹å‘å†²çªï¼‰
    GetCharacterMovement()->bOrientRotationToMovement = true;//å¯ç”¨è§’è‰²æœå‘ç§»åŠ¨æ–¹å‘ï¼ˆå…³é”®ï¼ä½¿è§’è‰²ç§»åŠ¨æ—¶è‡ªåŠ¨è½¬å‘ï¼‰
    GetCharacterMovement()->RotationRate = FRotator(0.f, 180.f, 0.f);//æ—‹è½¬é€Ÿç‡ï¼ˆYaw=180 è¡¨ç¤ºæ¯ç§’è½¬å‘ 180 åº¦ï¼Œä¿è¯å¿«é€Ÿè½¬èº«å“åº”ï¼‰
    GetCharacterMovement()->MaxWalkSpeed = 300.f; //æœ€å¤§è¡Œèµ°é€Ÿåº¦ï¼ˆå•ä½ï¼šå˜ç±³/ç§’ï¼‰ï¼Œæ§åˆ¶æ•Œäººç§»åŠ¨èŠ‚å¥
    GetCharacterMovement()->BrakingDecelerationWalking = 1000.f;//è¡Œèµ°æ—¶å‡é€Ÿå€¼ï¼ˆå•ä½ï¼šå˜ç±³/ç§’Â²ï¼‰ï¼Œå½±å“åœæ­¢æ—¶çš„æ€¥ç¼“ç¨‹åº¦

    EnemyCombatComponent = CreateDefaultSubobject<UEnemyCombatComponent>(TEXT("CombatComponent"));//åˆ›å»ºå¹¶æŒ‚è½½ UEnemyCombatComponent ç»„ä»¶åˆ°è§’è‰²
}
```

WarriorEnemyGameplayAbilityç±»

```c++
//WarriorEnemyGameplayAbility.h

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystem/Abilities/WarriorGameplayAbility.h"
#include "WarriorEnemyGameplayAbility.generated.h"

class AWarriorEnemyCharacter;
class UEnemyCombatComponent;

UCLASS()
class MYWARRIOR_API UWarriorEnemyGameplayAbility : public UWarriorGameplayAbility
{
	GENERATED_BODY()
	
	public:
    UFUNCTION(BlueprintPure, Category = "Warrior|Ability")
    AWarriorEnemyCharacter* GetEnemyCharacterFromActorInfo();//ä»æŠ€èƒ½ç»‘å®šçš„Actorä¿¡æ¯ä¸­è·å–æ•Œäººè§’è‰²å®ä¾‹

    UFUNCTION(BlueprintPure, Category = "Warrior|Ability")
    UEnemyCombatComponent* GetEnemyCombatComponentFromActorInfo();//è·å–æ•Œäººçš„æˆ˜æ–—ç»„ä»¶ï¼ˆUEnemyCombatComponentï¼‰

    private:
        TWeakObjectPtr<AWarriorEnemyCharacter> CachedWarriorEnemyCharacter;
    /*TWeakObjectPtrï¼šå¼±æŒ‡é’ˆç±»å‹ï¼Œé¿å…å¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼ã€‚
       ä¼˜åŠ¿ï¼šè‡ªåŠ¨å¤„ç†å¯¹è±¡é”€æ¯åçš„ç©ºå¼•ç”¨ï¼Œå®‰å…¨æ€§é«˜äºè£¸æŒ‡é’ˆã€‚
      ç¼“å­˜ç›®çš„ï¼šå‡å°‘é¢‘ç¹æŸ¥è¯¢Actorä¿¡æ¯çš„æ€§èƒ½å¼€é”€ã€‚
        åœºæ™¯ï¼šåœ¨æŠ€èƒ½æŒç»­æ¿€æ´»æœŸé—´ï¼ˆå¦‚è¿å‡»åŠ¨ç”»ï¼‰ï¼Œå¤šæ¬¡è®¿é—®åŒä¸€è§’è‰²æ—¶æå‡æ•ˆç‡
    */
};
//WarriorEnemyGameplayAbility.cpp
#include "AbilitySystem/Abilities/WarriorEnemyGameplayAbility.h"
#include "Characters/WarriorEnemyCharacter.h"
AWarriorEnemyCharacter* UWarriorEnemyGameplayAbility::GetEnemyCharacterFromActorInfo()
{
    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆé¿å…é‡å¤ç±»å‹è½¬æ¢ï¼‰
    if (!CachedWarriorEnemyCharacter.IsValid())
    {
        // ä»å½“å‰æŠ€èƒ½ç»‘å®šçš„AvatarActorè·å–æ•Œäººè§’è‰²å®ä¾‹
        CachedWarriorEnemyCharacter = Cast<AWarriorEnemyCharacter>(CurrentActorInfo->AvatarActor);
    }
    // è¿”å›ç¼“å­˜çš„è§’è‰²æŒ‡é’ˆï¼ˆè‹¥æ— æ•ˆåˆ™è¿”å›nullptrï¼‰
    return CachedWarriorEnemyCharacter.IsValid() ? CachedWarriorEnemyCharacter.Get() : nullptr;
}

UEnemyCombatComponent* UWarriorEnemyGameplayAbility::GetEnemyCombatComponentFromActorInfo()
{
    // é€šè¿‡è§’è‰²å®ä¾‹è·å–æˆ˜æ–—ç»„ä»¶
    return GetEnemyCharacterFromActorInfo()->GetEnemyCombatComponent();
}

```



### å¼‚æ­¥åŠ è½½æ•Œäººæ•°æ®

![](./Lesson Images/Lesson4-8.png)

DataAsset_EnemyStartUpDataç±» 

```c++
//DataAsset_EnemyStartUpData.h

#pragma once

#include "CoreMinimal.h"
#include "DataAssets/StartUpData/DataAsset_StartUpDataBase.h"
#include "DataAsset_EnemyStartUpData.generated.h"

class UWarriorEnemyGameplayAbility;

UCLASS()
class MYWARRIOR_API UDataAsset_EnemyStartUpData : public UDataAsset_StartUpDataBase
{
    GENERATED_BODY()
public:
    virtual void GiveToAbilitySystemComponent(UWarriorAbilitySystemComponent* InASCToGive, int32 ApplyLevel = 1) override;//å°†é¢„è®¾çš„æ•ŒäººæŠ€èƒ½ï¼ˆEnemyCombatAbilitiesï¼‰åŠ¨æ€èµ‹äºˆæ•Œäººçš„èƒ½åŠ›ç³»ç»Ÿç»„ä»¶ï¼ˆASCï¼‰

private:
    UPROPERTY(EditDefaultsOnly, Category = "StartUpData")
    TArray<TSubclassOf<UWarriorEnemyGameplayAbility>> EnemyCombatAbilities; //æ•Œäººæˆ˜æ–—èƒ½åŠ›
};
//DataAsset_EnemyStartUpData.cpp
#include "DataAssets/StartUpData/DataAsset_EnemyStartUpData.h"
#include "AbilitySystem/WarriorAbilitySystemComponent.h"
#include "AbilitySystem/Abilities/WarriorEnemyGameplayAbility.h"
// å°†æ•°æ®èµ„äº§ä¸­é…ç½®çš„æ•ŒäººæŠ€èƒ½èµ‹äºˆç›®æ ‡èƒ½åŠ›ç³»ç»Ÿç»„ä»¶ï¼ˆASCï¼‰
void UDataAsset_EnemyStartUpData::GiveToAbilitySystemComponent(
    UWarriorAbilitySystemComponent* InASCToGive, // ç›®æ ‡ASCç»„ä»¶
    int32 ApplyLevel // æŠ€èƒ½åˆå§‹ç­‰çº§ï¼ˆé»˜è®¤=1ï¼‰
) 
{
    // 1. è°ƒç”¨åŸºç±»åˆå§‹åŒ–é€»è¾‘ï¼ˆå¦‚é€šç”¨æŠ€èƒ½/å±æ€§èµ‹äºˆï¼‰
    Super::GiveToAbilitySystemComponent(InASCToGive, ApplyLevel);
    
    // 2. æ£€æŸ¥æ•Œäººä¸“å±æŠ€èƒ½æ•°ç»„æ˜¯å¦éç©º
    if (!EnemyCombatAbilities.IsEmpty()) 
    {
        // 3. éå†æ‰€æœ‰é¢„è®¾çš„æ•ŒäººæŠ€èƒ½ç±»
        for (const TSubclassOf<UWarriorEnemyGameplayAbility>& AbilityClass : EnemyCombatAbilities)
        {
            // 4. è·³è¿‡æ— æ•ˆæŠ€èƒ½ç±»ï¼ˆé˜²æ­¢å´©æºƒï¼‰
            if (!AbilityClass) continue;

            // 5. åˆ›å»ºæŠ€èƒ½è§„æ ¼ï¼ˆFGameplayAbilitySpecï¼‰
            FGameplayAbilitySpec AbilitySpec(AbilityClass);
            
            // 6. è®¾ç½®æŠ€èƒ½æ¥æºå¯¹è±¡ï¼ˆé€šå¸¸ä¸ºæ•Œäººè§’è‰²å®ä¾‹ï¼‰
            AbilitySpec.SourceObject = InASCToGive->GetAvatarActor();
            
            // 7. è®¾ç½®æŠ€èƒ½åˆå§‹ç­‰çº§ï¼ˆæ”¯æŒåŠ¨æ€éš¾åº¦/æˆé•¿ï¼‰
            AbilitySpec.Level = ApplyLevel;
            
            // 8. å°†æŠ€èƒ½èµ‹äºˆASCç»„ä»¶ï¼ˆæ³¨å†Œåˆ°GASç³»ç»Ÿï¼‰
            InASCToGive->GiveAbility(AbilitySpec);
        }
    }
}
```

**WarriorEnemyCharacterç±»**

```c++
//WarriorEnemyCharacter.h 

#pragma once

#include "CoreMinimal.h"
#include "Characters/WarriorBaseCharacter.h"
#include "WarriorEnemyCharacter.generated.h"

UCLASS()
class MYWARRIOR_API AWarriorEnemyCharacter : public AWarriorBaseCharacter
{
    GENERATED_BODY()
    protected:
    //~ Begin APawn Interface
    virtual void PossessedBy(AController* NewController) override;
    //~ End APawn Interface
    private:
    void InitEnemyStartUpData();
};
//WarriorEnemyCharacter.cpp
#include "Engine/AssetManager.h"
#include "DataAssets/StartUpData/DataAsset_EnemyStartUpData.h"
/**
 * @brief å½“æ§åˆ¶å™¨æ¥ç®¡æ­¤æ•Œäººè§’è‰²æ—¶è§¦å‘åˆå§‹åŒ–é€»è¾‘
 * @param NewController æ–°æ¥ç®¡è§’è‰²çš„æ§åˆ¶å™¨ï¼ˆé€šå¸¸ä¸ºAIControllerï¼‰
 * @note æ­¤å‡½æ•°åœ¨è§’è‰²è¢«AIæ§åˆ¶å™¨æˆ–ç©å®¶æ§åˆ¶å™¨æ¥ç®¡æ—¶è°ƒç”¨ï¼Œç”¨äºåˆå§‹åŒ–æ•Œäººä¸“å±æ•°æ®
 */
void AWarriorEnemyCharacter::PossessedBy(AController* NewController)
{
    // 1. è°ƒç”¨çˆ¶ç±»åŸºç¡€é€»è¾‘ï¼ˆå¤„ç†æ§åˆ¶å™¨ç»‘å®šç­‰æ ¸å¿ƒæ“ä½œï¼‰
    Super::PossessedBy(NewController);
    
    // 2. åˆå§‹åŒ–æ•Œäººå¯åŠ¨æ•°æ®ï¼ˆå¦‚æŠ€èƒ½ã€å±æ€§ç­‰ï¼‰
    InitEnemyStartUpData(); // [1,3](@ref)
}

/**
 * @brief å¼‚æ­¥åŠ è½½å¹¶åº”ç”¨æ•Œäººä¸“å±çš„å¯åŠ¨æ•°æ®èµ„äº§
 * @note ä½¿ç”¨UEçš„å¼‚æ­¥åŠ è½½ç³»ç»Ÿé¿å…åŒæ­¥åŠ è½½å¯¼è‡´çš„å¡é¡¿ï¼Œé€‚ç”¨äºå¯èƒ½å¤§é‡ç”Ÿæˆçš„æ•Œäººå®ä¾‹
 * @warning è‹¥CharacterStartUpDataæœªé…ç½®ï¼Œå‡½æ•°å°†é™é»˜é€€å‡º
 */
void AWarriorEnemyCharacter::InitEnemyStartUpData()
{
    // æ£€æŸ¥æ•°æ®èµ„äº§è·¯å¾„æœ‰æ•ˆæ€§ï¼ˆTSoftObjectPtråˆ¤ç©ºï¼‰
    if (CharacterStartUpData.IsNull()) // é¿å…æ— æ•ˆåŠ è½½è¯·æ±‚
    {
        return; // æœªé…ç½®æ•°æ®æ—¶å®‰å…¨é€€å‡º
    }
    
    // 3. å‘èµ·å¼‚æ­¥åŠ è½½è¯·æ±‚ï¼ˆé€šè¿‡UEçš„æµå¼èµ„æºç®¡ç†å™¨ï¼‰
    UAssetManager::GetStreamableManager().RequestAsyncLoad(
        CharacterStartUpData.ToSoftObjectPath(), // è½¬æ¢è½¯å¼•ç”¨ä¸ºå¯åŠ è½½è·¯å¾„
        FStreamableDelegate::CreateLambda(        // å®šä¹‰åŠ è½½å®Œæˆå›è°ƒ
            [this]() // Lambdaæ•è·å½“å‰è§’è‰²å®ä¾‹
            {
                // 4. éªŒè¯åŠ è½½ç»“æœæœ‰æ•ˆæ€§
                if (UDataAsset_StartUpDataBase* LoadedData = CharacterStartUpData.Get())
                {
                    // 5. å°†æ•°æ®èµ‹äºˆè§’è‰²çš„èƒ½åŠ›ç³»ç»Ÿç»„ä»¶ï¼ˆASCï¼‰
                    LoadedData->GiveToAbilitySystemComponent(WarriorAbilitySystemComponent); // [1](@ref)
                    // è°ƒè¯•è¾“å‡ºç¤ºä¾‹ï¼ˆæ­£å¼ç¯å¢ƒå»ºè®®ç§»é™¤ï¼‰
                    // Debug::Print(TEXT("Enemy StartUpData Loaded"), FColor::Green); // [1](@ref)
                }
            }
        )
    );
}
```

**å…³é”®è®¾è®¡è§£æ**

1. **å¼‚æ­¥èµ„æºåŠ è½½ä¼˜åŒ–**
   - **`RequestAsyncLoad`**ï¼šé€šè¿‡UEçš„æµå¼èµ„æºç®¡ç†å™¨å¼‚æ­¥åŠ è½½æ•°æ®èµ„äº§ï¼Œé¿å…åŒæ­¥åŠ è½½å¡é¡¿ä¸»çº¿ç¨‹ã€‚
   - **é€‚ç”¨åœºæ™¯**ï¼šæ•Œäººè§’è‰²å¯èƒ½å¤§é‡ç”Ÿæˆï¼ŒåŒæ­¥åŠ è½½ä¼šå¯¼è‡´æ€§èƒ½ç“¶é¢ˆã€‚
   - **`TSoftObjectPtr`å®‰å…¨æœºåˆ¶**ï¼š  
     ä½¿ç”¨`IsNull()`æ£€æŸ¥è½¯å¼•ç”¨æœ‰æ•ˆæ€§ï¼Œ`Get()`è‡ªåŠ¨å¤„ç†åŠ è½½åçš„å¼ºå¼•ç”¨è½¬æ¢ã€‚

2. **GASæ•°æ®åˆå§‹åŒ–æµç¨‹**
   - **`GiveToAbilitySystemComponent`**ï¼š  
     æ•°æ®èµ„äº§ä¸­é…ç½®çš„æŠ€èƒ½ï¼ˆå¦‚`EnemyCombatAbilities`ï¼‰é€šè¿‡æ­¤æ–¹æ³•æ³¨å…¥ASCï¼Œå®ŒæˆæŠ€èƒ½æ³¨å†Œã€‚
   - **åŠ¨æ€æŠ€èƒ½èµ‹äºˆ**ï¼š  
     æ•°æ®èµ„äº§`UDataAsset_EnemyStartUpData`å¯åŒ…å«æ•Œäººä¸“å±æŠ€èƒ½ï¼Œå¦‚è¿‘æˆ˜è¿å‡»ã€æ ¼æŒ¡ç­‰ã€‚

3. **ç”Ÿå‘½å‘¨æœŸä¸äº‹ä»¶é©±åŠ¨**
   - **`PossessedBy`æ—¶æœº**ï¼š  
     æ§åˆ¶å™¨æ¥ç®¡æ—¶è§¦å‘åˆå§‹åŒ–ï¼Œç¡®ä¿AIè¡Œä¸ºæ ‘ä¸æŠ€èƒ½ç³»ç»ŸååŒå·¥ä½œã€‚
   - **Lambdaå›è°ƒä½œç”¨åŸŸ**ï¼š  
     é€šè¿‡`[this]`æ•è·å½“å‰è§’è‰²å®ä¾‹ï¼Œç¡®ä¿å›è°ƒä¸­èƒ½è®¿é—®æ­£ç¡®çš„`WarriorAbilitySystemComponent`ã€‚

4. **è°ƒè¯•ä¸é”™è¯¯å¤„ç†**
   - **é™é»˜å¤±è´¥è®¾è®¡**ï¼š  
     æ•°æ®æœªé…ç½®æ—¶ç›´æ¥é€€å‡ºï¼Œé¿å…è¿è¡Œæ—¶å´©æºƒã€‚
   - **è°ƒè¯•è¾“å‡º**ï¼š  
     æ³¨é‡Šçš„`Debug::Print`å¯ç”¨äºå¼€å‘é˜¶æ®µéªŒè¯åŠ è½½çŠ¶æ€ã€‚

### ç”Ÿæˆæ•Œäººæ­¦å™¨

ç»§æ‰¿SpawnWeaponBaseçš„è“å›¾ç±»å’Œç”Ÿæˆè§’è‰²æ­¦å™¨æµç¨‹å·®ä¸å¤š

## å±æ€§è®¾ç½®

![](./Lesson Images/Lesson4-2.png)

```c++
//WarriorAttributeSet.h 
#pragma once

#include "CoreMinimal.h"
#include "AttributeSet.h"
#include "AbilitySystem/WarriorAbilitySystemComponent.h"
#include "WarriorAttributeSet.generated.h"


// å±æ€§è®¿é—®å™¨å®å®šä¹‰ï¼ˆç®€åŒ–å±æ€§å£°æ˜ï¼‰
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
    GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \ // ç”Ÿæˆå±æ€§å…ƒæ•°æ®è·å–å™¨
    GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \               // ç”Ÿæˆå±æ€§å€¼Getter
    GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \               // ç”Ÿæˆå±æ€§å€¼Setter
    GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)               // ç”Ÿæˆå±æ€§å€¼åˆå§‹åŒ–å™¨

// è‡ªå®šä¹‰å±æ€§é›†ç±»ï¼ˆç»§æ‰¿GASæ ‡å‡†å±æ€§é›†ï¼‰
UCLASS()
class MYWARRIOR_API UWarriorAttributeSet : public UAttributeSet
{
    GENERATED_BODY() // UEåå°„ä»£ç ç”Ÿæˆ

public:
    // æ„é€ å‡½æ•°å£°æ˜
    UWarriorAttributeSet();

    //--- å±æ€§å®šä¹‰ï¼ˆä½¿ç”¨å®ç®€åŒ–è®¿é—®å™¨ç”Ÿæˆï¼‰---
    
    // å½“å‰ç”Ÿå‘½å€¼ï¼ˆè“å›¾åªè¯»ï¼‰
    UPROPERTY(BlueprintReadOnly, Category = "Health")
    FGameplayAttributeData CurrentHealth;
    ATTRIBUTE_ACCESSORS(UWarriorAttributeSet, CurrentHealth) // ç”ŸæˆGet/Setå‡½æ•°

    // æœ€å¤§ç”Ÿå‘½å€¼ï¼ˆè“å›¾åªè¯»ï¼‰
    UPROPERTY(BlueprintReadOnly, Category = "Health")
    FGameplayAttributeData MaxHealth;
    ATTRIBUTE_ACCESSORS(UWarriorAttributeSet, MaxHealth)

    // å½“å‰æ€’æ°”å€¼ï¼ˆç”¨äºæŠ€èƒ½é‡Šæ”¾èµ„æºï¼‰
    UPROPERTY(BlueprintReadOnly, Category = "Rage")
    FGameplayAttributeData CurrentRage;
    ATTRIBUTE_ACCESSORS(UWarriorAttributeSet, CurrentRage)

    // æœ€å¤§æ€’æ°”å€¼
    UPROPERTY(BlueprintReadOnly, Category = "Rage")
    FGameplayAttributeData MaxRage;
    ATTRIBUTE_ACCESSORS(UWarriorAttributeSet, MaxRage)

    // æ”»å‡»åŠ›ï¼ˆå½±å“ä¼¤å®³è¾“å‡ºï¼‰
    UPROPERTY(BlueprintReadOnly, Category = "Damage")
    FGameplayAttributeData AttackPower;
    ATTRIBUTE_ACCESSORS(UWarriorAttributeSet, AttackPower)

    // é˜²å¾¡åŠ›ï¼ˆå‡å°‘å—åˆ°çš„ä¼¤å®³ï¼‰
    UPROPERTY(BlueprintReadOnly, Category = "Damage")
    FGameplayAttributeData DefensePower;
    ATTRIBUTE_ACCESSORS(UWarriorAttributeSet, DefensePower)

    // å½“å‰æ‰¿å—çš„ä¼¤å®³ï¼ˆç”¨äºè®¡ç®—å®é™…ç”Ÿå‘½æ‰£é™¤ï¼‰
    UPROPERTY(BlueprintReadOnly, Category = "Damage")
    FGameplayAttributeData DamageTaken;
    ATTRIBUTE_ACCESSORS(UWarriorAttributeSet, DamageTaken)

};
//WarriorAttributeSet.cpp
// ç‰ˆæƒå£°æ˜
// Tcohneyn All Rights Reserved

#include "AbilitySystem/WarriorAttributeSet.h"

// æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–å±æ€§é»˜è®¤å€¼
UWarriorAttributeSet::UWarriorAttributeSet() 
{
    // åˆå§‹åŒ–æ‰€æœ‰å±æ€§ä¸º1.0ï¼ˆå®é™…é¡¹ç›®é€šå¸¸ä»æ•°æ®è¡¨è¯»å–åˆå§‹å€¼ï¼‰
    InitCurrentHealth(1.f);    // å½“å‰ç”Ÿå‘½å€¼
    InitMaxHealth(1.f);         // æœ€å¤§ç”Ÿå‘½å€¼
    InitCurrentRage(1.f);       // å½“å‰æ€’æ°”å€¼
    InitMaxRage(1.f);           // æœ€å¤§æ€’æ°”å€¼
    InitAttackPower(1.f);       // æ”»å‡»åŠ›
    InitDefensePower(1.f);      // é˜²å¾¡åŠ›
}

```

* ä½¿ç”¨showdebug abilitysystemæ§åˆ¶å°å‘½ä»¤æŸ¥çœ‹å±æ€§

![](./Lesson Images/4-1.png)

### Gameplay Effect

* å»ºç«‹æ›²çº¿è¡¨æ ¼ç”¨æ¥ä½œä¸ºå±æ€§æ•°æ®

![](./Lesson Images/4-2.png)



![](./Lesson Images/4-3.png)

* è¿™ç§æ–¹æ³•å¯ä»¥ç›´æ¥å¼€å§‹æ—¶ï¼Œè®©æœ€å¤§è¡€é‡èµ‹å€¼ç»™å½“å‰è¡€é‡

![](./Lesson Images/4-4.png)

### åº”ç”¨GameplayEffect

* å°†æ¸¸æˆæ•ˆæœåº”ç”¨åˆ°ç›®æ ‡ï¼Œåœ¨UDataAsset_StartUpDataBaseç±»ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªæ¸¸æˆæ•ˆæœç±»å‹çš„æ•°ç»„ï¼Œå¹¶å¤„ç†è¯¥å‡½æ•°å†…éƒ¨çš„åˆå§‹åŒ–ï¼Œèµ‹äºˆèƒ½åŠ›ç³»ç»Ÿç»„ä»¶

**UDataAsset_StartUpDataBaseç±»**

```c++
//UDataAsset_StartUpDataBase.h

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "DataAsset_StartUpDataBase.generated.h"

class UGameplayEffect;
UCLASS()
class MYWARRIOR_API UDataAsset_StartUpDataBase : public UDataAsset
{
    GENERATED_BODY()
public:
    virtual void GiveToAbilitySystemComponent(UWarriorAbilitySystemComponent* InASCToGive, int32 ApplyLevel = 1);

protected:

    UPROPERTY(EditDefaultsOnly, Category = "StartUpData")
    TArray<TSubclassOf<UGameplayEffect>> StartUpGameplayEffects;//å­˜å‚¨GEçš„æ•°ç»„
};
//UDataAsset_StartUpDataBase.cpp

#include "DataAssets/StartUpData/DataAsset_StartUpDataBase.h"
#include "AbilitySystem/WarriorAbilitySystemComponent.h" // è‡ªå®šä¹‰ASCç»„ä»¶
#include "AbilitySystem/Abilities/WarriorGameplayAbility.h" // è‡ªå®šä¹‰GameplayAbility

/**
 * @brief å‘ç›®æ ‡èƒ½åŠ›ç³»ç»Ÿç»„ä»¶ï¼ˆASCï¼‰èµ‹äºˆåˆå§‹èƒ½åŠ›å’Œæ•ˆæœ
 * @param InASCToGive ç›®æ ‡ASCç»„ä»¶ï¼ˆå¿…é¡»æœ‰æ•ˆï¼‰
 * @param ApplyLevel èƒ½åŠ›/æ•ˆæœçš„åˆå§‹ç­‰çº§
 * @note æ­¤å‡½æ•°æ˜¯è§’è‰²åˆå§‹åŒ–çš„æ ¸å¿ƒé€»è¾‘ï¼Œé›†æˆäº†GASçš„ä¸¤ç§å…³é”®èµ„æºï¼šèƒ½åŠ›ï¼ˆAbilitiesï¼‰å’Œæ•ˆæœï¼ˆEffectsï¼‰
 */
void UDataAsset_StartUpDataBase::GiveToAbilitySystemComponent(UWarriorAbilitySystemComponent* InASCToGive, int32 ApplyLevel)
{
    // 1. éªŒè¯ASCæœ‰æ•ˆæ€§ï¼ˆå¼€å‘é˜¶æ®µè§¦å‘æ–­è¨€ï¼Œè¿è¡Œæ—¶å®‰å…¨é€€å‡ºï¼‰
    check(InASCToGive); // å¼€å‘é˜¶æ®µå¼ºåˆ¶æ£€æŸ¥
    if (!InASCToGive) return; // è¿è¡Œæ—¶å®‰å…¨é˜²æŠ¤

    // 2. æˆäºˆä¸»åŠ¨èƒ½åŠ›ï¼ˆç«‹å³æ¿€æ´»ï¼‰[1,3](@ref)
    GrantAbilities(ActivateOnGivenAbilities, InASCToGive, ApplyLevel);    
    // 3. æˆäºˆè¢«åŠ¨/ååº”èƒ½åŠ›ï¼ˆå¦‚æ ¼æŒ¡ã€åå‡»ï¼‰[4](@ref)
    GrantAbilities(ReactiveAbilities, InASCToGive, ApplyLevel);

    // 4. åº”ç”¨åˆå§‹Gameplay Effectsï¼ˆå¦‚è§’è‰²åŸºç¡€å±æ€§ï¼‰[2,3](@ref)
    if (!StartUpGameplayEffects.IsEmpty())
    {
        for (const TSubclassOf<UGameplayEffect>& EffectClass : StartUpGameplayEffects)
        {
            if (!EffectClass) continue; // è·³è¿‡æ— æ•ˆæ•ˆæœç±»

            // 4.1 è·å–GameplayEffectçš„é»˜è®¤å¯¹è±¡ï¼ˆCDOï¼‰
            UGameplayEffect* EffectCDO = EffectClass->GetDefaultObject<UGameplayEffect>();
            
            // 4.2 å‘è‡ªèº«åº”ç”¨æ•ˆæœ
            InASCToGive->ApplyGameplayEffectToSelf(
                EffectCDO,           // æ•ˆæœå®ä¾‹
                ApplyLevel,           // æ•ˆæœç­‰çº§ï¼ˆå½±å“æ•°å€¼è®¡ç®—ï¼‰
                InASCToGive->MakeEffectContext() // åˆ›å»ºæ•ˆæœä¸Šä¸‹æ–‡ï¼ˆåŒ…å«æ¥æº/ç›®æ ‡ä¿¡æ¯ï¼‰
            );
        }
    }
}
```

### åˆå§‹åŒ–æ•Œäººçš„å±æ€§

åŸºæœ¬ä¸è§’è‰²çš„ä¸€è‡´æœ‰ä¸€ä¸ªåœ°æ–¹éœ€è¦æ³¨æ„ã€‚

åœ¨ `DefaultGame.ini` ä¸­æ·»åŠ ä»¥ä¸‹é…ç½®ä»¥å¯ç”¨ï¼š

```c++
[/Script/GameplayAbilities.AbilitySystemGlobals]
bUseDebugTargetFromHud=true
```

`bUseDebugTargetFromHud=true` æ˜¯GASè°ƒè¯•æµç¨‹çš„â€œå¿«æ·å¼€å…³â€ğŸ¯ï¼Œé€šè¿‡ç»‘å®šHUDç„¦ç‚¹å¯¹è±¡ï¼Œå¤§å¹…å‡å°‘æ‰‹åŠ¨åˆ‡æ¢ç›®æ ‡çš„ç¹çæ“ä½œã€‚å°¤å…¶åœ¨å¤šè§’è‰²æˆ–ç½‘ç»œç¯å¢ƒä¸‹ï¼Œèƒ½æ˜¾è‘—æå‡å¼€å‘æ•ˆç‡ã€‚å¦‚éœ€æ·±å…¥è°ƒè¯•å±æ€§åŒæ­¥æˆ–åº•å±‚é€»è¾‘ï¼Œå¯ç»“åˆ `AbilitySystem.Debug` ç³»åˆ—å‘½ä»¤è¿›ä¸€æ­¥åˆ†æ

## å‘½ä¸­æ£€æµ‹

ä¸ºäº†é€ æˆä¼¤å®³ï¼Œæˆ‘ä»¬éœ€è¦æ­£ç¡®çš„è®¾ç½®å‘½ä¸­æ£€æµ‹,å‘½ä¸­æ£€æµ‹ï¼Œæˆ‘ä»¬éœ€è¦å¤„ç†å››ä¸ªé—®é¢˜ã€‚

* æ­¦å™¨ç¢°æ’(Toggle Weapon Collision)
* å‘½ä¸­æ£€æŸ¥(Hit Check)
* å¤„ç†å‘½ä¸­(Process Hit)
* é€šçŸ¥ç»“æœ(Notify Result)

### æ­¦å™¨ç¢°æ’

* æˆ‘ä»¬ä½¿ç”¨åŠ¨ç”»çŠ¶æ€é€šçŸ¥æ¥å¼€å¯æ­¦å™¨ç¢°æ’ä¸å…³é—­æ­¦å™¨ç¢°æ’
* è¦å¯ç”¨æ­¦å™¨ç¢°æ’ï¼Œæ˜¾ç„¶éœ€è¦å…ˆ**è·å–æ­¦å™¨å®ä¾‹**â€”â€”è¿™å¯ä»¥é€šè¿‡æˆ‘ä»¬çš„PawnCombatComponentè®¿é—®ï¼Œåœ¨Pongæˆ˜æ–—ç»„ä»¶å†…éƒ¨ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º`ToggleCollision`çš„å‡½æ•°ï¼Œç„¶ååœ¨NMNotifyStateä¸­ç›´æ¥è°ƒç”¨æ­¤å‡½æ•°ï¼Œå°±èƒ½**éšæ—¶å¼€å…³ç¢°æ’**
* å½“å‰çš„é—®é¢˜æ˜¯ï¼šå¦‚ä½•ä»é€šçŸ¥çŠ¶æ€ä¸­**è·å–PawnCombatComponent**ï¼Ÿ
* ä¸ºäº†ï¼Œå¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œä¸€ç§æ–¹æ³•æ˜¯è™½ç„¶å¯ä»¥ç”¨`FindComponentByClass`åŠ¨æ€æœç´¢ç»„ä»¶ï¼Œä½†é«˜é¢‘è°ƒç”¨æ—¶**æ€§èƒ½æŸè€—è¾ƒå¤§**ã€‚

![](./Lesson Images/4-5.png)

* å› æ­¤é€‰æ‹©é€šè¿‡**æ¥å£æŠ½è±¡**å®ç°ï¼šåˆ›å»ºä¸€ä¸ª`IPawnCombat`æ¥å£ã€‚åœ¨`BaseCharacter`ä¸­å®ç°è¯¥æ¥å£ï¼Œå£°æ˜çº¯è™šå‡½æ•°`GetPongCombatComponent()`ã€‚è‹±é›„/æ•Œäººå­ç±»é‡å†™æ­¤å‡½æ•°ï¼Œè¿”å›å„è‡ªçš„æˆ˜æ–—ç»„ä»¶ã€‚åœ¨`ToggleWeaponCollision`é€šçŸ¥çŠ¶æ€ä¸­ï¼Œåªéœ€æ£€æŸ¥éª¨éª¼ç½‘æ ¼æ‰€æœ‰è€…æ˜¯å¦å®ç°æ­¤æ¥å£ï¼Œå³å¯**ç›´æ¥è·å–ç»„ä»¶**ã€‚

![](./Lesson Images/4-6.png)

![](./Lesson Images/4-7.png)

**PawnCombatInterfaceç±»**

```c++
//PawnCombatInterface.h

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "PawnCombatInterface.generated.h"

// å‰å‘å£°æ˜æˆ˜æ–—ç»„ä»¶ç±»ï¼ˆé¿å…å¾ªç¯ä¾èµ–ï¼‰
class UPawnCombatComponent;

UINTERFACE(MinimalAPI) 
class UPawnCombatInterface : public UInterface
{
    GENERATED_BODY()
};

/**
 * æˆ˜æ–—è§’è‰²æ¥å£å®šä¹‰ï¼ˆçº¯C++æ¥å£ç±»ï¼‰
 * ä½œç”¨ï¼šæä¾›ç»Ÿä¸€è®¿é—®è§’è‰²æˆ˜æ–—ç»„ä»¶çš„æ–¹å¼
 */
class MYWARRIOR_API IPawnCombatInterface
{
    GENERATED_BODY() 

public:
    // çº¯è™šå‡½æ•°ï¼šå¼ºåˆ¶æ´¾ç”Ÿç±»å®ç°æˆ˜æ–—ç»„ä»¶è·å–é€»è¾‘
    // è¿”å›å€¼ï¼šæŒ‡å‘UPawnCombatComponentçš„å¸¸é‡æŒ‡é’ˆ
    virtual UPawnCombatComponent* GetPawnCombatComponent() const = 0;
};
```

**WarriorBaseCharacterç±»**

```c++
//WarriorBaseCharacter.h
#pragma once
#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "AbilitySystemInterface.h"
#include "Interfaces/PawnCombatInterface.h"
#include "WarriorBaseCharacter.generated.h"
// åŒ…å«ç”Ÿæˆçš„å¤´æ–‡ä»¶ï¼Œç”¨äºåºåˆ—åŒ–å’Œåå°„

class UWarriorAbilitySystemComponent;
// å£°æ˜UWarriorAbilitySystemComponentç±»ï¼Œç”¨äºå‰å‘å£°æ˜
class UWarriorAttributeSet;
// å£°æ˜UWarriorAttributeSetç±»ï¼Œç”¨äºå‰å‘å£°æ˜
class UDataAsset_StartUpDataBase;


UCLASS()
class MYWARRIOR_API AWarriorBaseCharacter : public ACharacter, public IAbilitySystemInterface,public IPawnCombatInterface
{
    GENERATED_BODY()

public:

    // æ„é€ å‡½æ•°ï¼Œè®¾ç½®è§’è‰²çš„é»˜è®¤å±æ€§
    AWarriorBaseCharacter();

    //~ Begin IPawnCombatComponent Interface
    virtual UPawnCombatComponent* GetPawnCombatComponent() const override;
    //~ End IPawnCombatComponent Interface

};
//WarriorBaseCharacter.cpp
UPawnCombatComponent* AWarriorBaseCharacter::GetPawnCombatComponent() const
{
    return nullptr;
}
```

**WarriorHeroCharacterç±»**

```c++
//WarriorHeroCharacter.h
public:
    // æ„é€ å‡½æ•°å£°æ˜
    AWarriorHeroCharacter();

    //~ Begin IPawnCombatInterface Interface
    // é‡å†™æˆ˜æ–—æ¥å£çš„çº¯è™šå‡½æ•°
    virtual UPawnCombatComponent* GetPawnCombatComponent() const override;
    //~ End IPawnCombatInterface Interface
public:
    // å†…è”å‡½æ•°ï¼šè·å–è‹±é›„ä¸“å±æˆ˜æ–—ç»„ä»¶ï¼ˆç±»å‹å®‰å…¨ï¼‰
    FORCEINLINE UHeroCombatComponent* GetHeroCombatComponent() const 
    { 
        return HeroCombatComponent; 
    }
private:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Combat", meta = (AllowPrivateAccess = "true"))
    UHeroCombatComponent* HeroCombatComponent;
//WarriorHeroCharacter.cpp
// Tcohneyn All Rights Reserved

#include "Components/Combat/HeroCombatComponent.h"

AWarriorHeroCharacter::AWarriorHeroCharacter()
{    // åˆ›å»ºé»˜è®¤çš„è‹±é›„æˆ˜æ–—ç»„ä»¶å®ä¾‹
    // å‚æ•°1ï¼šç»„ä»¶ç±»æ¨¡æ¿
    // å‚æ•°2ï¼šç»„ä»¶åç§°ï¼ˆç”¨äºè°ƒè¯•å’Œåºåˆ—åŒ–ï¼‰
    HeroCombatComponent = CreateDefaultSubobject<UHeroCombatComponent>(TEXT("HeroCombatComponent"));
}

UPawnCombatComponent* AWarriorHeroCharacter::GetPawnCombatComponent() const
{
    // è¿”å›åŸºç±»æŒ‡é’ˆï¼ˆå®ç°å¤šæ€ï¼‰
    return HeroCombatComponent;
}
```

**WarriorEnemyCharacterç±»åŒä¸Š**

**WarriorFunctionLibraryç±»**

```c++
//WarriorFunctionLibrary.h
class UPawnCombatComponent;
// åŸç”Ÿå‡½æ•°ï¼šä»Actorè·å–æˆ˜æ–—ç»„ä»¶ (C++ä¸“ç”¨)
	static UPawnCombatComponent* NativeGetPawnCombatComponentFromActor(AActor* InActor);
// è“å›¾å‡½æ•°ï¼šä»Actorè·å–æˆ˜æ–—ç»„ä»¶ (è“å›¾å¯è°ƒç”¨)
// ExpandEnumAsExecsï¼šå°†è¾“å‡ºæšä¸¾è½¬æ¢ä¸ºè“å›¾æ‰§è¡Œåˆ†æ”¯å¼•è„š
// DisplayNameï¼šè“å›¾èŠ‚ç‚¹æ˜¾ç¤ºåç§°
	UFUNCTION(BlueprintCallable, Category = "Warrior|FunctionLibrary", meta = (DisplayName = "Get Pawn Combat Component From Actor", ExpandEnumAsExecs = "OutValidType"))
	static UPawnCombatComponent* BP_GetPawnCombatComponentFromActor(AActor* InActor, EWarriorValidType& OutValidType);
//WarriorFunctionLibrary.cpp
#include "Interfaces/PawnCombatInterface.h"
/**
 * @brief ä»Actorè·å–æˆ˜æ–—ç»„ä»¶çš„åŸç”Ÿå®ç°
 * @param InActor ç›®æ ‡Actor
 * @return æˆ˜æ–—ç»„ä»¶æŒ‡é’ˆï¼Œæ— æ•ˆæ—¶è¿”å›nullptr
 * @note åŸºäºIPawnCombatInterfaceæ¥å£å®ç°
 */
UPawnCombatComponent* UWarriorFunctionLibrary::NativeGetPawnCombatComponentFromActor(AActor* InActor)
{
    check(InActor); // ç¡®ä¿è¾“å…¥å‚æ•°æœ‰æ•ˆ (ä»…åœ¨å¼€å‘æ¨¡å¼ç¼–è¯‘)
    
    // 1. éªŒè¯Actoræ˜¯å¦å®ç°æˆ˜æ–—æ¥å£
    if (IPawnCombatInterface* PawnCombatInterface = Cast<IPawnCombatInterface>(InActor))
    {
        // 2. é€šè¿‡æ¥å£ç›´æ¥è·å–ç»„ä»¶æŒ‡é’ˆ
        return PawnCombatInterface->GetPawnCombatComponent();
    }
    return nullptr; // æ— æˆ˜æ–—ç»„ä»¶
}

/**
 * @brief è“å›¾å¯è°ƒç”¨çš„æˆ˜æ–—ç»„ä»¶è·å–æ–¹æ³•
 * @param InActor ç›®æ ‡Actor
 * @param OutValidType è¾“å‡ºå‚æ•°ï¼šç»„ä»¶æœ‰æ•ˆæ€§
 * @return æˆ˜æ–—ç»„ä»¶æŒ‡é’ˆ (æ— æ•ˆæ—¶ä¸ºnullptr)
 * @note ExpandEnumAsExecså…ƒæ•°æ®ä½¿è“å›¾ä¸­è‡ªåŠ¨ç”Ÿæˆæ‰§è¡Œåˆ†æ”¯
 */
UPawnCombatComponent* UWarriorFunctionLibrary::BP_GetPawnCombatComponentFromActor(
    AActor* InActor, 
    EWarriorValidType& OutValidType)
{
    // 1. è°ƒç”¨åŸç”Ÿå®ç°è·å–ç»„ä»¶
    UPawnCombatComponent* CombatComponent = NativeGetPawnCombatComponentFromActor(InActor);
    
    // 2. è®¾ç½®æœ‰æ•ˆæ€§æšä¸¾å€¼
    OutValidType = CombatComponent ? 
        EWarriorValidType::Valid :      // æœ‰æ•ˆç»„ä»¶
        EWarriorValidType::InValid;     // æ— æ•ˆç»„ä»¶
    
    return CombatComponent;
}
```

**PawnCombatComponentç±»**

```c++
//PawnCombatComponent.h
UCLASS()
class MYWARRIOR_API UPawnCombatComponent : public UPawnExtensionComponentBase
{
    GENERATED_BODY()
    /**
     * @brief å¼€å…³æ­¦å™¨ç¢°æ’ä½“çš„æ ¸å¿ƒæ¥å£ï¼ˆè“å›¾å¯è°ƒç”¨ï¼‰
     * @param bShouldEnable æ˜¯å¦å¯ç”¨ç¢°æ’
     * @param ToggleDamageType ç¢°æ’ä½“ç±»å‹ï¼ˆé»˜è®¤ä¸ºå½“å‰è£…å¤‡æ­¦å™¨ï¼‰
     *
     * @note æ­¤å‡½æ•°é€šè¿‡è“å›¾åœ¨åŠ¨ç”»é€šçŸ¥ä¸­è¢«è°ƒç”¨ï¼Œå®ç°æ”»å‡»åŠ¨ä½œæœŸé—´æ­¦å™¨ç¢°æ’ä½“çš„ç²¾ç¡®æ¿€æ´»
     * @tip ä½¿ç”¨EToggleDamageTypeå®šä¹‰ä¸åŒç¢°æ’æºï¼ˆæ­¦å™¨/èº«ä½“ï¼‰
     */
      UFUNCTION(BlueprintCallable, Category = "Warrior|Combat")
    void ToggleWeaponCollision(bool bShouldEnable, EToggleDamageType ToggleDamageType = EToggleDamageType::CurrentEquippedWeapon);
};
//PawnCombatComponent.cpp
#include "Components/BoxComponent.h"
void UPawnCombatComponent::ToggleWeaponCollision(bool bShouldEnable, EToggleDamageType ToggleDamageType)
{
    // 1. å¤„ç†è£…å¤‡æ­¦å™¨ç¢°æ’ä½“
    if (ToggleDamageType == EToggleDamageType::CurrentEquippedWeapon)
    {
        // 1.1 è·å–å½“å‰è£…å¤‡çš„æ­¦å™¨å®ä¾‹
        AWarriorWeaponBase* WeaponToToggle = GetCharacterCurrentEquippedWeapon();
        check(WeaponToToggle); // ç¡®ä¿æ­¦å™¨å­˜åœ¨ï¼ˆå¼€å‘æœŸå´©æºƒé˜²æŠ¤ï¼‰
        
        // 1.2 è·å–æ­¦å™¨ç¢°æ’ç›’ç»„ä»¶
        UBoxComponent* WeaponCollisionBox = WeaponToToggle->GetWeaponCollisionBox();
        
        // 1.3 ç¢°æ’å¼€å…³é€»è¾‘
        if (bShouldEnable) 
        {
            // å¯ç”¨æ­¦å™¨ç¢°æ’ï¼ˆä»…æ£€æµ‹æŸ¥è¯¢ï¼Œä¸å‘ç”Ÿç‰©ç†åé¦ˆï¼‰
            WeaponCollisionBox->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
            
            // è°ƒè¯•è¾“å‡º (å¼€å‘æœŸä½¿ç”¨)
            //Debug::Print(WeaponToToggle->GetName() + TEXT(" Collision Enabled"), FColor::Green);
        }
        else 
        {
            // ç¦ç”¨æ­¦å™¨ç¢°æ’
            WeaponCollisionBox->SetCollisionEnabled(ECollisionEnabled::NoCollision);
            
            // æ¸…ç©ºå½“å‰è®°å½•çš„å—å‡»Actoråˆ—è¡¨ï¼ˆé˜²æ­¢é‡å¤è®¡ç®—ä¼¤å®³ï¼‰
            OverlappedActors.Empty();
            
            // è°ƒè¯•è¾“å‡º
            //Debug::Print(WeaponToToggle->GetName() + TEXT(" Collision Disabled"), FColor::Red);
        }
    }
    
    // 2. TODO: æœªæ¥æ‰©å±•ç‚¹ - å¤„ç†èº«ä½“ç¢°æ’ç›’çš„å¼€å…³é€»è¾‘
    // if (ToggleDamageType == EToggleDamageType::BodyCollision) 
    // {
    //    // å®ç°èº«ä½“ç¢°æ’ä½“æ§åˆ¶
    // }
}
```

**ANS_ToggleWeaponCollision_Cè“å›¾ç±»**

```lua
---@type ANS_ToggleWeaponCollision_C
local M = UnLua.Class()

function M:Received_NotifyBegin(MeshComp)
    local Owner = MeshComp:GetOwner()-- è·å–éª¨éª¼ç½‘æ ¼ç»„ä»¶çš„æ‹¥æœ‰è€…ï¼ˆé€šå¸¸ä¸ºè§’è‰²Actorï¼‰
    local CombatComponet = UE.UWarriorFunctionLibrary.BP_GetPawnCombatComponentFromActor(Owner)
    if CombatComponet then
    CombatComponet:ToggleWeaponCollision(true,self.ToggleDamageType)
else
    print("ERROR: Missing combat component on "..Owner:GetName())
end
    return false -- è¿”å› false ä»¥é˜»æ­¢åŠ¨ç”»ç»§ç»­æ’­æ”¾
end


function M:Received_NotifyEnd(MeshComp)
    local Owner = MeshComp:GetOwner()
    local CombatComponet = UE.UWarriorFunctionLibrary.BP_GetPawnCombatComponentFromActor(Owner)
    CombatComponet:ToggleWeaponCollision(false,self.ToggleDamageType)
    return false -- è¿”å› false ä»¥é˜»æ­¢åŠ¨ç”»ç»§ç»­æ’­æ”¾
end

return M
```

### å‘½ä¸­æ£€æŸ¥

æ¥ä¸‹æ¥éœ€è¦å¤„ç†çš„æ˜¯**å‘½ä¸­æ£€æµ‹ï¼ˆHit Checkï¼‰**â€”â€”æˆ‘ä»¬éœ€è¦ç¡®ä¿æ­¦å™¨***ä»…å¯¹ç©å®¶å’Œæ•Œäººçš„é¢„è®¾ç›®æ ‡***é€ æˆä¼¤å®³ã€‚å…·ä½“å®ç°æ–¹æ¡ˆå¦‚ä¸‹ï¼š

1. **é€»è¾‘èµ·ç‚¹ï¼šæ­¦å™¨åŸºç±»ï¼ˆWeapon Base Classï¼‰**â€”â€”åœ¨åŸºç±»ä¸­ä¸ºç¢°æ’ä½“çš„**é‡å äº‹ä»¶ï¼ˆOverlap Eventsï¼‰**åˆ›å»ºå›è°ƒå‡½æ•°ã€‚å½“æ­¦å™¨ç¢°æ’ç›’ä¸ç›®æ ‡å‘ç”Ÿé‡å æ—¶ï¼Œé¦–å…ˆéªŒè¯ç›®æ ‡æ˜¯å¦å±äº **æ•Œå¯¹å…³ç³»ï¼ˆHostileï¼‰**ã€‚
2. **æ•Œå¯¹å…³ç³»éªŒè¯æµç¨‹**â€”â€”è‹¥ç›®æ ‡**éæ•Œå¯¹**ï¼Œåˆ™æ— éœ€ä»»ä½•æ“ä½œã€‚è‹¥ç›®æ ‡ä¸º**æ•Œå¯¹ç›®æ ‡**ï¼Œå°†æ­¤ä¿¡æ¯ä¼ é€’ç»™è§’è‰²çš„**æˆ˜æ–—ç»„ä»¶ï¼ˆCombatComponentï¼‰**ã€‚
3. **æˆ˜æ–—ç»„ä»¶å¤„ç†**â€”â€”CombatComponent` å°†æ¥ç®¡åç»­æµç¨‹ï¼Œæ‰§è¡Œ**ä¼¤å®³å¤„ç†é€»è¾‘**

![](./Lesson Images/4-8.png)

```c++
//WarriorWeaponBase.h
DECLARE_DELEGATE_OneParam(FOnTargetInteractedDelegate,AActor*)//å§”æ‰˜å£°æ˜

UCLASS()
class MYWARRIOR_API AWarriorWeaponBase : public AActor
{
    GENERATED_BODY()
    public:
    // æ­¦å™¨å‡»ä¸­ç›®æ ‡æ—¶è§¦å‘çš„å§”æ‰˜
    FOnTargetInteractedDelegate OnWeaponHitTarget;
    // æ­¦å™¨ç¦»å¼€ç›®æ ‡æ—¶è§¦å‘çš„å§”æ‰˜
    FOnTargetInteractedDelegate OnWeaponPulledFromTarget;
    protected:
    // ç¢°æ’ç›’å¼€å§‹é‡å äº‹ä»¶å¤„ç†å‡½æ•°
    UFUNCTION()
    virtual void OnCollisonBoxBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,
        int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    // ç¢°æ’ç›’ç»“æŸé‡å äº‹ä»¶å¤„ç†å‡½æ•°
    UFUNCTION()
    virtual void OnCollisonBoxEndOverlap(
        UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);    
};
//WarriorWeaponBase.cpp
AWarriorWeaponBase::AWarriorWeaponBase()
{
    WeaponCollisionBox->OnComponentBeginOverlap.AddUniqueDynamic(this,&ThisClass::OnCollisionBoxBeginOverlap);
    WeaponCollisionBox->OnComponentEndOverlap.AddUniqueDynamic(this,&ThisClass::OnCollisionBoxEndOverlap);
}
void AWarriorWeaponBase::OnCollisionBoxBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
    // è·å–æ­¦å™¨æŒæœ‰è€…ï¼ˆç©å®¶æˆ–AIæ§åˆ¶çš„Pawnï¼‰
    APawn* WeaponOwningPawn = GetInstigator<APawn>();
    // éªŒè¯æŒæœ‰è€…æœ‰æ•ˆæ€§ï¼ˆé˜²å¾¡æ€§ç¼–ç¨‹ï¼‰
    checkf(WeaponOwningPawn, TEXT("Forget to assign an instiagtor as the owning pawn for the weapon %s"),*GetName());
    // æ£€æŸ¥é‡å å¯¹è±¡æ˜¯å¦ä¸ºPawnï¼ˆæ’é™¤åœºæ™¯ç‰©ä½“ï¼‰
    if (APawn* HitPawn = Cast<APawn>(OtherActor))
    {
        // é˜²æ­¢æ”»å‡»è‡ªèº«ï¼ˆå¦‚è§’è‰²æ­¦å™¨ç¢°åˆ°è‡ªå·±ï¼‰
        if (WeaponOwningPawn != HitPawn)
        {
            // è§¦å‘å‘½ä¸­äº‹ä»¶ï¼ˆé€šçŸ¥CombatComponentå¤„ç†ä¼¤å®³é€»è¾‘ï¼‰
            OnWeaponHitTarget.ExecuteIfBound(OtherActor);
            
            // TODO: æ‰©å±•æ•Œå¯¹æ£€æµ‹é€»è¾‘ï¼ˆå¦‚é˜µè¥ç³»ç»Ÿ/é˜Ÿä¼å…³ç³»ï¼‰
            // å½“å‰å®ç°ä»…æ’é™¤è‡ªèº«ï¼Œéœ€å¢åŠ æ•Œäººè¯†åˆ«
        }
    }
}

void AWarriorWeaponBase::OnCollisionBoxEndOverlap(
    UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
    APawn* WeaponOwningPawn = GetInstigator<APawn>();
    checkf(WeaponOwningPawn, ...); // åŒä¸Šæœ‰æ•ˆæ€§æ£€æŸ¥

    if (APawn* HitPawn = Cast<APawn>(OtherActor))
    {
        if (WeaponOwningPawn != HitPawn)
        {
            // é€šçŸ¥ç›®æ ‡ç¦»å¼€ï¼ˆå¯ç”¨äºç»“æŸè¿å‡»/é‡ç½®çŠ¶æ€ï¼‰
            OnWeaponPulledFromTarget.ExecuteIfBound(OtherActor);
        }
    }
}
```

**PawnCombatComponentç±»**

```c++
//PawnCombatComponent.h
// å£°æ˜æ­¦å™¨å‘½ä¸­ç›®æ ‡æ—¶çš„å›è°ƒå‡½æ•°ï¼ˆè™šå‡½æ•°æ”¯æŒå­ç±»é‡å†™ï¼‰
    virtual void OnHitTargetActor(AActor* HitActor);
// å£°æ˜æ­¦å™¨ç¦»å¼€ç›®æ ‡æ—¶çš„å›è°ƒå‡½æ•°ï¼ˆè™šå‡½æ•°æ”¯æŒå­ç±»é‡å†™ï¼‰
    virtual void OnWeaponPulledFromTargetActor(AActor* InteractedActor);
//PawnCombatComponent.cpp
void UPawnCombatComponent::RegisterSpawnedWeapon(
    FGameplayTag InWeaponTagToRegister, AWarriorWeaponBase* InWeaponToRegister, bool bRegisterAsEquippedWeapon)
{
     // å°†æ­¦å™¨çš„å‘½ä¸­äº‹ä»¶å§”æ‰˜ç»‘å®šåˆ°å½“å‰æˆ˜æ–—ç»„ä»¶çš„å›è°ƒå‡½æ•°
    // BindUObject ç¡®ä¿å§”æ‰˜è°ƒç”¨æ—¶ä¿ç•™å¯¹è±¡ä¸Šä¸‹æ–‡ï¼ˆé¿å…é‡æŒ‡é’ˆï¼‰
    InWeaponToRegister->OnWeaponHitTarget.BindUObject(this,&ThisClass::OnHitTargetActor);
    // å°†æ­¦å™¨çš„ç¦»å¼€äº‹ä»¶å§”æ‰˜ç»‘å®šåˆ°å½“å‰æˆ˜æ–—ç»„ä»¶çš„å›è°ƒå‡½æ•°
    InWeaponToRegister->OnWeaponPulledFromTarget.BindUObject(this, &ThisClass::OnWeaponPulledFromTargetActor);
}
void UPawnCombatComponent::OnHitTargetActor(AActor* HitActor) {}

void UPawnCombatComponent::OnWeaponPulledFromTargetActor(AActor* InteractedActor) {}
```

**HeroCombatComponentç±»**

```c++
//HeroCombatComponent.h
    virtual void OnHitTargetActor(AActor* HitActor) override;
    virtual void OnWeaponPulledFromTargetActor(AActor* InteractedActor) override;
//HeroCombatComponent.cpp
#include "WarriorDebugHelper.h"
void UHeroCombatComponent::OnHitTargetActor(AActor* HitActor) 
{
    Debug::Print(GetOwningPawn()->GetActorNameOrLabel() + TEXT("hit") + HitActor->GetActorNameOrLabel(), FColor::Green);
}

void UHeroCombatComponent::OnWeaponPulledFromTargetActor(AActor* InteractedActor) 
{
    Debug::Print(GetOwningPawn()->GetActorNameOrLabel() + TEXT("s weapon pulled from") + InteractedActor->GetActorNameOrLabel(), FColor::Red);
}
```

### å¤„ç†å‘½ä¸­

* ç°åœ¨æ¥å¤„ç†ä¼¤å®³å¹¶ä¸”é€šçŸ¥æˆ‘ä»¬çš„æ¸¸æˆèƒ½åŠ›æ¥å®æ–½ä¼¤å®³
* é¦–å…ˆè¦å…¨éƒ¨åªèƒ½ä¼¤å®³ç›®æ ‡ä¸€æ¬¡ï¼Œæ–°å»ºä¸€ä¸ªç”¨æ¥å­˜å‚¨é‡å çš„Actor
* æ¯æ¬¡ç¢°æ’çŠ¶æ€é€šçŸ¥ç»“æŸåï¼Œæ¸…é™¤ä¸€ä¸‹æ•°ç»„

**PawnCombatComponentç±»**

```c++
//PawnCombatComponent.h
protected:
    TArray<AActor*> OverlappedActors;
//PawnCombatComponent.cpp
void UPawnCombatComponent::ToggleWeaponCollision(bool bShouldEnable, EToggleDamageType ToggleDamageType)
{
       .........
            WeaponToToggle->GetWeaponCollisionBox()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
            //Debug::Print(WeaponToToggle->GetName() + TEXT(" Collision Disabled"), FColor::Red);
            OverlappedActors.Empty();//æ¸…ç©ºå‘½ä¸­è®¡æ•°æ•°ç»„
        }
    }
    //TODO:Handle body collision boxes
}
```

* åœ¨ç¢°æ’æ—¶ï¼Œç¡®ä¿åªé€ æˆäº†ä¸€æ¬¡ä¼¤å®³

**HeroCombatComponentç±»**

```c++
// HeroCombatComponent.cpp

// å‡½æ•°åŠŸèƒ½ï¼šå¤„ç†æ­¦å™¨å‘½ä¸­ç›®æ ‡Actoræ—¶çš„é€»è¾‘ï¼Œé¿å…é‡å¤è§¦å‘ä¼¤å®³
void UHeroCombatComponent::OnHitTargetActor(AActor* HitActor) 
{
    // æ£€æŸ¥ç›®æ ‡Actoræ˜¯å¦å·²è¢«è®°å½•ï¼ˆé¿å…å•æ¬¡æ”»å‡»å¤šæ¬¡å‘½ä¸­åŒä¸€ç›®æ ‡ï¼‰
    if (OverlappedActors.Contains(HitActor))
    {
        return; // è‹¥å·²å‘½ä¸­è¿‡ï¼Œç›´æ¥è¿”å›ï¼ˆä¸é‡å¤å¤„ç†ï¼‰
    }
    
    // å°†æ–°å‘½ä¸­çš„ç›®æ ‡åŠ å…¥å·²å‘½ä¸­åˆ—è¡¨
    OverlappedActors.AddUnique(HitActor);
}
```

### é€šçŸ¥ç»“æœ

æ¥ä¸‹æ¥è¦å¤„ç†çš„æ˜¯ï¼šåœ¨æ£€æµ‹åˆ°æœ‰æ•ˆå‘½ä¸­æ—¶ï¼Œé€šçŸ¥æ¸¸æˆæŠ€èƒ½ï¼ˆGameplay Abilityï¼‰åº”ç”¨ä¼¤å®³ã€‚å…·ä½“æµç¨‹å¦‚ä¸‹ï¼š

ä»¥è½»æ”»å‡»æŠ€èƒ½ï¼ˆGA_LightAttackï¼‰ä¸ºä¾‹ï¼šæ¸¸æˆæŠ€èƒ½ å°†æ’­æ”¾æ”»å‡»åŠ¨ç”»è’™å¤ªå¥‡ï¼ˆMontageï¼‰ï¼Œå¹¶åœ¨æ’­æ”¾æœŸé—´ç­‰å¾…æ¸¸æˆäº‹ä»¶ï¼ˆGameplay Eventï¼‰ã€‚è¯¥äº‹ä»¶ç”±æˆ˜æ–—ç»„ä»¶ï¼ˆCombat Componentï¼‰å‘é€ã€‚å½“æˆ˜æ–—ç»„ä»¶æ£€æµ‹åˆ°å‘½ä¸­æ—¶ï¼Œå®ƒä¼šå‘æ¸¸æˆæŠ€èƒ½å‘é€æ­¤äº‹ä»¶ã€‚äº‹ä»¶ä¼ é€’è‡³æ¸¸æˆæŠ€èƒ½è“å›¾åï¼Œæˆ‘ä»¬å°†åœ¨æ­¤å¤„åº”ç”¨ä¼¤å®³ã€‚

![](./Lesson Images/4-9.png)

**HeroCombatComponentç±»**

```c++
//HeroCombatComponent.cpp
#include "WarriorGameplayTags.h"         // å¼•ç”¨è‡ªå®šä¹‰çš„æ¸¸æˆæ ‡ç­¾åº“ï¼ˆç”¨äºæ ‡è¯†äº‹ä»¶ç±»å‹ï¼‰
#include "AbilitySystemBlueprintLibrary.h" // æä¾›GASè“å›¾åº“åŠŸèƒ½

void UHeroCombatComponent::OnHitTargetActor(AActor* HitActor) 
{
    // 3. æ„é€ æ¸¸æˆäº‹ä»¶æ•°æ®ï¼ˆä¼ é€’ä¼¤å®³è®¡ç®—æ‰€éœ€ä¸Šä¸‹æ–‡ï¼‰
    FGameplayEventData Data;
    Data.Instigator = GetOwningPawn();  // ä¼¤å®³å‘èµ·è€…ï¼ˆç©å®¶è§’è‰²ï¼‰
    Data.Target = HitActor;              // ä¼¤å®³æ‰¿å—è€…ï¼ˆè¢«å‡»ä¸­çš„Actorï¼‰

    // 4. å‘é€è¿‘æˆ˜å‘½ä¸­äº‹ä»¶ï¼ˆè§¦å‘ä¼¤å®³æŠ€èƒ½ï¼‰
    UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(
        GetOwningPawn(),                       // äº‹ä»¶å‘é€ç»™ç©å®¶è§’è‰²çš„AbilitySystemComponent
        WarriorGameplayTags::Shared_Event_MeleeHit, // æ ‡ç­¾ï¼šæ ‡è¯†"è¿‘æˆ˜å‘½ä¸­"äº‹ä»¶ç±»å‹
        Data                                    // åŒ…å«æ”»å‡»è€…/ç›®æ ‡çš„ä¸Šä¸‹æ–‡æ•°æ®
    );
}
```

**Hero_LightAttackMasterç±»**

```c++
//Hero_LightAttackMaster.cpp
void UHero_LightAttackMaster::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    UsedComboCount = CurrentLightAttackComboCount;//ç”¨å¦ä¸€ä¸ªå˜é‡å­˜å‚¨å½“å‰è®¡æ•°é˜²æ­¢CurrentLightAttackComboCountå› åŒæ—¶å¢åŠ é”™è¯¯
}
void UHero_LightAttackMaster::RunSequenceTasks()
{
    // å®šä¹‰ä»»åŠ¡åºåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼ˆLambda å‡½æ•°å°è£…ï¼‰
    auto Task1 = [this]  // æ•è·å½“å‰ç±»çš„ä¸Šä¸‹æ–‡
    {
        // åˆ›å»ºç­‰å¾…æ¸¸æˆäº‹ä»¶çš„å¼‚æ­¥ä»»åŠ¡
        // å‚æ•°è¯´æ˜ï¼š
        //   this: å½“å‰æŠ€èƒ½å¯¹è±¡ï¼ˆOwnerï¼‰
        //   EventTag: éœ€ç›‘å¬çš„æ¸¸æˆäº‹ä»¶æ ‡ç­¾ï¼ˆå¦‚"Event.Combat.Hit"ï¼‰
        WaitEventTask = UAbilityTask_WaitGameplayEvent::WaitGameplayEvent(this, EventTag);

        // ç»‘å®šäº‹ä»¶å›è°ƒï¼šå½“æ¥æ”¶åˆ°æŒ‡å®šæ ‡ç­¾çš„æ¸¸æˆäº‹ä»¶æ—¶ï¼Œè§¦å‘OnGameplayEventReceived
        WaitEventTask->EventReceived.AddDynamic(
            this, 
            &ThisClass::OnGameplayEventReceived  // äº‹ä»¶å¤„ç†å‡½æ•°
        );

        // æ¿€æ´»ä»»åŠ¡ï¼ˆä½¿ä»»åŠ¡è¿›å…¥å¯æ‰§è¡ŒçŠ¶æ€ï¼‰
        WaitEventTask->ReadyForActivation();
    };

}
```

* ç°åœ¨é€‰ä¸­è¿™ä¸ªç±»çš„é»˜è®¤è®¾ç½®ï¼ˆåœ¨é«˜çº§ä¸‹æ‹‰èœå•ä¸‹ï¼‰ï¼Œæˆ‘éœ€è¦å–æ¶ˆå‹¾é€‰   **åœ¨ç¼–è¾‘å™¨ä¸­æ˜¾ç¤ºè§¦å‘æ•ˆæœâ€ï¼ˆshow fire in editorï¼‰**é€‰é¡¹

![](./Lesson Images/4-10.png)

1. **`Show Fire in Editor` çš„ä½œç”¨**

* æ§åˆ¶ç¼–è¾‘å™¨å†…æ˜¯å¦é¢„è§ˆåŠ¨ç”»é€šçŸ¥ï¼ˆå¦‚ç²’å­ç‰¹æ•ˆã€éŸ³æ•ˆï¼‰ï¼Œå–æ¶ˆå‹¾é€‰å¯é¿å…

  æœªåˆå§‹åŒ–æ—¶è§¦å‘é€»è¾‘é”™è¯¯ã€‚

* å…¸å‹åº”ç”¨åœºæ™¯ï¼šæ”»å‡»åŠ¨ç”»çš„ä¼¤å®³åˆ¤å®šé€šçŸ¥éœ€åœ¨è¿è¡Œæ—¶æ¿€æ´»ï¼Œè€Œéç¼–è¾‘é˜¶æ®µã€‚

2. **æ–­è¨€é”™è¯¯ï¼ˆAssertionï¼‰çš„æˆå› **

* å½“`NM Notify State`å°è¯•è®¿é—®`Mesh Component`æ—¶ï¼Œè‹¥ç»„ä»¶çš„**æ‰€æœ‰è€…ï¼ˆOwnerï¼‰æœªå®Œæˆåˆå§‹åŒ–**ï¼ˆå¦‚`Pong Comeback`ç»„ä»¶æœªæ³¨å…¥ä¾èµ–ï¼‰ï¼Œä¼šè§¦å‘å¼•æ“çš„å®‰å…¨æ£€æŸ¥æœºåˆ¶ã€‚
* è§£å†³æ–¹æ¡ˆï¼šé€šè¿‡**å»¶è¿Ÿåˆå§‹åŒ–**æˆ–**äº‹ä»¶é©±åŠ¨**ï¼ˆå¦‚`BeginPlay`ï¼‰ç¡®ä¿èµ„æºå°±ç»ªã€‚

## è‡ªå®šä¹‰è®¡ç®—

æ¥ä¸‹æ¥è¦å¤„ç†çš„æ˜¯**è‡ªå®šä¹‰ä¼¤å®³è®¡ç®—ï¼ˆCustom Damage Calculationï¼‰**ã€‚è¿™ä¸€æ­¥å°†ç»¼åˆæ‰€æœ‰ç›¸å…³å±æ€§æ•°æ®ï¼Œæœ€ç»ˆå¯¹ç›®æ ‡æ–½åŠ ä¼¤å®³ã€‚å…·ä½“æµç¨‹å¦‚ä¸‹ï¼š

1. **èµ·ç‚¹ï¼šæ”»å‡»æŠ€èƒ½ï¼ˆAttack Abilityï¼‰**
     å½“æŠ€èƒ½æ¥æ”¶åˆ°æˆ˜æ–—ç»„ä»¶ï¼ˆCombatComponentï¼‰å‘é€çš„**æ¸¸æˆäº‹ä»¶ï¼ˆGameplay Eventï¼‰**ååˆ›å»º**GameplayFXå¥æŸ„ï¼ˆGameplay Effect Spec Handleï¼‰** ç”¨äºæ‰¿è½½æœ€ç»ˆä¼¤å®³æ•°æ®ã€‚
2. **GameplayFXå¥æŸ„çš„ä½œç”¨** 
     é€šè¿‡æ­¤å¥æŸ„å¯å­˜å‚¨æ‰©å±•ä¿¡æ¯ï¼ˆå¦‚æ”»å‡»ç±»å‹ã€è¿å‡»æ•°ã€æ­¦å™¨ä¼¤å®³ç³»æ•°ã€è§¦å‘æºç­‰ï¼‰å…¶æœ¬è´¨æ˜¯**GameplayEffectSpec**çš„å°è£…å®¹å™¨ï¼Œæ”¯æŒåŠ¨æ€é…ç½®ä¼¤å®³å‚æ•°
3. **åº”ç”¨ä¼¤å®³å¥æŸ„** 
    å°†å­˜å‚¨å®Œæ•´ä¼¤å®³æ•°æ®çš„å¥æŸ„**åº”ç”¨è‡³ç›®æ ‡å¯¹è±¡**ï¼ˆApplySpecToTargetï¼‰ï¼›
4. **æ‰§è¡Œè®¡ç®—é˜¶æ®µ**
    é€šè¿‡**GameplayEffectExecutionCalculation**ç±»æ•è·æ‰€æœ‰ç›¸å…³å±æ€§ï¼ŒåŸºäºå…¬å¼ï¼ˆå¦‚æ”»å‡»åŠ›-é˜²å¾¡åŠ›**ç³»æ•°ï¼‰è®¡ç®—æœ€ç»ˆä¼¤å®³å€¼
5. **å±æ€§æ›´æ–°ä¸é€šçŸ¥**
    åœ¨**å±æ€§é›†ï¼ˆAttributeSetï¼‰** ä¸­æ›´æ–°ç”Ÿå‘½å€¼ç­‰å±æ€§ï¼Œè‡ªåŠ¨é€šçŸ¥UIå±‚åˆ·æ–°å±æ€§å˜åŒ–ï¼ˆå¦‚è¡€æ¡UIå®æ—¶å“åº”ï¼‰

![](./Lesson Images/4-11.png)

### åˆ¶ä½œGameplayEffectå¥æŸ„ 

**WarriorHeroGameplayAbilityç±»**

```c++
//WarriorHeroGameplayAbility.h
public:
    UFUNCTION(BlueprintPure, Category = "Warrior|Ability")
    FGameplayEffectSpecHandle MakeHeroDamageEffectSpecHandle(TSubclassOf<UGameplayEffect> EffectClass, float InWeaponBaseDamage,FGameplayTag InCurrentAttackTypeTag,int32 InUsedComboCount);
//WarriorHeroGameplayAbility.cpp
#include "WarriorGameplayTags.h"
#include "AbilitySystem/WarriorAbilitySystemComponent.h"
/**
 * åŠŸèƒ½ï¼šåˆ›å»ºç”¨äºä¼¤å®³è®¡ç®—çš„ GameplayEffectSpec å¥æŸ„
 * 
 * å‚æ•°è¯´æ˜ï¼š
 *   - EffectClass: ä¼¤å®³æ•ˆæœå¯¹åº”çš„ GameplayEffect ç±»ï¼ˆå¦‚ä¼¤å®³è®¡ç®—å…¬å¼çš„è“å›¾ç±»ï¼‰
 *   - InWeaponBaseDamage: æ­¦å™¨åŸºç¡€ä¼¤å®³å€¼ï¼ˆåŠ¨æ€ä¼ é€’ï¼‰
 *   - InCurrentAttackTypeTag: å½“å‰æ”»å‡»ç±»å‹çš„æ ‡ç­¾ï¼ˆå¦‚è½»å‡»ã€é‡å‡»ã€æš´å‡»ï¼‰
 *   - InUsedComboCount: å½“å‰è¿å‡»æ¬¡æ•°ï¼ˆç”¨äºåŠ¨æ€è°ƒæ•´ä¼¤å®³ç³»æ•°ï¼‰
 * 
 * è¿”å›å€¼ï¼šé…ç½®å®Œæˆçš„ GameplayEffectSpec å¥æŸ„ï¼Œç”¨äºåç»­åº”ç”¨ä¼¤å®³æ•ˆæœ
 */
FGameplayEffectSpecHandle UWarriorHeroGameplayAbility::MakeHeroDamageEffectSpecHandle(
    TSubclassOf<UGameplayEffect> EffectClass, float InWeaponBaseDamage, FGameplayTag InCurrentAttackTypeTag, int32 InUsedComboCount)
{
    // é˜²å¾¡æ€§æ£€æŸ¥ï¼šç¡®ä¿ä¼ å…¥çš„EffectClassæœ‰æ•ˆ
    check(EffectClass);

    // 1. åˆ›å»ºæ•ˆæœä¸Šä¸‹æ–‡ï¼ˆContextï¼‰å¹¶è®¾ç½®å…³é”®ä¿¡æ¯
    FGameplayEffectContextHandle ContextHandle = 
        GetWarriorAbilitySystemComponentFromActorInfo()->MakeEffectContext();
    
    ContextHandle.SetAbility(this);         // å…³è”å½“å‰Abilityå®ä¾‹[1,2](@ref)
    ContextHandle.AddSourceObject(GetAvatarActorFromActorInfo()); // è®¾ç½®ä¼¤å®³æºå¯¹è±¡ï¼ˆè§’è‰²æ¨¡å‹ï¼‰
    ContextHandle.AddInstigator(GetAvatarActorFromActorInfo(), GetAvatarActorFromActorInfo()); // è®¾ç½®è§¦å‘è€…ï¼ˆé€šå¸¸ä¸æºå¯¹è±¡ç›¸åŒï¼‰

    // 2. åˆ›å»ºGameplayEffectSpecï¼ˆæ•ˆæœè§„æ ¼ï¼‰[4](@ref)
    FGameplayEffectSpecHandle EffectSpecHandle =
        GetWarriorAbilitySystemComponentFromActorInfo()->MakeOutgoingSpec(
            EffectClass, 
            GetAbilityLevel(), // æ ¹æ®Abilityç­‰çº§è°ƒæ•´æ•ˆæœå¼ºåº¦
            ContextHandle
        );

    // 3. åŠ¨æ€æ³¨å…¥ä¼¤å®³å‚æ•°ï¼ˆSetByCalleræœºåˆ¶ï¼‰
    // å°†æ­¦å™¨åŸºç¡€ä¼¤å®³é€šè¿‡æ ‡ç­¾ `Shared_SetByCaller_BaseDamage` åŠ¨æ€ç»‘å®šåˆ°æ•ˆæœ[4](@ref)
    EffectSpecHandle.Data->SetSetByCallerMagnitude(
        WarriorGameplayTags::Shared_SetByCaller_BaseDamage, 
        InWeaponBaseDamage
    );

    // 4. è‹¥æ”»å‡»ç±»å‹æ ‡ç­¾æœ‰æ•ˆï¼Œæ³¨å…¥è¿å‡»æ¬¡æ•°ä½œä¸ºåŠ¨æ€å‚æ•°
    if (InCurrentAttackTypeTag.IsValid()) {
        EffectSpecHandle.Data->SetSetByCallerMagnitude(
            InCurrentAttackTypeTag, 
            InUsedComboCount // ä¾‹å¦‚ï¼šè¿å‡»æ¬¡æ•°è¶Šé«˜ï¼Œä¼¤å®³å€ç‡è¶Šå¤§
        );
    }

    return EffectSpecHandle; // è¿”å›é…ç½®å®Œæˆçš„å¥æŸ„
}
```

1. GameplayEffectSpec çš„ä½œç”¨  
   â€¢ æ˜¯ GameplayEffect çš„ä¸´æ—¶å®ä¾‹åŒ–é…ç½®ï¼Œå­˜å‚¨è¿è¡Œæ—¶åŠ¨æ€å‚æ•°  

   â€¢ é€šè¿‡ SetSetByCallerMagnitude å®ç°ä¼¤å®³å…¬å¼çš„åŠ¨æ€æ³¨å…¥ï¼ˆå¦‚æ­¦å™¨ä¼¤å®³ã€è¿å‡»å€ç‡ï¼‰

2. SetByCaller åŠ¨æ€å‚æ•°ç³»ç»Ÿ  
   â€¢ æ ‡ç­¾æ˜ å°„æ•°å€¼ï¼šShared_SetByCaller_BaseDamage æ ‡ç­¾å¯¹åº”åŸºç¡€ä¼¤å®³ï¼ŒInCurrentAttackTypeTag å¯¹åº”è¿å‡»æ•°  

   â€¢ å…¬å¼çµæ´»æ€§ï¼šä¼¤å®³å…¬å¼å¯åœ¨ GameplayEffect ä¸­å®šä¹‰ä¸ºï¼š  
     FinalDamage = BaseDamage Ã— (1 + ComboCount Ã— 0.1) 
   
     å…¶ä¸­ BaseDamage å’Œ ComboCount ç”± SetByCaller æä¾›

3. ä¸Šä¸‹æ–‡ï¼ˆContextï¼‰çš„é‡è¦æ€§  
   â€¢ SetAbility() ç¡®ä¿æ•ˆæœå¯å›æº¯åˆ°è§¦å‘çš„æŠ€èƒ½  

   â€¢ AddSourceObject() å’Œ AddInstigator() ç”¨äºç¡®å®šä¼¤å®³æ¥æºï¼Œå½±å“ï¼š  

     â—¦ é˜µè¥åˆ¤æ–­ï¼ˆå‹å†›å…ä¼¤ï¼‰  

     â—¦ å—å‡»åé¦ˆæ–¹å‘è®¡ç®—  

     â—¦ ä¼¤å®³è´£ä»»å½’å±ï¼ˆå¦‚å‡»æ€ç»Ÿè®¡ï¼‰



æ–°å»ºGE_Shared_DealDamageç±»ä½œä¸ºé€ æˆä¼¤å®³ï¼Œç„¶åæ–°å»ºä¸€ä¸ªè®¡ç®—ç±»ï¼Œç”¨æ¥ç¼–ç é€ æˆä¼¤å®³çš„é€»è¾‘ã€‚

![](./Lesson Images/4-12.png)

**WarriorStructTypesç±»**

```c++
#include "ScalableFloat.h"
USTRUCT(BlueprintType)
struct FWarriorHeroWeaponData
{
    GENERATED_BODY()
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    FScalableFloat WeaponBaseDamage;   //æ·»åŠ æ­¦å™¨åŸºç¡€ä¼¤å®³

};
```

**HeroCombatComponentç±»**

```c++
//HeroCombatComponent.h
     // å£°æ˜ï¼šè·å–å½“å‰è£…å¤‡çš„æ­¦å™¨å¯¹è±¡ï¼ˆè“å›¾å¯è°ƒç”¨ï¼‰
     UFUNCTION(BlueprintCallable, Category = "Warrior|Combat")
    AWarriorHeroWeapon* GetHeroCurrentEquippedWeapon() const;
     // å£°æ˜ï¼šæ ¹æ®ç­‰çº§è·å–å½“å‰æ­¦å™¨çš„ä¼¤å®³å€¼ï¼ˆè“å›¾å¯è°ƒç”¨ï¼‰
    UFUNCTION(BlueprintCallable, Category = "Warrior|Combat")
    float GetHeroCurrentEquippedWeaponDamageAtLevel(float InLevel) const;
//HeroCombatComponent.cpp
// å‡½æ•°ï¼šè·å–å½“å‰è§’è‰²è£…å¤‡çš„æ­¦å™¨å¯¹è±¡
AWarriorHeroWeapon* UHeroCombatComponent::GetHeroCurrentEquippedWeapon() const
{
    // 1. è°ƒç”¨çˆ¶ç±»æ–¹æ³•è·å–åŸºç¡€æ­¦å™¨å¯¹è±¡
    AWeapon* BaseWeapon = GetCharacterCurrentEquippedWeapon();
    
    // 2. å®‰å…¨è½¬æ¢ä¸ºè‡ªå®šä¹‰æ­¦å™¨ç±»å‹ `AWarriorHeroWeapon`
    return Cast<AWarriorHeroWeapon>(BaseWeapon);
}

// å‡½æ•°ï¼šæ ¹æ®è¾“å…¥ç­‰çº§è®¡ç®—å½“å‰æ­¦å™¨çš„ä¼¤å®³å€¼
float UHeroCombatComponent::GetHeroCurrentEquippedWeaponDamageAtLevel(float InLevel) const
{
    // 1. è·å–å½“å‰æ­¦å™¨å¯¹è±¡
    AWarriorHeroWeapon* CurrentWeapon = GetHeroCurrentEquippedWeapon();
    if (!CurrentWeapon) 
    {
        UE_LOG(LogCombat, Error, TEXT("No equipped weapon!"));
        return 0.0f; // é˜²å¾¡æ€§æ£€æŸ¥ï¼šæ­¦å™¨æ— æ•ˆæ—¶è¿”å›0
    }

    // 2. ä»æ­¦å™¨æ•°æ®ä¸­è·å–åŸºç¡€ä¼¤å®³æ›²çº¿ï¼ˆ`FRealCurve` æˆ– `UCurveTable`ï¼‰
    const FHeroWeaponData& WeaponData = CurrentWeapon->HeroWeaponData;
    
    // 3. é€šè¿‡ç­‰çº§å‚æ•°æŸ¥è¯¢åŠ¨æ€ä¼¤å®³å€¼
    return WeaponData.WeaponBaseDamage.GetValueAtLevel(InLevel);
}
```

* æ–°å»ºä¸€ä¸ªæ›²çº¿è¡¨æ ¼ï¼Œä½œä¸ºæ­¦å™¨çš„ä¼¤å®³ç­‰çº§

![](./Lesson Images/4-13.png)


**Hero_LightAttackMasterç±»**

```c++
//Hero_LightAttackMaster.h
public:
    UPROPERTY(EditDefaultsOnly, Category = "GameplayEffect")
    FGameplayTag InCurrentAttackTypeTag;
    UPROPERTY(EditDefaultsOnly, Category = "GameplayEffect")
    TSubclassOf<UGameplayEffect> EffectClass;
    int UsedComboCount;
protected:
    void HandleApplyDamage(FGameplayEventData Payload);
//Hero_LightAttackMaster.cpp

/**
 * åŠŸèƒ½ï¼šå¤„ç†è½»æ”»å‡»æŠ€èƒ½çš„ä¼¤å®³åº”ç”¨é€»è¾‘
 * è§¦å‘æ—¶æœºï¼šæ¥æ”¶åˆ°æˆ˜æ–—ç»„ä»¶å‘é€çš„ä¼¤å®³äº‹ä»¶ï¼ˆå¦‚æ­¦å™¨å‘½ä¸­ç›®æ ‡ï¼‰
 * 
 * @param Payload åŒ…å«äº‹ä»¶æ•°æ®çš„ç»“æ„ä½“ï¼ˆå¦‚ç›®æ ‡Actorã€å‘½ä¸­ä½ç½®ç­‰ï¼‰
 */
void UHero_LightAttackMaster::HandleApplyDamage(FGameplayEventData Payload)
{
    // 1. è·å–æ­¦å™¨åŸºç¡€ä¼¤å®³ï¼ˆåŠ¨æ€è®¡ç®—ï¼‰
    //   - é€šè¿‡è§’è‰²æˆ˜æ–—ç»„ä»¶è·å–å½“å‰è£…å¤‡æ­¦å™¨åœ¨ *å½“å‰æŠ€èƒ½ç­‰çº§* ä¸‹çš„ä¼¤å®³å€¼
    float InWeaponBaseDamage = GetHeroCombatComponentFromActorInfo()->GetHeroCurrentEquippedWeaponDamageAtLevel(GetAbilityLevel());
    
    // 2. åˆ›å»ºä¼¤å®³æ•ˆæœè§„æ ¼å¥æŸ„ï¼ˆGameplayEffectSpecï¼‰
    //   - EffectClass: é¢„é…ç½®çš„ä¼¤å®³æ•ˆæœè“å›¾ï¼ˆå¦‚æš´å‡»/ç©¿é€ç­‰ï¼‰
    //   - InWeaponBaseDamage: åŠ¨æ€è®¡ç®—çš„æ­¦å™¨åŸºç¡€ä¼¤å®³
    //   - InCurrentAttackTypeTag: æ”»å‡»ç±»å‹æ ‡ç­¾ï¼ˆå¦‚"Attack.Light"ï¼‰
    //   - UsedComboCount: å½“å‰è¿å‡»æ¬¡æ•°ï¼ˆç”¨äºåŠ¨æ€è°ƒæ•´ä¼¤å®³å€ç‡ï¼‰
    FGameplayEffectSpecHandle InSpecHandle = 
        MakeHeroDamageEffectSpecHandle(EffectClass, InWeaponBaseDamage, InCurrentAttackTypeTag, UsedComboCount);
    
    // 3. æ³¨ï¼šæ­¤å¤„åº”æ·»åŠ ä¼¤å®³åº”ç”¨é€»è¾‘ï¼ˆæœªå®Œæ•´å±•ç¤ºï¼‰
    //   é€šå¸¸éœ€è°ƒç”¨ï¼šApplyGameplayEffectSpecToTarget(InSpecHandle, Payload.TargetActor);
}
```

### åº”ç”¨å¥æŸ„åˆ°ç›®æ ‡

```c++
//WarriorGameplayAbility.h
   FActiveGameplayEffectHandle NativeApplyEffectSpecHandleToTarget(AActor* TargetActor, const FGameplayEffectSpecHandle& InSpecHandle);
    UFUNCTION(BlueprintCallable, Category = "Warrior|Ability", meta = (DisplayName = "Apply Gameplay Effect Spec Handle To Target Actor", ExpandEnumAsExecs = "OutSuccessType"))
    FActiveGameplayEffectHandle BP_ApplyEffectSpecHandleToTarget(AActor* TargetActor, const FGameplayEffectSpecHandle& InSpecHandle,EWarriorSuccessType& OutSuccessType);
//WarriorGameplayAbility.cpp

/**
 * åŠŸèƒ½ï¼šå°†æ•ˆæœè§„æ ¼ï¼ˆGameplayEffectSpecï¼‰åº”ç”¨åˆ°ç›®æ ‡Actorï¼ˆåŸç”ŸC++å®ç°ï¼‰
 * 
 * å‚æ•°è¯´æ˜ï¼š
 *   - TargetActor: ç›®æ ‡Actorï¼ˆéœ€åŒ…å«AbilitySystemComponentï¼‰
 *   - InSpecHandle: é¢„é…ç½®çš„GameplayEffectSpecå¥æŸ„ï¼ˆåŒ…å«ä¼¤å®³å…¬å¼ã€æ ‡ç­¾ç­‰æ•°æ®ï¼‰
 * 
 * è¿”å›å€¼ï¼šåº”ç”¨åç”Ÿæˆçš„æ´»è·ƒæ•ˆæœå¥æŸ„ï¼ˆFActiveGameplayEffectHandleï¼‰ï¼Œç”¨äºåç»­è¿½è¸ªæˆ–ç§»é™¤æ•ˆæœ
 * ç½‘ç»œåŒæ­¥ï¼šæ­¤å‡½æ•°åœ¨æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯å‡å¯è°ƒç”¨ï¼Œä½†å®é™…æ•ˆæœåº”ç”¨éœ€æœåŠ¡ç«¯æƒå¨éªŒè¯[2,4](@ref)
 */
FActiveGameplayEffectHandle UWarriorGameplayAbility::NativeApplyEffectSpecHandleToTarget(
    AActor* TargetActor, const FGameplayEffectSpecHandle& InSpecHandle)
{
    // 1. è·å–ç›®æ ‡Actorçš„AbilitySystemComponentï¼ˆASCï¼‰
    UAbilitySystemComponent* TargetASC = 
        UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);
    
    // é˜²å¾¡æ€§æ£€æŸ¥ï¼šç¡®ä¿ç›®æ ‡ASCå’Œæ•ˆæœè§„æ ¼æœ‰æ•ˆ
    check(TargetASC && InSpecHandle.IsValid()); // ä»»ä¸€æ— æ•ˆæ—¶è§¦å‘æ–­è¨€å´©æºƒ

    // 2. é€šè¿‡è‡ªèº«ASCå°†æ•ˆæœåº”ç”¨åˆ°ç›®æ ‡ASC
    return GetAbilitySystemComponentFromActorInfo()->ApplyGameplayEffectSpecToTarget(
        *InSpecHandle.Data,  // è§£å¼•ç”¨è·å–GameplayEffectSpecå®ä¾‹
        TargetASC            // ç›®æ ‡ç»„ä»¶
    );
}

//----------------------------------------------------------------//

/**
 * åŠŸèƒ½ï¼šè“å›¾å¯è°ƒç”¨çš„æ•ˆæœåº”ç”¨å‡½æ•°ï¼ˆæ‰©å±•æ‰§è¡Œåˆ†æ”¯é€»è¾‘ï¼‰
 * 
 * å‚æ•°è¯´æ˜ï¼š
 *   - TargetActor: ç›®æ ‡Actor
 *   - InSpecHandle: æ•ˆæœè§„æ ¼å¥æŸ„
 *   - OutSuccessType: è¾“å‡ºæšä¸¾ï¼ˆé€šè¿‡ExpandEnumAsExecsç”Ÿæˆè“å›¾åˆ†æ”¯å¼•è„šï¼‰
 * 
 * è¿”å›å€¼ï¼šåŒåŸç”Ÿå‡½æ•°ï¼Œä½†é¢å¤–æä¾›æ‰§è¡ŒçŠ¶æ€æ ‡è¯†
 * è®¾è®¡æ„å›¾ï¼šä¸ºè“å›¾æä¾›å¯è§†åŒ–æˆåŠŸ/å¤±è´¥åˆ†æ”¯[1](@ref)
 */
FActiveGameplayEffectHandle UWarriorGameplayAbility::BP_ApplyEffectSpecHandleToTarget(
    AActor* TargetActor, const FGameplayEffectSpecHandle& InSpecHandle, 
    EWarriorSuccessType& OutSuccessType)
{
    // è°ƒç”¨åŸç”Ÿåº”ç”¨å‡½æ•°
    FActiveGameplayEffectHandle ActiveHandle = 
        NativeApplyEffectSpecHandleToTarget(TargetActor, InSpecHandle);
    
    // åˆ¤æ–­åº”ç”¨æ˜¯å¦æˆåŠŸï¼ˆåº•å±‚éªŒè¯ASCæœ‰æ•ˆæ€§åŠç½‘ç»œæƒé™ï¼‰
    OutSuccessType = ActiveHandle.WasSuccessfullyApplied() ? 
        EWarriorSuccessType::Successful : 
        EWarriorSuccessType::Failed;
    
    return ActiveHandle;
}
```

**Hero_LightAttackMasterç±»**

```c++
//Hero_LightAttackMaster.cpp
void UHero_LightAttackMaster::HandleApplyDamage(FGameplayEventData Payload)
{
    // 1. è·å–æ­¦å™¨åŸºç¡€ä¼¤å®³ï¼ˆåŠ¨æ€è®¡ç®—ï¼‰
    //   - é€šè¿‡è§’è‰²æˆ˜æ–—ç»„ä»¶è·å–å½“å‰è£…å¤‡æ­¦å™¨åœ¨ *å½“å‰æŠ€èƒ½ç­‰çº§* ä¸‹çš„ä¼¤å®³å€¼
    float InWeaponBaseDamage = GetHeroCombatComponentFromActorInfo()->GetHeroCurrentEquippedWeaponDamageAtLevel(GetAbilityLevel());
    
    // 2. åˆ›å»ºä¼¤å®³æ•ˆæœè§„æ ¼å¥æŸ„ï¼ˆGameplayEffectSpecï¼‰
    //   - EffectClass: é¢„é…ç½®çš„ä¼¤å®³æ•ˆæœè“å›¾ï¼ˆå¦‚æš´å‡»/ç©¿é€ç­‰ï¼‰
    //   - InWeaponBaseDamage: åŠ¨æ€è®¡ç®—çš„æ­¦å™¨åŸºç¡€ä¼¤å®³
    //   - InCurrentAttackTypeTag: æ”»å‡»ç±»å‹æ ‡ç­¾ï¼ˆå¦‚"Attack.Light"ï¼‰
    //   - UsedComboCount: å½“å‰è¿å‡»æ¬¡æ•°ï¼ˆç”¨äºåŠ¨æ€è°ƒæ•´ä¼¤å®³å€ç‡ï¼‰
    FGameplayEffectSpecHandle InSpecHandle = 
        MakeHeroDamageEffectSpecHandle(EffectClass, InWeaponBaseDamage, InCurrentAttackTypeTag, UsedComboCount);
    
    // 3. è·å–ç›®æ ‡Actorï¼ˆéœ€åŒ…å«AbilitySystemComponentï¼‰
    //   - ä»äº‹ä»¶æ•°æ®ä¸­æå–ç›®æ ‡ï¼Œé™æ€è½¬æ¢é¿å…è¿è¡Œæ—¶å¼€é”€
    //   - é˜²å¾¡æ€§æ£€æŸ¥ï¼šå®é™…é¡¹ç›®ä¸­éœ€éªŒè¯Payload.Targetæœ‰æ•ˆæ€§
    AActor* LocalTargetActor = static_cast<AActor*>(Payload.Target);
    
    // 4. å°†ä¼¤å®³æ•ˆæœåº”ç”¨åˆ°ç›®æ ‡
    //   - NativeApplyEffectSpecHandleToTargetå†…éƒ¨å¤„ç†ASCè·å–å’Œç½‘ç»œåŒæ­¥[5](@ref)
    //   - è¿”å›FActiveGameplayEffectHandleç”¨äºåç»­è¿½è¸ªï¼ˆå¦‚ç§»é™¤æ•ˆæœï¼‰
    FActiveGameplayEffectHandle ActiveGameplayEffectHandle = 
        NativeApplyEffectSpecHandleToTarget(LocalTargetActor, InSpecHandle);
}
```

### **GameplayEffectæ‰§è¡Œè®¡ç®—**â€Œ

**GEExecCalc_DamageTakenç±»**

```c++
//GameplayEffectExecutionCalculation.h

#pragma once
#include "CoreMinimal.h"
#include "GameplayEffectExecutionCalculation.h" // ç»§æ‰¿GASçš„æ‰§è¡Œè®¡ç®—åŸºç±»
#include "GEExecCalc_DamageTaken.generated.h"   // Unreal åå°„ç”Ÿæˆå¤´æ–‡ä»¶

/**
 * åŠŸèƒ½ï¼šè‡ªå®šä¹‰ä¼¤å®³æ‰¿å—æ‰§è¡Œè®¡ç®—å™¨
 * æ ¸å¿ƒä½œç”¨ï¼šå®æ—¶è®¡ç®—è§’è‰²å—åˆ°çš„æœ€ç»ˆä¼¤å®³å€¼ï¼Œæ”¯æŒåŠ¨æ€ä¿®æ­£ï¼ˆå¦‚é˜²å¾¡å‡ä¼¤ã€æŠ—æ€§ç­‰ï¼‰
 * è®¾è®¡åŸç†ï¼š
 *   - ç»§æ‰¿è‡ªUGameplayEffectExecutionCalculationï¼Œé‡å†™Execute_Implementation
 *   - é€šè¿‡å±æ€§æ•è·ï¼ˆAttribute Captureï¼‰è¯»å–æ”»å‡»æ–¹å’Œå—å‡»æ–¹çš„å±æ€§å€¼
 *   - åŸºäºæ¸¸æˆé€»è¾‘ï¼ˆå¦‚æŠ¤ç”²å…¬å¼ã€å…ƒç´ æŠ—æ€§ï¼‰åŠ¨æ€ä¿®æ­£ä¼¤å®³å€¼
 * ç½‘ç»œåŒæ­¥ï¼šè‡ªåŠ¨å¤„ç†å®¢æˆ·ç«¯é¢„æµ‹ä¸æœåŠ¡ç«¯æƒå¨éªŒè¯
 */
UCLASS()
class MYWARRIOR_API UGEExecCalc_DamageTaken : public UGameplayEffectExecutionCalculation
{
    GENERATED_BODY()
public:
    // æ„é€ å‡½æ•°ï¼šå£°æ˜éœ€è¦æ•è·çš„å±æ€§ï¼ˆå¦‚æ”»å‡»åŠ›ã€æŠ¤ç”²å€¼ã€æŠ—æ€§ç­‰ï¼‰
    UGEExecCalc_DamageTaken();

    /**
     * æ ¸å¿ƒè®¡ç®—é€»è¾‘ï¼šæ‰§è¡Œä¼¤å®³è®¡ç®—
     * 
     * @param ExecutionParams  æä¾›è®¡ç®—æ‰€éœ€ä¸Šä¸‹æ–‡æ•°æ®ï¼ˆæ”»å‡»æ–¹/å—å‡»æ–¹ASCã€æ ‡ç­¾ã€å±æ€§å€¼ç­‰ï¼‰
     * @param OutExecutionOutput è¾“å‡ºè®¡ç®—ç»“æœï¼ˆæœ€ç»ˆä¿®æ”¹çš„å±æ€§å€¼ï¼‰
     */
    virtual void Execute_Implementation(
        const FGameplayEffectCustomExecutionParameters& ExecutionParams,
        FGameplayEffectCustomExecutionOutput& OutExecutionOutput
    ) const override;
};
//GameplayEffectExecutionCalculation.cpp
#pragma once
#include "AbilitySystem/GEExecCalc/GEExecCalc_DamageTaken.h"
#include "AbilitySystem/WarriorAttributeSet.h"
#include "WarriorGameplayTags.h"
#include "WarriorDebugHelper.h"

// å®šä¹‰æ•è·å±æ€§çš„ç»“æ„ä½“ï¼ˆå°è£…æ”»å‡»åŠ›ã€é˜²å¾¡åŠ›ã€æ‰¿å—ä¼¤å®³å±æ€§ï¼‰
struct FWarriorDamageCapture
{
    // å£°æ˜å±æ€§æ•è·å®ï¼ˆè‡ªåŠ¨ç”Ÿæˆå±æ€§å®šä¹‰ï¼‰
    DECLARE_ATTRIBUTE_CAPTUREDEF(AttackPower) // æ”»å‡»åŠ›ï¼ˆæºï¼‰
    DECLARE_ATTRIBUTE_CAPTUREDEF(DefensePower) // é˜²å¾¡åŠ›ï¼ˆç›®æ ‡ï¼‰
    DECLARE_ATTRIBUTE_CAPTUREDEF(DamageTaken)  // æ‰¿å—ä¼¤å®³ï¼ˆç›®æ ‡ï¼‰

    // æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–å±æ€§æ•è·å®šä¹‰
    FWarriorDamageCapture()
    {
        // å‚æ•°ï¼šå±æ€§é›†ç±»ã€å±æ€§åã€æ•è·æºï¼ˆSource/Targetï¼‰ã€æ˜¯å¦å¿«ç…§
        DEFINE_ATTRIBUTE_CAPTUREDEF(UWarriorAttributeSet, AttackPower, Source, false)   // ä»æ”»å‡»æ–¹æ•è·
        DEFINE_ATTRIBUTE_CAPTUREDEF(UWarriorAttributeSet, DefensePower, Target, false) // ä»å—å‡»æ–¹æ•è·
        DEFINE_ATTRIBUTE_CAPTUREDEF(UWarriorAttributeSet, DamageTaken, Target, false)   // è¾“å‡ºåˆ°å—å‡»æ–¹
    }
};

// å•ä¾‹æ¨¡å¼è·å–å±æ€§æ•è·ç»“æ„ä½“ï¼ˆé¿å…é‡å¤åˆå§‹åŒ–ï¼‰
static const FWarriorDamageCapture& GetWarriorDamageCapture()
{
    static FWarriorDamageCapture WarriorDamageCapture; // é™æ€å±€éƒ¨å˜é‡ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
    return WarriorDamageCapture;
}

// æ„é€ å‡½æ•°ï¼šæ³¨å†Œéœ€è¦æ•è·çš„å±æ€§
UGEExecCalc_DamageTaken::UGEExecCalc_DamageTaken()
{
    // æ·»åŠ å±æ€§åˆ°æ•è·åˆ—è¡¨ï¼ˆé€šè¿‡å•ä¾‹è·å–å®šä¹‰ï¼‰
    RelevantAttributesToCapture.Add(GetWarriorDamageCapture().AttackPowerDef);   // æ”»å‡»åŠ›
    RelevantAttributesToCapture.Add(GetWarriorDamageCapture().DefensePowerDef);   // é˜²å¾¡åŠ›
    RelevantAttributesToCapture.Add(GetWarriorDamageCapture().DamageTakenDef);     // æ‰¿å—ä¼¤å®³
}

// æ ¸å¿ƒæ‰§è¡Œå‡½æ•°ï¼šè®¡ç®—æœ€ç»ˆä¼¤å®³
void UGEExecCalc_DamageTaken::Execute_Implementation(
    const FGameplayEffectCustomExecutionParameters& ExecutionParams, 
    FGameplayEffectCustomExecutionOutput& OutExecutionOutput
) const 
{
    // 1. è·å–å½“å‰GameplayEffectè§„æ ¼ï¼ˆåŒ…å«ä¼¤å®³å‚æ•°ï¼‰
    const FGameplayEffectSpec& EffectSpec = ExecutionParams.GetOwningSpec();

    // 2. è®¾ç½®è¯„ä¼°å‚æ•°ï¼ˆèšåˆæº/ç›®æ ‡æ ‡ç­¾ï¼‰
    FAggregatorEvaluateParameters EvaluateParameters;
    EvaluateParameters.SourceTags = EffectSpec.CapturedSourceTags.GetAggregatedTags(); // æ”»å‡»æ–¹æ ‡ç­¾
    EvaluateParameters.TargetTags = EffectSpec.CapturedTargetTags.GetAggregatedTags(); // å—å‡»æ–¹æ ‡ç­¾

    // 3. æ•è·æºå±æ€§ï¼šæ”»å‡»åŠ›
    float SourceAttackPower = 0.f;
    ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(
        GetWarriorDamageCapture().AttackPowerDef, EvaluateParameters, SourceAttackPower
    );

    // 4. ä»SetByCalleråŠ¨æ€å‚æ•°è·å–åŸºç¡€å€¼å’Œè¿å‡»æ•°
    float BaseDamage = 0.f;
    int32 UsedLightAttackComboCount = 0;
    int32 UsedHeavyAttackComboCount = 0;
    
    // éå†SetByCalleré”®å€¼å¯¹
    for (const TPair<FGameplayTag, float>& TagMagnitude : EffectSpec.SetByCallerTagMagnitudes) 
    {
        // åŒ¹é…åŸºç¡€ä¼¤å®³æ ‡ç­¾
        if (TagMagnitude.Key.MatchesTagExact(WarriorGameplayTags::Shared_SetByCaller_BaseDamage)) {
            BaseDamage = TagMagnitude.Value;
        }
        // åŒ¹é…è½»æ”»å‡»è¿å‡»æ•°æ ‡ç­¾
        if (TagMagnitude.Key.MatchesTagExact(WarriorGameplayTags::Player_SetByCaller_AttackType_Light)) {
            UsedLightAttackComboCount = TagMagnitude.Value;
        }
        // åŒ¹é…é‡æ”»å‡»è¿å‡»æ•°æ ‡ç­¾
        if (TagMagnitude.Key.MatchesTagExact(WarriorGameplayTags::Player_SetByCaller_AttackType_Heavy)) {
            UsedHeavyAttackComboCount = TagMagnitude.Value;
        }
    }

    // 5. æ•è·ç›®æ ‡å±æ€§ï¼šé˜²å¾¡åŠ›
    float TargetDefensePower = 0.f;
    ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(
        GetWarriorDamageCapture().DefensePowerDef, EvaluateParameters, TargetDefensePower
    );

    // 6. è¿å‡»ä¼¤å®³å€ç‡è®¡ç®—
    // è½»æ”»å‡»ï¼šæ¯è¿å‡»+5%ä¼¤å®³ï¼ˆç¬¬1å‡»100%ï¼Œç¬¬2å‡»105%ï¼Œç¬¬3å‡»110%...ï¼‰
    if (UsedLightAttackComboCount != 0) {
        const float DamageIncreasePercentLight = (UsedLightAttackComboCount - 1) * 0.05f + 1.f;
        BaseDamage *= DamageIncreasePercentLight;
    }
    // é‡æ”»å‡»ï¼šæ¯è¿å‡»+15%ä¼¤å®³ï¼ˆç¬¬1å‡»115%ï¼Œç¬¬2å‡»130%...ï¼‰
    if (UsedHeavyAttackComboCount != 0) {
        const float DamageIncreasePercentHeavy = UsedHeavyAttackComboCount * 0.15f + 1.f;
        BaseDamage *= DamageIncreasePercentHeavy;
    }

    // 7. æœ€ç»ˆä¼¤å®³å…¬å¼ï¼šåŸºç¡€ä¼¤å®³ Ã— æ”»å‡»åŠ› Ã· é˜²å¾¡åŠ›
    const float FinalDamageDone = BaseDamage * SourceAttackPower / TargetDefensePower;

    // 8. è¾“å‡ºç»“æœåˆ°DamageTakenå±æ€§ï¼ˆè¦†ç›–å†™å…¥ï¼‰
    if (FinalDamageDone > 0.f) {
        OutExecutionOutput.AddOutputModifier(
            FGameplayModifierEvaluatedData(
                GetWarriorDamageCapture().DamageTakenProperty, // ç›®æ ‡å±æ€§
                EGameplayModOp::Override,                     // æ“ä½œç±»å‹ï¼ˆè¦†ç›–ï¼‰
                FinalDamageDone                               // è®¡ç®—å€¼
            )
        );
    }
}
```

### å±æ€§é›†

* é‡å†™UAttributeSetç±»ä¸­çš„PostGameplayEffectExecuteå‡½æ•°

```c++
 //WarriorAttributeSet.h
virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;
 //WarriorAttributeSet.cpp
#include "GameplayEffectExtension.h"
#include "WarriorFunctionLibrary.h"
#include "WarriorGameplayTags.h"
// åœ¨ GameplayEffect æˆåŠŸä¿®æ”¹å±æ€§åè§¦å‘çš„å›è°ƒå‡½æ•°
void UWarriorAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
{

    // 4. å¤„ç†ç”Ÿå‘½å€¼ï¼ˆCurrentHealthï¼‰å±æ€§å˜åŒ–
    if (Data.EvaluatedData.Attribute == GetCurrentHealthAttribute()) 
    {
        // 4.1 çº¦æŸç”Ÿå‘½å€¼èŒƒå›´ [0, MaxHealth]
        const float NewCurrentHealth = FMath::Clamp(GetCurrentHealth(), 0.f, GetMaxHealth());
        SetCurrentHealth(NewCurrentHealth); // æ›´æ–°å±æ€§å€¼

    }

    // 5. å¤„ç†æ€’æ°”å€¼ï¼ˆCurrentRageï¼‰å±æ€§å˜åŒ–
    if (Data.EvaluatedData.Attribute == GetCurrentRageAttribute()) 
    {
        // 5.1 çº¦æŸæ€’æ°”å€¼èŒƒå›´ [0, MaxRage]
        const float NewCurrentRage = FMath::Clamp(GetCurrentRage(), 0.f, GetMaxRage());
        SetCurrentRage(NewCurrentRage);

    }

    // 6. å¤„ç†æ‰¿å—ä¼¤å®³ï¼ˆDamageTakenï¼‰å±æ€§å˜åŒ–
    if (Data.EvaluatedData.Attribute == GetDamageTakenAttribute()) 
    {
        // 6.1 è®°å½•æ—§ç”Ÿå‘½å€¼å¹¶è·å–ä¼¤å®³å€¼
        const float OldHealth = GetCurrentHealth();
        const float DamageDone = GetDamageTaken(); 

        // 6.2 è®¡ç®—æ–°ç”Ÿå‘½å€¼ï¼ˆæ‰£å‡ä¼¤å®³å¹¶çº¦æŸèŒƒå›´ï¼‰
        const float NewCurrentHealth = FMath::Clamp(OldHealth - DamageDone, 0.f, GetMaxHealth());
        SetCurrentHealth(NewCurrentHealth);

        // 6.3 è°ƒè¯•è¾“å‡ºä¼¤å®³è¯¦æƒ…ï¼ˆæœåŠ¡ç«¯å¯è§ï¼‰
        const FString DebugString = FString::Printf(
            TEXT("Old Health: %f, Damage Done: %f, NewCurrentHealth: %f"), 
            OldHealth, DamageDone, NewCurrentHealth
        );
        Debug::Print(DebugString, FColor::Green);
    }
}
```

## **å‡»ä¸­ååº”ï¼ˆHit Reactï¼‰**

* ä¸ºæ•Œäººåˆ›å»ºå‡»ä¸­ååº”èƒ½åŠ›

æ•Œäººèƒ½åŠ›åˆ›å»ºæµç¨‹

![](./Lesson Images/4-14.png)

é¦–å…ˆæ·»åŠ **Shared_Ability_HitReactï¼ŒShared_Event_HitReactï¼ŒEnemy_Ability_Melee**å’Œ**Enemy_Ability_Ranged**æ ‡ç­¾

åˆ›å»º**Enemy_HitReact_Base**ï¼Œå…¶å­ç±»è¿™æ ·è®¾ç½®ã€‚

é€šè¿‡è¿™ä¸¤é¡¹é…ç½®ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œæ•Œäººçš„å—å‡»ååº”èƒ½åŠ›å¯ **ä¸­æ–­å¹¶å°é”** å…¶è‡ªèº«çš„æ”»å‡»èƒ½åŠ›ã€‚ç¡®ä¿å—å‡»ååº”æœŸé—´æ•Œäººæ— æ³•ç»§ç»­æ”»å‡»ï¼Œæå‡æˆ˜æ–—æµç•…æ€§ã€‚

![](./Lesson Images/4-15.png)

æ¥ä¸‹æ¥é…ç½® **å®ä¾‹åŒ–ç­–ç•¥ï¼ˆInstancing Policyï¼‰**ã€‚ç”±äºå—å‡»ååº”èƒ½åŠ›ä¼šè¢«é¢‘ç¹æ¿€æ´»â€¦â€¦

å°†å…¶ä» **Per Executionï¼ˆæ¯æ¬¡æ‰§è¡Œï¼‰** æ”¹ä¸º **Per Actorï¼ˆæ¯ä¸ªè§’è‰²ï¼‰**ã€‚

* **Per Actor**ï¼šæ¯ä¸ªè§’è‰²ä»…ä¿ç•™ä¸€ä¸ªèƒ½åŠ›å®ä¾‹ï¼Œåç»­æ¿€æ´»å¤ç”¨è¯¥å®ä¾‹
* **é€‚ç”¨åœºæ™¯**ï¼šå—å‡»ã€è·³è·ƒç­‰é«˜é¢‘èƒ½åŠ›ï¼Œå‡å°‘å†…å­˜ç¢ç‰‡å’Œåˆå§‹åŒ–è€—æ—¶ã€‚

å‘ä¸‹æ»šåŠ¨è‡³ **Ability Triggersï¼ˆèƒ½åŠ›è§¦å‘å™¨ï¼‰**ï¼Œç‚¹å‡»æ·»åŠ æŒ‰é’®æ–°å¢å…ƒç´ ã€‚åœ¨è§¦å‘å™¨æ ‡ç­¾çš„ä¸‹æ‹‰èœå•ä¸­ï¼Œé€‰æ‹©åˆšåˆ›å»ºçš„ **Shared.Event.HitReact** äº‹ä»¶æ ‡ç­¾ã€‚

![](./Lesson Images/4-16.png)

**Enemy_HitReact_Baseç±»**

```c++
//Enemy_HitReact_Base.h
#pragma once
#include "CoreMinimal.h"
#include "AbilitySystem/Abilities/WarriorEnemyGameplayAbility.h" // ç»§æ‰¿è‡ªå®šä¹‰æ•Œäººèƒ½åŠ›åŸºç±»
#include "Enemy_HitReact_Base.generated.h"

class UAnimMontage;
class UAbilityTask_PlayMontageAndWait;

UCLASS()
class MYWARRIOR_API UEnemy_HitReact_Base : public UWarriorEnemyGameplayAbility {
    GENERATED_BODY()
public:
    // é…ç½®å‚æ•°ï¼šæ˜¯å¦æ’­æ”¾å—å‡»åŠ¨ç”»
    UPROPERTY(EditDefaultsOnly, Category = "HitReact")
    bool HasHitReactMontageToPlay = true;

    // é…ç½®å‚æ•°ï¼šæ˜¯å¦è½¬å‘æ”»å‡»è€…
    UPROPERTY(EditDefaultsOnly, Category = "HitReact")
    bool FaceAttackter = true;

    // é…ç½®å‚æ•°ï¼šå¯éšæœºæ’­æ”¾çš„å—å‡»åŠ¨ç”»è’™å¤ªå¥‡åˆ—è¡¨
    UPROPERTY(EditDefaultsOnly, Category = "HitReact")
    TArray<UAnimMontage*> MontagesToPlay;

protected:
    // åŠ¨ç”»æ’­æ”¾å®Œæˆå›è°ƒå‡½æ•°
    UFUNCTION()
    void OnMontage();

    // é‡å†™èƒ½åŠ›æ¿€æ´»é€»è¾‘
    virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, 
        const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo, 
        const FGameplayEventData* TriggerEventData) override;

    // é‡å†™èƒ½åŠ›ç»“æŸé€»è¾‘
    virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, 
        const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo, 
        bool bReplicateEndAbility, bool bWasCancelled) override;

private:
    // åŠ¨ç”»æ’­æ”¾ä»»åŠ¡å®ä¾‹
    UAbilityTask_PlayMontageAndWait* PlayMontageTask;

    // éšæœºé€‰æ‹©è’™å¤ªå¥‡åŠ¨ç”»
    UAnimMontage* ShuffleMontage();
};
//Enemy_HitReact_Base.cpp
#include "AbilitySystem/Abilities/Shared/Enemy_HitReact_Base.h"
#include "Abilities/Tasks/AbilityTask_PlayMontageAndWait.h" // åŠ¨ç”»ä»»åŠ¡ç±»
#include "Kismet/KismetSystemLibrary.h" // å»¶è¿Ÿå‡½æ•°
#include "Kismet/KismetMathLibrary.h"   // æ•°å­¦è®¡ç®—ï¼ˆè½¬å‘é€»è¾‘ï¼‰
#include "Engine/LatentActionManager.h" // å»¶è¿Ÿå›è°ƒç®¡ç†
#include "Characters/WarriorEnemyCharacter.h" // æ•Œäººè§’è‰²ç±»

// èƒ½åŠ›æ¿€æ´»æ ¸å¿ƒé€»è¾‘
void UEnemy_HitReact_Base::ActivateAbility(...) {
    // Lambda 1: è½¬å‘æ”»å‡»è€…
    auto Task1 = [this, EventDataCopy = *TriggerEventData] {
        if (FaceAttackter) {
            FVector Start = GetEnemyCharacterFromActorInfo()->GetActorLocation();
            FVector Target = EventDataCopy.Instigator->GetActorLocation(); // æ”»å‡»è€…ä½ç½®
            FRotator NewRotation = UKismetMathLibrary::FindLookAtRotation(Start, Target);
            GetEnemyCharacterFromActorInfo()->SetActorRotation(NewRotation); // ç«‹å³è½¬å‘[5](@ref)
        }
    };

    // Lambda 2: æ’­æ”¾å—å‡»åŠ¨ç”»æˆ–å»¶è¿Ÿç»“æŸ
    auto Task2 = [this] {
        if (HasHitReactMontageToPlay) {
            UAnimMontage* MontageToPlay = ShuffleMontage(); // éšæœºé€‰æ‹©åŠ¨ç”»
            PlayMontageTask = UAbilityTask_PlayMontageAndWait::CreatePlayMontageAndWaitProxy(...);
            // ç»‘å®šåŠ¨ç”»äº‹ä»¶å›è°ƒ
            PlayMontageTask->OnCompleted.AddDynamic(this, &ThisClass::OnMontage);
            PlayMontageTask->OnBlendOut.AddDynamic(this, &ThisClass::OnMontage);
            PlayMontageTask->ReadyForActivation(); // å¯åŠ¨ä»»åŠ¡
            // æ¿€æ´»å—å‡»æè´¨ç‰¹æ•ˆï¼ˆå¦‚è§’è‰²é«˜äº®ï¼‰
            GetOwningComponentFromActorInfo()->SetScalarParameterValueOnMaterials("HitFxSwitch", 1.f);
        } 
        else { // æ— åŠ¨ç”»æ—¶å»¶è¿Ÿç»“æŸ
            UKismetSystemLibrary::Delay(GetWorld(), 0.2f, FLatentActionInfo(...));
            GetOwningComponentFromActorInfo()->SetScalarParameterValueOnMaterials("HitFxSwitch", 1.f);
        }
    };

    // é¡ºåºæ‰§è¡Œä»»åŠ¡ï¼ˆç¡®ä¿è½¬å‘åœ¨åŠ¨ç”»å‰å®Œæˆï¼‰
    Task1(); 
    Task2();
}

// åŠ¨ç”»æ’­æ”¾å®Œæˆå›è°ƒ
void UEnemy_HitReact_Base::OnMontage() {
    if (PlayMontageTask) PlayMontageTask->EndTask(); // æ¸…ç†ä»»åŠ¡
    EndAbility(...); // ç»“æŸèƒ½åŠ›
}

// éšæœºé€‰æ‹©è’™å¤ªå¥‡åŠ¨ç”»
UAnimMontage* UEnemy_HitReact_Base::ShuffleMontage() {
    int32 Index = FMath::RandRange(0, MontagesToPlay.Num() - 1);
    return MontagesToPlay[Index]; // é¿å…é‡å¤å—å‡»åŠ¨ç”»
}

// èƒ½åŠ›ç»“æŸé€»è¾‘
void UEnemy_HitReact_Base::EndAbility(...) {
    Super::EndAbility(...); // è°ƒç”¨çˆ¶ç±»
    // å…³é—­å—å‡»æè´¨ç‰¹æ•ˆ
    GetOwningComponentFromActorInfo()->SetScalarParameterValueOnMaterials("HitFxSwitch", 0.f);
}
```

åˆ›å»ºGA_Enemy_HitReact_Baseå­ç±»GA_Guardian_HitReactæ·»åŠ åŠ¨ç”»è’™å¤ªå¥‡ã€‚

 

ä¹‹åä¸ºäº†è§¦å‘å‡»ä¸­ååº”èƒ½åŠ›åœ¨Hero_LightAttackMasterç±»

**Hero_LightAttackMasterç±»**

```c++
//Hero_LightAttackMaster.cpp
// å¤„ç†è½»æ”»å‡»ä¼¤å®³åº”ç”¨çš„æ ¸å¿ƒå‡½æ•°
void UHero_LightAttackMaster::HandleApplyDamage(FGameplayEventData Payload)
{
    // 1. è·å–å½“å‰æ­¦å™¨åŸºç¡€ä¼¤å®³å€¼ï¼ˆåŸºäºèƒ½åŠ›ç­‰çº§ï¼‰
    float InWeaponBaseDamage = GetHeroCombatComponentFromActorInfo()
        ->GetHeroCurrentEquippedWeaponDamageAtLevel(GetAbilityLevel());

    // 2. åˆ›å»ºä¼¤å®³æ•ˆæœè§„æ ¼ï¼ˆGameplayEffectSpecï¼‰
    FGameplayEffectSpecHandle InSpecHandle = 
        MakeHeroDamageEffectSpecHandle( // è‡ªå®šä¹‰å°è£…å‡½æ•°
            EffectClass,                // ä¼¤å®³æ•ˆæœç±»ï¼ˆå¦‚æ‰£è¡€ã€é™„åŠ å¼‚å¸¸çŠ¶æ€ï¼‰
            InWeaponBaseDamage,         // åŸºç¡€ä¼¤å®³å€¼
            InCurrentAttackTypeTag,     // å½“å‰æ”»å‡»ç±»å‹æ ‡ç­¾ï¼ˆå¦‚Light_Attackï¼‰
            UsedComboCount              // å½“å‰è¿å‡»æ•°ï¼ˆç”¨äºåŠ¨æ€ä¼¤å®³å€ç‡ï¼‰
        );

    // 3. è½¬æ¢ç›®æ ‡å¯¹è±¡ä¸ºActoræŒ‡é’ˆ
    AActor* LocalTargetActor = static_cast<AActor*>(Payload.Target);


    // 5. å°†ä¼¤å®³æ•ˆæœåº”ç”¨åˆ°ç›®æ ‡Actor
    FActiveGameplayEffectHandle ActiveGameplayEffectHandle = 
        NativeApplyEffectSpecHandleToTarget(LocalTargetActor, InSpecHandle);

    // 6. è‹¥æ•ˆæœåº”ç”¨æˆåŠŸï¼Œå‘é€GameplayEventé€šçŸ¥ç›®æ ‡
    if (ActiveGameplayEffectHandle.WasSuccessfullyApplied()) 
    {
        UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(
            LocalTargetActor, 
            ToActorEventTag, // äº‹ä»¶æ ‡ç­¾ï¼ˆå¦‚Event.HitReactï¼‰
            Payload          // ä¼ é€’åŸå§‹äº‹ä»¶æ•°æ®ï¼ˆå«ä¼¤å®³æ¥æºã€æ•°å€¼ç­‰ï¼‰
        );
    }
}
```

é‡å‡»åŒç†

## å‡»ä¸­/å£°éŸ³ç‰¹æ•ˆï¼ˆHit/SoundFxï¼‰

### æè´¨å‡»ä¸­ç‰¹æ•ˆ(Material Hit FX)

* ä½¿ç”¨å‡†å¤‡å¥½çš„æè´¨å‡½æ•°è¿›è¡Œæ·»åŠ åˆ°æ€ªç‰©çš„æè´¨ä¸Š

![](./Lesson Images/4-17.png)

**Enemy_HitReact_Baseç±»**çœ‹ä¸Šæ–¹

### å£°éŸ³ç‰¹æ•ˆ(Sound FX)

**1. å‡»ä¸­ååº”å£°æ•ˆ**

åœ¨åŠ¨ç”»è’™å¤ªå¥‡ä¸­æ·»åŠ å£°éŸ³

**2. è¿‘æˆ˜å‡»ä¸­å£°æ•ˆ**

ç”±äºä¸æ˜¯æ¯æ¬¡æ’­æ”¾è’™å¤ªå¥‡å°±è¦æ’­æ”¾å£°éŸ³ï¼Œè¿™é‡Œé€‰æ‹©ç”¨GameplayCuesã€‚

**Hero_AxeHit_GCNotify_Baseç±»**

```c++
//Hero_AxeHit_GCNotify_Base.h
#pragma once
#include "CoreMinimal.h"
#include "GameplayCueNotify_Static.h"  // é™æ€GameplayCueåŸºç±»ï¼ˆéåŠ¨æ€ç”Ÿæˆï¼‰
#include "Hero_AxeHit_GCNotify_Base.generated.h"

class USoundBase;

/**
 * åŠŸèƒ½ï¼šæ–§å¤´å‘½ä¸­ç‰¹æ•ˆçš„é™æ€GameplayCueé€šçŸ¥å™¨
 * è®¾è®¡ç‰¹ç‚¹ï¼š
 *   - ç»§æ‰¿è‡ªUGameplayCueNotify_Staticï¼Œé€‚ç”¨äºæ— éœ€åŠ¨æ€ç”Ÿæˆçš„ç®€å•ç‰¹æ•ˆ
 *   - é€šè¿‡è¦†å†™OnExecute_Implementationå®ç°åŸºç¡€éŸ³æ•ˆæ’­æ”¾é€»è¾‘
 *   - å¯æ‰©å±•æ€§ï¼šæ”¯æŒåç»­æ·»åŠ ç²’å­ã€åŠ¨ç”»ç­‰ç‰¹æ•ˆ
 */
UCLASS()
class MYWARRIOR_API UHero_AxeHit_GCNotify_Base : public UGameplayCueNotify_Static
{
    GENERATED_BODY()
public:
    // é…ç½®æ–§å¤´å‘½ä¸­éŸ³æ•ˆèµ„æºï¼ˆé€šè¿‡ç¼–è¾‘å™¨è®¾ç½®ï¼‰
    UPROPERTY(EditDefaultsOnly, Category = "Sound")
    USoundBase* Sound;

    /**
     * å¤„ç†GameplayCueäº‹ä»¶å…¥å£
     * @param MyTarget   ç›®æ ‡Actorï¼ˆè¢«æ–§å¤´å‡»ä¸­çš„å¯¹è±¡ï¼‰
     * @param EventType  Cueäº‹ä»¶ç±»å‹ï¼ˆå¦‚OnActiveã€WhileActiveã€Executedã€Removedï¼‰
     * @param Parameters åŒ…å«ä¼¤å®³æ•°å€¼ã€å‘½ä¸­ä½ç½®ç­‰ä¸Šä¸‹æ–‡æ•°æ®
     */
    virtual void HandleGameplayCue(
        AActor* MyTarget, 
        EGameplayCueEvent::Type EventType, 
        const FGameplayCueParameters& Parameters
    ) override;

    /**
     * æ‰§è¡Œæ ¸å¿ƒé€»è¾‘ï¼ˆå®é™…æ’­æ”¾éŸ³æ•ˆï¼‰
     * @param Target    ç›®æ ‡Actor
     * @param Parameters ä¸Šä¸‹æ–‡å‚æ•°
     * @return æ˜¯å¦æ‰§è¡ŒæˆåŠŸ
     */
    virtual bool OnExecute_Implementation(
        AActor* Target, 
        const FGameplayCueParameters& Parameters
    ) const override;
};
//Hero_AxeHit_GCNotify_Base.cpp
#include "AbilitySystem/GameplayCues/Hero_AxeHit_GCNotify_Base.h"
#include "Kismet/GameplayStatics.h"  // éŸ³æ•ˆæ’­æ”¾API
#include "GameplayEffectTypes.h"     // FGameplayCueParameterså®šä¹‰

void UHero_AxeHit_GCNotify_Base::HandleGameplayCue(...)
{
    Super::HandleGameplayCue(MyTarget, EventType, Parameters); // ä¿ç•™çˆ¶ç±»åŸºç¡€å¤„ç†
    // å¯åœ¨æ­¤å¤„æ‰©å±•å…¶ä»–äº‹ä»¶é€»è¾‘ï¼ˆå¦‚WhileActiveæŒç»­æ’­æ”¾å£°éŸ³ï¼‰
}

bool UHero_AxeHit_GCNotify_Base::OnExecute_Implementation(...) const
{
    // 1. è·å–ç›®æ ‡Actorä½ç½®ä½œä¸ºéŸ³æ•ˆæ’­æ”¾ä½ç½®
    FVector Location = Target->GetActorLocation();
    
    // 2. åœ¨ç›®æ ‡ä½ç½®æ’­æ”¾é…ç½®çš„éŸ³æ•ˆ
    UGameplayStatics::PlaySoundAtLocation(
        GetWorld(),   // è·å–å½“å‰Worldä¸Šä¸‹æ–‡
        Sound,        // é…ç½®çš„éŸ³æ•ˆèµ„æº
        Location      // å‘½ä¸­ä½ç½®
    );
    
    // 3. è°ƒç”¨çˆ¶ç±»å®ç°ï¼ˆé€šå¸¸è¿”å›trueè¡¨ç¤ºæˆåŠŸï¼‰
    return Super::OnExecute_Implementation(Target, Parameters);
}
```

**Hero_LightAttackMasterç±»**

```c++
//Hero_LightAttackMaster.cpp
// å¤„ç†è½»æ”»å‡»ä¼¤å®³åº”ç”¨çš„æ ¸å¿ƒå‡½æ•°
void UHero_LightAttackMaster::HandleApplyDamage(FGameplayEventData Payload)
{
    // 1. è·å–å½“å‰æ­¦å™¨åŸºç¡€ä¼¤å®³å€¼ï¼ˆåŸºäºèƒ½åŠ›ç­‰çº§ï¼‰
    float InWeaponBaseDamage = GetHeroCombatComponentFromActorInfo()
        ->GetHeroCurrentEquippedWeaponDamageAtLevel(GetAbilityLevel());

    // 2. åˆ›å»ºä¼¤å®³æ•ˆæœè§„æ ¼ï¼ˆGameplayEffectSpecï¼‰
    FGameplayEffectSpecHandle InSpecHandle = 
        MakeHeroDamageEffectSpecHandle( // è‡ªå®šä¹‰å°è£…å‡½æ•°
            EffectClass,                // ä¼¤å®³æ•ˆæœç±»ï¼ˆå¦‚æ‰£è¡€ã€é™„åŠ å¼‚å¸¸çŠ¶æ€ï¼‰
            InWeaponBaseDamage,         // åŸºç¡€ä¼¤å®³å€¼
            InCurrentAttackTypeTag,     // å½“å‰æ”»å‡»ç±»å‹æ ‡ç­¾ï¼ˆå¦‚Light_Attackï¼‰
            UsedComboCount              // å½“å‰è¿å‡»æ•°ï¼ˆç”¨äºåŠ¨æ€ä¼¤å®³å€ç‡ï¼‰
        );

    // 3. è½¬æ¢ç›®æ ‡å¯¹è±¡ä¸ºActoræŒ‡é’ˆ
    AActor* LocalTargetActor = static_cast<AActor*>(Payload.Target);

    // 4. è§¦å‘æ­¦å™¨å‘½ä¸­éŸ³æ•ˆçš„GameplayCue
    GetWarriorAbilitySystemComponentFromActorInfo()
        ->ExecuteGameplayCue(WeaponHitSoundGameplayCueTag); // æ’­æ”¾éŸ³æ•ˆ/ç²’å­ç‰¹æ•ˆ

    // 5. å°†ä¼¤å®³æ•ˆæœåº”ç”¨åˆ°ç›®æ ‡Actor
    FActiveGameplayEffectHandle ActiveGameplayEffectHandle = 
        NativeApplyEffectSpecHandleToTarget(LocalTargetActor, InSpecHandle);

    // 6. è‹¥æ•ˆæœåº”ç”¨æˆåŠŸï¼Œå‘é€GameplayEventé€šçŸ¥ç›®æ ‡
    if (ActiveGameplayEffectHandle.WasSuccessfullyApplied()) 
    {
        UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(
            LocalTargetActor, 
            ToActorEventTag, // äº‹ä»¶æ ‡ç­¾ï¼ˆå¦‚Event.HitReactï¼‰
            Payload          // ä¼ é€’åŸå§‹äº‹ä»¶æ•°æ®ï¼ˆå«ä¼¤å®³æ¥æºã€æ•°å€¼ç­‰ï¼‰
        );
    }
}
```

* ç„¶ååœ¨DefaultGame.iniæ–‡ä»¶ä¸­æ·»åŠ è·¯å¾„

```
[/Script/GameplayAbilities.AbilitySystemGlobals]
GameplayCueNotifyPaths="/Game/GameplayCues"
```

* **åŠŸèƒ½**ï¼šæŒ‡å®šGameplayCueèµ„æºçš„æœç´¢è·¯å¾„ã€‚
* **ä¼˜åŒ–æ„ä¹‰**ï¼š
  - é»˜è®¤æƒ…å†µä¸‹ï¼ŒGASä¼šæ‰«ææ•´ä¸ª `/Game`ç›®å½•æŸ¥æ‰¾GameplayCueèµ„æºï¼Œ**å¤§å‹é¡¹ç›®å¯èƒ½å¼•å‘æ€§èƒ½é—®é¢˜**ï¼ˆå¦‚åŠ è½½å¡é¡¿ã€å†…å­˜å ç”¨é«˜ï¼‰ã€‚
  - é€šè¿‡é™åˆ¶è·¯å¾„ä¸º `/Game/GameplayCues`ï¼Œå¼•æ“ä»…æ‰«æè¯¥ç›®å½•ï¼Œ**æ˜¾è‘—æå‡èµ„æºåŠ è½½æ•ˆç‡å’Œè¿è¡Œæ—¶æ€§èƒ½**ã€‚

### å‡»ä¸­åœé¡¿(Hit Pause)

æ·»åŠ **Player_Ability_HitPause**å’Œ**Player_Event_HitPause**æ ‡ç­¾ã€‚

**HeroCombatComponentç±»**

```c++
// HeroCombatComponent.cpp

// å‡½æ•°åŠŸèƒ½ï¼šå¤„ç†æ­¦å™¨å‘½ä¸­ç›®æ ‡Actoræ—¶çš„é€»è¾‘ï¼Œé¿å…é‡å¤è§¦å‘ä¼¤å®³
//HeroCombatComponent.cpp
#include "WarriorGameplayTags.h"         // å¼•ç”¨è‡ªå®šä¹‰çš„æ¸¸æˆæ ‡ç­¾åº“ï¼ˆç”¨äºæ ‡è¯†äº‹ä»¶ç±»å‹ï¼‰
#include "AbilitySystemBlueprintLibrary.h" // æä¾›GASè“å›¾åº“åŠŸèƒ½

void UHeroCombatComponent::OnHitTargetActor(AActor* HitActor) 
{
    // 3. æ„é€ æ¸¸æˆäº‹ä»¶æ•°æ®ï¼ˆä¼ é€’ä¼¤å®³è®¡ç®—æ‰€éœ€ä¸Šä¸‹æ–‡ï¼‰
    FGameplayEventData Data;
    Data.Instigator = GetOwningPawn();  // ä¼¤å®³å‘èµ·è€…ï¼ˆç©å®¶è§’è‰²ï¼‰
    Data.Target = HitActor;              // ä¼¤å®³æ‰¿å—è€…ï¼ˆè¢«å‡»ä¸­çš„Actorï¼‰

    // 4. å‘é€å‘½ä¸­åœé¡¿
        UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(
        GetOwningPawn(),               // äº‹ä»¶å‘é€ç»™ç©å®¶è§’è‰²çš„AbilitySystemComponent
        WarriorGameplayTags::Player_Event_HitPause,   // æ ‡ç­¾ï¼šæ ‡è¯†"å‘½ä¸­åœé¡¿"äº‹ä»¶ç±»å‹
        FGameplayEventData()           // ç©º
        );
}
```

**GA_Hero_Hit_Pause_Cç±»**

```lua
local Screen = require("Widgets.Screen")
--
-- DESCRIPTION
--
-- @COMPANY **
-- @AUTHOR **
-- @DATE ${date} ${time}
--
require("LuaPanda").start("127.0.0.1",8818);

---@type GA_Hero_Hit_Pause_C
local M = UnLua.Class()

function M:ExecuteHitPause()
    local world = self:GetWorld()
    -- å¯åŠ¨åç¨‹å¤„ç†å»¶è¿Ÿé€»è¾‘
--[[     coroutine.wrap(function()
        -- è®°å½•å½“å‰æ—¶é—´è†¨èƒ€çŠ¶æ€
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 0.1)
        Screen.Print("æ—¶é—´è†¨èƒ€å·²æ¿€æ´»ï¼Œå½“å‰è†¨èƒ€ç³»æ•°: 0.1")

        -- å…³é”®ï¼ä½¿ç”¨UnrealåŸç”Ÿå»¶è¿Ÿå‡½æ•°ï¼ˆLatent Functionï¼‰
        UE.UKismetSystemLibrary.Delay(world, self.HitPauseDuration)
        
        -- æ¢å¤æ—¶é—´å¹¶ç»“æŸæŠ€èƒ½
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 1.0)
        Screen.Print("æ—¶é—´è†¨èƒ€å·²æ¢å¤ï¼Œå½“å‰è†¨èƒ€ç³»æ•°: 1.0")
        self:K2_EndAbility()
    end)() ]]
    coroutine.resume(coroutine.create(function()
        -- è®°å½•å½“å‰æ—¶é—´è†¨èƒ€çŠ¶æ€
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 0.1)
        --Screen.Print("æ—¶é—´è†¨èƒ€å·²æ¿€æ´»ï¼Œå½“å‰è†¨èƒ€ç³»æ•°: 0.1")

        -- å…³é”®ï¼ä½¿ç”¨UnrealåŸç”Ÿå»¶è¿Ÿå‡½æ•°ï¼ˆLatent Functionï¼‰
        UE.UKismetSystemLibrary.Delay(world, self.HitPauseDuration)

        -- æ¢å¤æ—¶é—´å¹¶ç»“æŸæŠ€èƒ½
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 1.0)
        --Screen.Print("æ—¶é—´è†¨èƒ€å·²æ¢å¤ï¼Œå½“å‰è†¨èƒ€ç³»æ•°: 1.0")
        self:K2_EndAbility()
    end))
end

function M:K2_ActivateAbilityFromEvent(EventData)
    self:ExecuteHitPause()
end

return M

```

## ç›¸æœºæŠ–åŠ¨ï¼ˆCamera Shakeï¼‰

**GA_Hero_Hit_Pause_Cç±»**

```lua
local Screen = require("Widgets.Screen")
--
-- DESCRIPTION
--
-- @COMPANY **
-- @AUTHOR **
-- @DATE ${date} ${time}
--
require("LuaPanda").start("127.0.0.1",8818);

---@type GA_Hero_Hit_Pause_C
local M = UnLua.Class()

function M:camerashake()
    -- è·å–å½“å‰è§’è‰²çš„æ§åˆ¶å™¨
    local HeroController = self:GetHeroControllerFromActorInfo()
    if HeroController then
        -- è·å–å½“å‰è§’è‰²çš„æ‘„åƒæœºç»„ä»¶
         HeroController:ClientStartCameraShake(self.CameraShakeClass, 1.0)
    end
end
function M:ExecuteHitPause()
    local world = self:GetWorld()
    -- å¯åŠ¨åç¨‹å¤„ç†å»¶è¿Ÿé€»è¾‘
--[[     coroutine.wrap(function()
        -- è®°å½•å½“å‰æ—¶é—´è†¨èƒ€çŠ¶æ€
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 0.1)
        Screen.Print("æ—¶é—´è†¨èƒ€å·²æ¿€æ´»ï¼Œå½“å‰è†¨èƒ€ç³»æ•°: 0.1")

        -- å…³é”®ï¼ä½¿ç”¨UnrealåŸç”Ÿå»¶è¿Ÿå‡½æ•°ï¼ˆLatent Functionï¼‰
        UE.UKismetSystemLibrary.Delay(world, self.HitPauseDuration)
        
        -- æ¢å¤æ—¶é—´å¹¶ç»“æŸæŠ€èƒ½
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 1.0)
        Screen.Print("æ—¶é—´è†¨èƒ€å·²æ¢å¤ï¼Œå½“å‰è†¨èƒ€ç³»æ•°: 1.0")
        self:K2_EndAbility()
    end)() ]]
    coroutine.resume(coroutine.create(function()
        -- è®°å½•å½“å‰æ—¶é—´è†¨èƒ€çŠ¶æ€
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 0.1)
        --Screen.Print("æ—¶é—´è†¨èƒ€å·²æ¿€æ´»ï¼Œå½“å‰è†¨èƒ€ç³»æ•°: 0.1")

        -- å…³é”®ï¼ä½¿ç”¨UnrealåŸç”Ÿå»¶è¿Ÿå‡½æ•°ï¼ˆLatent Functionï¼‰
        UE.UKismetSystemLibrary.Delay(world, self.HitPauseDuration)

        -- æ¢å¤æ—¶é—´å¹¶ç»“æŸæŠ€èƒ½
        UE.UGameplayStatics.SetGlobalTimeDilation(world, 1.0)
        --Screen.Print("æ—¶é—´è†¨èƒ€å·²æ¢å¤ï¼Œå½“å‰è†¨èƒ€ç³»æ•°: 1.0")
        -- æ‰§è¡Œæ‘„åƒæœºéœ‡åŠ¨
        self:camerashake()
        -- ç»“æŸæŠ€èƒ½
        self:K2_EndAbility()
    end))
end

function M:K2_ActivateAbilityFromEvent(EventData)
    self:ExecuteHitPause()
end

return M

```

## æ­»äº¡æ•ˆæœï¼ˆDeathï¼‰

æœ¬èŠ‚å°†å®ç°æ•Œäººç”Ÿå‘½å€¼å½’é›¶æ—¶çš„æ­»äº¡é€»è¾‘ï¼Œæµç¨‹å¦‚ä¸‹ï¼š

1. **å±æ€§é›†ï¼ˆAttribute Setï¼‰æ£€æµ‹**ï¼šä»å±æ€§é›†è·å–å½“å‰ç”Ÿå‘½å€¼ã€‚
2. **ç”Ÿå‘½å€¼å½’é›¶åˆ¤å®š**ï¼šå½“è¯¥å±æ€§é›†çš„æŒæœ‰è€…ï¼ˆActorï¼‰ç”Ÿå‘½å€¼é™è‡³é›¶æ—¶â€¦â€¦â€¦â€¦ä¸ºå…¶æ·»åŠ ä¸€ä¸ª **æ­»äº¡æ ‡ç­¾ï¼ˆGameplayTagï¼‰**ã€‚
3. **æ­»äº¡èƒ½åŠ›ï¼ˆDeath Abilityï¼‰**ï¼šé€šè¿‡å¦ä¸€é¡¹æ¸¸æˆèƒ½åŠ›æ’­æ”¾æ­»äº¡è’™å¤ªå¥‡åŠ¨ç”»ã€‚è¯¥èƒ½åŠ›åœ¨ **æ­»äº¡æ ‡ç­¾æ·»åŠ è‡³æŒæœ‰è€…æ—¶è‡ªåŠ¨è§¦å‘**ã€‚
4. **æ­»äº¡æ•ˆæœ**ï¼šé€šè¿‡æè´¨ä¸ç²’å­ç‰¹æ•ˆå¢å¼ºè¡¨ç°åŠ›ã€‚

![](./Lesson Images/4-18.png)

æ·»åŠ **Shared_Ability_Death**å’Œ**Shared_Status_Dead**æ ‡ç­¾

**WarriorAttributeSetç±»**

```c++
//WarriorAttributeSet.cpp
void UWarriorAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
{
    // è§’è‰²æ­»äº¡å¤„ç†é€»è¾‘
    if (GetCurrentHealth() == 0.f)
    {
        // é€šè¿‡å·¥å…·å‡½æ•°ä¸ºè§’è‰²æ·»åŠ æ­»äº¡æ ‡ç­¾ï¼ˆè‹¥å°šæœªæ·»åŠ ï¼‰
        UWarriorFunctionLibrary::AddGameplayTagToActorIfNone(
            Data.Target.GetAvatarActor(),      // ç›®æ ‡è§’è‰²ï¼ˆAvatarActorï¼‰
            WarriorGameplayTags::Shared_Status_Dead // æ­»äº¡çŠ¶æ€æ ‡ç­¾ï¼ˆå¦‚"Status.Dead"ï¼‰
        );
    }
}
```

åˆ›å»º**Enemy_Death_Base**ç±»å…¶å­ç±»**GA_Enemy_Death_Base**è¿™æ ·é…ç½®

![](./Lesson Images/4-19.png)

![](./Lesson Images/4-20.png)

æ­»äº¡æ•ˆæœå¾—GCå’Œ**Hero_AxeHit_GCNotify_Base**é€»è¾‘ä¸€æ ·ç›´æ¥ä»è¿™é‡Œç»§æ‰¿**GC_Guardian_DeathSound**

**Enemy_Death_Baseç±»**

```c++
// Enemy_Death_Base.h
#pragma once
#include "CoreMinimal.h"
#include "AbilitySystem/Abilities/WarriorEnemyGameplayAbility.h"
#include "Enemy_Death_Base.generated.h"

class UAbilityTask_PlayMontageAndWait;
class UNiagaraSystem;

/**
 * åŠŸèƒ½ï¼šæ•Œäººæ­»äº¡èƒ½åŠ›çš„åŸºç±»
 * è®¾è®¡ç‰¹ç‚¹ï¼š
 *   - ç»§æ‰¿è‡ª UWarriorEnemyGameplayAbilityï¼Œå¤ç”¨è‡ªå®šä¹‰æ•Œäººèƒ½åŠ›é€»è¾‘
 *   - æ”¯æŒéšæœºæ’­æ”¾å¤šä¸ªæ­»äº¡åŠ¨ç”»è’™å¤ªå¥‡ï¼ˆMontageï¼‰
 *   - é›†æˆ GameplayCue è§¦å‘æ­»äº¡ç‰¹æ•ˆ/éŸ³æ•ˆ
 *   - å°¸ä½“æº¶è§£ç‰¹æ•ˆï¼ˆNiagara ç³»ç»Ÿï¼‰
 */
UCLASS()
class MYWARRIOR_API UEnemy_Death_Base : public UWarriorEnemyGameplayAbility {
    GENERATED_BODY()
public:
    // é…ç½®å¤šä¸ªæ­»äº¡åŠ¨ç”»è’™å¤ªå¥‡ï¼ˆæ”¯æŒéšæœºé€‰æ‹©ï¼‰
    UPROPERTY(EditDefaultsOnly, Category = "Death")
    TArray<UAnimMontage*> MontagesArray;

    // æ­»äº¡æ—¶è§¦å‘çš„ GameplayCue æ ‡ç­¾ï¼ˆå¦‚æ’­æ”¾ç²’å­ç‰¹æ•ˆã€éŸ³æ•ˆï¼‰
    UPROPERTY(EditDefaultsOnly, Category = "GameplayCue")
    FGameplayTag DeathGameplayCueTag;


protected:
    // è’™å¤ªå¥‡ä»»åŠ¡å®Œæˆæ—¶çš„å›è°ƒå‡½æ•°
    UFUNCTION()
    void OnMontage();

    // æ ¸å¿ƒï¼šæ¿€æ´»æ­»äº¡èƒ½åŠ›ï¼ˆæ’­æ”¾åŠ¨ç”»ã€è§¦å‘ç‰¹æ•ˆï¼‰
    virtual void ActivateAbility(
        const FGameplayAbilitySpecHandle Handle,
        const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo,
        const FGameplayEventData* TriggerEventData
    ) override;

    // ç»“æŸèƒ½åŠ›æ—¶å¤„ç†å°¸ä½“æº¶è§£
    virtual void EndAbility(
        const FGameplayAbilitySpecHandle Handle,
        const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo,
        bool bReplicateEndAbility,
        bool bWasCancelled
    ) override;

    // ä»æ•°ç»„ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªè’™å¤ªå¥‡åŠ¨ç”»
    UAnimMontage* MontagesArrayRandom(TArray<UAnimMontage*> MontagesArrayToRandom);

private:
    // å¼‚æ­¥ä»»åŠ¡ï¼šæ’­æ”¾è’™å¤ªå¥‡åŠ¨ç”»
    UAbilityTask_PlayMontageAndWait* PlayMontageTask;
};
// Enemy_Death_Base.cpp
#include "AbilitySystem/Abilities/Shared/Enemy_Death_Base.h"
#include "Abilities/Tasks/AbilityTask_PlayMontageAndWait.h"
#include "AbilitySystem/WarriorAbilitySystemComponent.h"
#include "Characters/WarriorEnemyCharacter.h"
#include "Kismet/KismetMathLibrary.h"
#include "NiagaraFunctionLibrary.h"

// 1. æ¿€æ´»æ­»äº¡èƒ½åŠ›
void UEnemy_Death_Base::ActivateAbility(...) {
    // éšæœºé€‰æ‹©æ­»äº¡åŠ¨ç”»
    UAnimMontage* MontageToPlay = MontagesArrayRandom(MontagesArray);
    
    // åˆ›å»ºå¼‚æ­¥ä»»åŠ¡ï¼šæ’­æ”¾è’™å¤ªå¥‡åŠ¨ç”»
    PlayMontageTask = UAbilityTask_PlayMontageAndWait::CreatePlayMontageAndWaitProxy(
        this, 
        FName("PlayMontageTask"), 
        MontageToPlay
    );

    // ç»‘å®šåŠ¨ç”»ç»“æŸå›è°ƒï¼ˆå®Œæˆ/æ··åˆç»“æŸ/ä¸­æ–­/å–æ¶ˆå‡è§¦å‘ï¼‰
    PlayMontageTask->OnCompleted.AddDynamic(this, &ThisClass::OnMontage);
    PlayMontageTask->OnBlendOut.AddDynamic(this, &ThisClass::OnMontage);
    PlayMontageTask->OnInterrupted.AddDynamic(this, &ThisClass::OnMontage);
    PlayMontageTask->OnCancelled.AddDynamic(this, &ThisClass::OnMontage);
    
    // å¯åŠ¨å¼‚æ­¥ä»»åŠ¡
    PlayMontageTask->ReadyForActivation();

    // 2. è§¦å‘æ­»äº¡GameplayCueï¼ˆå¦‚ç‰¹æ•ˆã€éŸ³æ•ˆï¼‰[7](@ref)
    GetWarriorAbilitySystemComponentFromActorInfo()->ExecuteGameplayCue(DeathGameplayCueTag);
}


// 4. éšæœºé€‰æ‹©è’™å¤ªå¥‡åŠ¨ç”»
UAnimMontage* UEnemy_Death_Base::MontagesArrayRandom(TArray<UAnimMontage*> MontagesArrayToRandom) {
    int32 RandomIndex = FMath::RandRange(0, MontagesArrayToRandom.Num() - 1);
    return MontagesArrayToRandom[RandomIndex];
}

// 5. è’™å¤ªå¥‡åŠ¨ç”»ç»“æŸå›è°ƒ
void UEnemy_Death_Base::OnMontage() {
    // å®‰å…¨ç»“æŸå¼‚æ­¥ä»»åŠ¡
    if (PlayMontageTask) PlayMontageTask->EndTask();
    
    // ç»“æŸèƒ½åŠ›ï¼ˆè§¦å‘å°¸ä½“æº¶è§£ï¼‰
    EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);
}
```

å½“å‰çš„é—®é¢˜æ˜¯ï¼šæ­»äº¡èƒ½åŠ›ç»“æŸåï¼Œå®ˆå«è€…ï¼ˆGuardianï¼‰ä¼š**ç¬é—´åˆ‡å›é—²ç½®çŠ¶æ€**ã€‚

è¿™æ˜¯æˆ‘ä»¬éœ€è¦ä¿®å¤çš„é—®é¢˜ï¼Œè§£å†³æ–¹æ¡ˆå¦‚ä¸‹ï¼š

**æ­»äº¡èƒ½åŠ›ç»“æŸæ—¶**ï¼Œé€šè¿‡èƒ½åŠ›ç±»ä¸­çš„å‡½æ•°é€šçŸ¥ `BP_EnemyCharacter_Base`ï¼ˆæ•Œäººè§’è‰²åŸºç±»ï¼‰å¤„ç†åç»­é€»è¾‘ã€‚

**æ­»äº¡åéœ€å¤„ç†çš„ä»»åŠ¡**ï¼š

1. **æš‚åœè§’è‰²åŠ¨ç”»**
2. **ç¦ç”¨ç¢°æ’ä½“**
3. **æ’­æ”¾æè´¨ä¸ç²’å­ç‰¹æ•ˆ**
4. **é”€æ¯Actor**

æ ¸å¿ƒé—®é¢˜ï¼š**å¦‚ä½•ä»æ¸¸æˆèƒ½åŠ›ï¼ˆGameplay Abilityï¼‰ä¸­é€šçŸ¥ `BP_EnemyCharacter_Base`ï¼Ÿ**

**æ–¹æ¡ˆä¸€ï¼šç›´æ¥ç±»å‹è½¬æ¢ï¼ˆCastingï¼‰**

åœ¨èƒ½åŠ›ç±»ä¸­ç¡¬å¼•ç”¨ `BP_EnemyCharacter_Base`ï¼Œç›´æ¥è°ƒç”¨å…¶å‡½æ•°ã€‚

**æ–¹æ¡ˆäºŒï¼šè“å›¾æ¥å£ï¼ˆBlueprint Interfaceï¼‰**

æ›´è§£è€¦çš„æ–¹æ¡ˆï¼Œéœ€ä¸‰æ­¥ï¼š

1. åˆ›å»ºæ¥å£èµ„äº§å¹¶å£°æ˜å‡½æ•°
2. åœ¨æ•Œäººè§’è‰²ä¸­å®ç°æ¥å£
3. èƒ½åŠ›ç±»ä¸­æ£€æŸ¥æ¥å£å¹¶è°ƒç”¨å‡½æ•°

**è“å›¾æ¥å£ vs ç›´æ¥ç±»å‹è½¬æ¢**

|     **æ–¹æ¡ˆ**     |     **é€‚ç”¨åœºæ™¯**     |      **ä¼˜åŠ¿**      |       **é£é™©**       |
| :--------------: | :------------------: | :----------------: | :------------------: |
|   **è“å›¾æ¥å£**   |  å¤šç±»å‹æ•Œäººå…±äº«é€»è¾‘  |    è§£è€¦ã€æ˜“æ‰©å±•    |  éœ€é¢å¤–åˆ›å»ºæ¥å£èµ„äº§  |
| **ç›´æ¥ç±»å‹è½¬æ¢** | å•ä¸€æ•Œäººç±»å‹ä¸“ç”¨é€»è¾‘ | å®ç°ç®€å•ã€æ€§èƒ½æ›´é«˜ | ä»£ç è€¦åˆåº¦é«˜ã€éš¾å¤ç”¨ |

**Enemy_Death_Interfaceç±»**

```c++
// Enemy_Death_Interface.h
#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "Enemy_Death_Interface.generated.h" // è‡ªåŠ¨ç”Ÿæˆåå°„ä»£ç 

// å£°æ˜ä¸€ä¸ªæ— éœ€è‡ªå®šä¹‰çš„è½»é‡æ¥å£ï¼ˆUINTERFACEï¼‰
// - MinimalAPI: ä»…å¯¼å‡ºå¿…è¦çš„ç±»å‹ä¿¡æ¯ï¼Œå‡å°‘ç¼–è¯‘ä¾èµ–[6](@ref)
UINTERFACE(MinimalAPI)
class UEnemy_Death_Interface : public UInterface {
    GENERATED_BODY() // UEå®ï¼Œç”Ÿæˆåå°„ä»£ç å’ŒåŸºç¡€å‡½æ•°
};

// å‰ç½®å£°æ˜é¿å…å¤´æ–‡ä»¶ä¾èµ–
class UNiagaraSystem;

// å®é™…æ¥å£ç±»ï¼ˆIEnemy_Death_Interfaceï¼‰
// - ç»§æ‰¿è‡ªUObjectï¼Œæ”¯æŒUEåå°„ç³»ç»Ÿ
class MYWARRIOR_API IEnemy_Death_Interface {
    GENERATED_BODY()

public:
    // çº¯è™šå‡½æ•°ï¼šæ•Œäººæ­»äº¡æ—¶è§¦å‘çš„æ¥å£
    // - ä½œç”¨ï¼šè§£è€¦æ­»äº¡èƒ½åŠ›ä¸è§’è‰²é€»è¾‘ï¼Œæ”¯æŒå¤šæ€è°ƒç”¨[1](@ref)
    // - å‚æ•° `Dissolve_Niagara_System`ï¼šè½¯æŒ‡é’ˆæŒ‡å‘Niagaraæº¶è§£ç‰¹æ•ˆèµ„æº
    virtual void OnEnemyDeath() = 0;
};
```

**Enemy_Death_Baseç±»**

```c++
//Enemy_Death_Base.h   
// å°¸ä½“æº¶è§£ç‰¹æ•ˆçš„ Niagara ç³»ç»Ÿèµ„æºï¼ˆè½¯å¼•ç”¨é¿å…å¼ºåˆ¶åŠ è½½ï¼‰
    UPROPERTY(EditDefaultsOnly, Category = "Death")
    TSoftObjectPtr<UNiagaraSystem> Dissolve_Niagara_System;
//Enemy_Death_Base.cpp
// 3. ç»“æŸèƒ½åŠ›æ—¶å¤„ç†å°¸ä½“æº¶è§£
void UEnemy_Death_Base::EndAbility(...) {
    Super::EndAbility(...);
    
    // è°ƒç”¨æ•Œäººè§’è‰²çš„æ­»äº¡é€»è¾‘ï¼ˆå¦‚å¯ç”¨ç‰©ç†æ¨¡æ‹Ÿã€æº¶è§£ç‰¹æ•ˆï¼‰
    GetEnemyCharacterFromActorInfo()->OnEnemyDeath();
}
```

**WarriorEnemyCharacterç±»**

```c++
//WarriorEnemyCharacter.h
#include "Interfaces/Enemy_Death_Interface.h"
#include "Components/TimelineComponent.h"

class MYWARRIOR_API AWarriorEnemyCharacter : 
    public AWarriorBaseCharacter, 
    public IEnemy_Death_Interface {
    GENERATED_BODY()
public:
    // å®ç°æ­»äº¡æ¥å£å‡½æ•°
    virtual void OnEnemyDeath(TSoftObjectPtr<UNiagaraSystem> Dissolve_Niagara_System) override;

#pragma region DissolveCurve // æº¶è§£ç‰¹æ•ˆé…ç½®åŒºåŸŸ
    // æ—¶é—´è½´å§”æ‰˜ï¼šç”¨äºæ›´æ–°æº¶è§£è¿›åº¦å’Œç»“æŸå›è°ƒ
    FOnTimelineFloat OnDissolveTimelineUpdate; 
    FOnTimelineEvent OnDissolveTimelineFinished;

    UPROPERTY(EditDefaultsOnly, Category = "Death")
    TSoftObjectPtr<UNiagaraSystem> Dissolve_Niagara_System;
    UPROPERTY(EditDefaultsOnly, Category = "Dissolve")
    float DissolveTime = 2.0f; // æº¶è§£æ€»æ—¶é•¿ï¼ˆç§’ï¼‰
    UPROPERTY(EditDefaultsOnly, Category = "Dissolve")
    UCurveFloat* DissolveCurve; // æ§åˆ¶æº¶è§£ç¨‹åº¦çš„æ›²çº¿ï¼ˆ0èµ·å§‹â†’1ç»“æŸï¼‰
    UPROPERTY(EditDefaultsOnly, Category = "Dissolve")
    FName DissolveParameterName; // æè´¨å‚æ•°åï¼ˆå¦‚"DissolveAmount"ï¼‰
    UPROPERTY(EditDefaultsOnly, Category = "Dissolve")
    FString ParameterNameString; // Niagaraç²’å­ç³»ç»Ÿå‚æ•°åï¼ˆå¦‚"User.DissolveColor"ï¼‰

    UPROPERTY()
    UTimelineComponent* DissolveTimeline; // æ§åˆ¶æº¶è§£åŠ¨ç”»çš„æ—¶é—´è½´ç»„ä»¶

    // æ—¶é—´è½´å›è°ƒå‡½æ•°
    UFUNCTION() void OnDissolveUpdate(float Value); // æ¯å¸§æ›´æ–°æè´¨å‚æ•°
    UFUNCTION() void OnDissolveFinished(); // æº¶è§£ç»“æŸæ—¶é”€æ¯è§’è‰²

    void SetDissolveTimeline(); // åˆå§‹åŒ–æ—¶é—´è½´ç»‘å®š
    void LoadNiagaraAsync(TSoftObjectPtr<UNiagaraSystem> Dissolve_Niagara_System); // å¼‚æ­¥åŠ è½½Niagaraç‰¹æ•ˆ
    void OnNiagaraLoaded(); // ç‰¹æ•ˆåŠ è½½å®Œæˆåçš„å›è°ƒ
    UNiagaraSystem* DissolveSystem; // ç¼“å­˜åŠ è½½çš„Niagaraèµ„æº
#pragma endregion
};
//WarriorEnemyCharacter.cpp
void AWarriorEnemyCharacter::BeginPlay()
{
    // è°ƒç”¨çˆ¶ç±»ï¼ˆAActorï¼‰çš„BeginPlay()ï¼Œç¡®ä¿åŸºç¡€åˆå§‹åŒ–é€»è¾‘ï¼ˆå¦‚ç»„ä»¶æ³¨å†Œã€å˜é‡åˆå§‹åŒ–ï¼‰è¢«æ‰§è¡Œ
    Super::BeginPlay();

    // åˆ›å»ºæ—¶é—´è½´ç»„ä»¶ï¼ˆUTimelineComponentï¼‰å®ä¾‹
    // - NewObjectï¼šåŠ¨æ€åˆ›å»ºUObjectæ´¾ç”Ÿç±»å¯¹è±¡
    // - thisï¼šæŒ‡å®šOuterï¼ˆæ‰€æœ‰è€…ï¼‰ä¸ºå½“å‰è§’è‰²ï¼Œç¡®ä¿ç”Ÿå‘½å‘¨æœŸç»‘å®š
    // - TEXT("DissolveTimeline")ï¼šå®šä¹‰ç»„ä»¶åç§°ï¼Œä¾¿äºè°ƒè¯•è¯†åˆ«
    DissolveTimeline = NewObject<UTimelineComponent>(this, TEXT("DissolveTimeline"));

    // è®¾ç½®ç»„ä»¶åˆ›å»ºæ–¹å¼ä¸ºç”¨æˆ·æ„é€ è„šæœ¬ï¼ˆUserConstructionScriptï¼‰
    // - é¿å…å¼•æ“è‡ªåŠ¨ç®¡ç†å†²çªï¼Œæ˜¾å¼å£°æ˜ç»„ä»¶åˆ›å»ºæ¥æº
    DissolveTimeline->CreationMethod = EComponentCreationMethod::UserConstructionScript;

    // å°†ç»„ä»¶æ·»åŠ åˆ°è“å›¾åˆ›å»ºç»„ä»¶åˆ—è¡¨ï¼ˆBlueprintCreatedComponentsï¼‰
    // - å…³é”®ä½œç”¨ï¼šé˜²æ­¢GCå›æ”¶ï¼è‹¥ä¸æ·»åŠ ï¼Œç»„ä»¶å¯èƒ½å› æœªè¢«å¼•ç”¨è€Œè¢«åƒåœ¾å›æ”¶
    this->BlueprintCreatedComponents.Add(DissolveTimeline);

    // æ³¨å†Œç»„ä»¶åˆ°Actor
    // - ä½¿ç»„ä»¶è¿›å…¥æ´»è·ƒçŠ¶æ€ï¼Œè§¦å‘OnRegisterç­‰äº‹ä»¶
    // - å¿…è¦çš„æ­¥éª¤ï¼šæœªæ³¨å†Œçš„ç»„ä»¶æ— æ³•å‚ä¸Tickæˆ–æ¸²æŸ“
    DissolveTimeline->RegisterComponent();
}
void AWarriorEnemyCharacter::OnEnemyDeath(...) {
    // Lambda 1: æš‚åœåŠ¨ç”» + ç¦ç”¨ç¢°æ’
    auto Task1 = [this] {
        GetMesh()->bPauseAnims = true; // å†»ç»“éª¨éª¼åŠ¨ç”»
        GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision); // å…³é—­ç¢°æ’
    };
    
    // Lambda 2: å¼‚æ­¥åŠ è½½ç‰¹æ•ˆ + å¯åŠ¨æº¶è§£æ—¶é—´è½´
    auto Task2 = [this, Dissolve_Niagara_System] {
        LoadNiagaraAsync(Dissolve_Niagara_System); // å¼‚æ­¥åŠ è½½Niagara
        DissolveTimeline->SetPlayRate(1.0f / DissolveTime); // è®¡ç®—æ—¶é—´è½´æ’­æ”¾é€Ÿç‡ï¼ˆ2ç§’æ’­å®Œï¼‰
        SetDissolveTimeline(); // ç»‘å®šæ—¶é—´è½´å§”æ‰˜
    };

    Task1(); // ç«‹å³æ‰§è¡Œ
    Task2(); // ç«‹å³æ‰§è¡Œï¼ˆå¼‚æ­¥åŠ è½½åœ¨åå°è¿›è¡Œï¼‰
}


void AWarriorEnemyCharacter::SetDissolveTimeline() {
    DissolveTimeline->PlayFromStart(); // ä»å¤´æ’­æ”¾
    // ç»‘å®šå§”æ‰˜åˆ°æ—¶é—´è½´äº‹ä»¶
    OnDissolveTimelineUpdate.BindDynamic(this, &ThisClass::OnDissolveUpdate); 
    OnDissolveTimelineFinished.BindDynamic(this, &ThisClass::OnDissolveFinished);
    
    if (DissolveCurve) {
        // å…³è”æ›²çº¿ï¼šé©±åŠ¨OnDissolveUpdateçš„Valueå‚æ•°ï¼ˆ0â†’1ï¼‰
        DissolveTimeline->AddInterpFloat(DissolveCurve, OnDissolveTimelineUpdate); 
    }
    DissolveTimeline->SetTimelineFinishedFunc(OnDissolveTimelineFinished);
    DissolveTimeline->SetLooping(false); // ä»…æ’­æ”¾ä¸€æ¬¡
}

void AWarriorEnemyCharacter::OnDissolveUpdate(float Value) {
    // æ›´æ–°è§’è‰²æè´¨çš„æº¶è§£å‚æ•°ï¼ˆå¦‚è®¾ç½®æ ‡é‡å‚æ•°"DissolveAmount"ï¼‰
    GetMesh()->SetScalarParameterValueOnMaterials(DissolveParameterName, Value);
    
    // æ›´æ–°æ­¦å™¨æè´¨çš„ç›¸åŒå‚æ•°ï¼ˆåŒæ­¥æº¶è§£æ•ˆæœï¼‰
    if (AWarriorWeaponBase* Weapon = EnemyCombatComponent->GetCharacterCurrentEquippedWeapon()) {
        Weapon->WeaponMesh->SetScalarParameterValueOnMaterials(DissolveParameterName, Value);
    }
}

void AWarriorEnemyCharacter::OnDissolveFinished() {
    Destroy(); // é”€æ¯è§’è‰²Actor
    // åŒæ­¥é”€æ¯æ­¦å™¨ï¼ˆé¿å…æ®‹ç•™ï¼‰
    if (AWarriorWeaponBase* Weapon = EnemyCombatComponent->GetCharacterCurrentEquippedWeapon()) {
        Weapon->Destroy();
    }
}
void AWarriorEnemyCharacter::LoadNiagaraAsync(...) {
    DissolveSystem = Dissolve_Niagara_System.Get(); // å°è¯•ç›´æ¥è·å–ï¼ˆè‹¥å·²åŠ è½½ï¼‰
    FSoftObjectPath NiagaraPath = Dissolve_Niagara_System.ToSoftObjectPath();
    // å¼‚æ­¥åŠ è½½å§”æ‰˜ï¼šåŠ è½½å®Œæˆåè§¦å‘OnNiagaraLoaded
    StreamableManager.RequestAsyncLoad(NiagaraPath, 
        FStreamableDelegate::CreateUObject(this, &ThisClass::OnNiagaraLoaded)
    );
}

void AWarriorEnemyCharacter::OnNiagaraLoaded() {
    if (!DissolveSystem) return; // å®‰å…¨æ ¡éªŒ

    // 1. é™„åŠ Niagaraç‰¹æ•ˆåˆ°éª¨éª¼ç½‘æ ¼ä½“
    UNiagaraComponent* NiagaraComp = UNiagaraFunctionLibrary::SpawnSystemAttached(
        DissolveSystem, 
        GetMesh(), 
        FName("Root"), // ç»‘å®šåˆ°æ ¹éª¨éª¼
        FVector::ZeroVector, 
        FRotator::ZeroRotator, 
        EAttachLocation::KeepRelativeOffset, 
        true // è‡ªåŠ¨æ¿€æ´»
    );

    // 2. åˆ›å»ºåŠ¨æ€æè´¨å®ä¾‹ï¼ˆMIDï¼‰
    UMaterialInstanceDynamic* DynamicMat = 
        GetMesh()->CreateDynamicMaterialInstance(0, GetMesh()->GetMaterial(0));

    // 3. ä»MIDè·å–é¢œè‰²å‚æ•°å¹¶ä¼ é€’ç»™Niagara
    FLinearColor DissolveColor = DynamicMat->K2_GetVectorParameterValue(DissolveParameterName);
    if (NiagaraComp) {
        // è®¾ç½®Niagaraç³»ç»Ÿä¸­çš„é¢œè‰²å˜é‡ï¼ˆéœ€ä¸ç¼–è¾‘å™¨å†…å˜é‡åä¸€è‡´ï¼‰
        NiagaraComp->SetNiagaraVariableLinearColor(ParameterNameString, DissolveColor);
    }
}
```

## **UI**

å¯¹äºUIéƒ¨åˆ†ï¼Œæ˜¾ç„¶æˆ‘ä»¬éœ€è¦åœ¨å±å¹•ä¸Šç»˜åˆ¶å¤§é‡ä¸åŒçš„æ§ä»¶ã€‚åŒ…æ‹¬æ‰€æœ‰è§’è‰²çš„è¡€æ¡ã€æ€’æ°”æ¡ï¼Œä»¥åŠè‹±é›„è§’è‰²çš„ä¸åŒå›¾æ ‡ã€‚å°†æ‰€æœ‰éœ€è¦çš„æ§ä»¶ç»˜åˆ¶åˆ°å±å¹•ä¸Šå¾ˆç®€å•ã€‚éš¾ç‚¹åœ¨äºå¦‚ä½•æ­£ç¡®ç»‘å®šéœ€è¦åœ¨UIä¸Šæ˜¾ç¤ºçš„å€¼ï¼Ÿä¾‹å¦‚ï¼Œæˆ‘ä»¬éœ€è¦ä»åŸç”Ÿç±» `WarriorAttributeSet`æ›´æ–°è§’è‰²è¡€æ¡ã€‚é€šè¿‡è¯¥ç±»å¯ç›‘æµ‹å±æ€§å˜åŒ–ã€‚æ¯å½“å½“å‰ç”Ÿå‘½å€¼å±æ€§å˜åŒ–æ—¶ï¼Œéœ€æ›´æ–°ç©å®¶å’Œæ•Œäººçš„è¡€æ¡ã€‚æ­¤å¤–ï¼Œåœ¨è‹±é›„çš„æ¸¸æˆèƒ½åŠ›è“å›¾ä¸­ï¼ˆå¦‚ `HeroEquipX`ï¼‰å½“è‹±é›„è£…å¤‡æ–§å¤´æ—¶ï¼Œéœ€æ›´æ–°å½“å‰æ­¦å™¨å›¾æ ‡ï¼ˆä»…ç©å®¶éœ€æ­¤åŠŸèƒ½ï¼‰ã€‚

![](./Lesson Images/4-21.png)

å¦‚ä½•è®¾è®¡é€šç”¨æ–¹æ¡ˆï¼Œå°†å¤šæ¥æºæ•°æ®åŒæ­¥è‡³UIï¼Ÿæ–¹æ¡ˆéœ€åŒæ—¶æ”¯æŒç©å®¶å’Œæ•Œäººï¼Œä¸”å¿…é¡»è§£è€¦â€”â€”`AttributeSet`æ— éœ€æ„ŸçŸ¥æ§ä»¶ï¼Œæ§ä»¶ä¹Ÿæ— éœ€æ„ŸçŸ¥ `AttributeSet`æˆ– `GameplayAbility`è“å›¾ã€‚è§£å†³æ–¹æ¡ˆæ˜¯å¼•å…¥ä¸­é—´å±‚ï¼šä¸ºPawnæ·»åŠ æ–°ç»„ä»¶ `PwnUIComponent`ã€‚

ç»„ä»¶ç±»ç»“æ„å¦‚ä¸‹ï¼š

![](./Lesson Images/4-22.png)

åœ¨å®Œæˆè§’è‰²çš„UIç»„ä»¶è®¾ç½®åï¼Œæˆ‘ä»¬å°†é€šè¿‡ä»¥ä¸‹æ–¹å¼æ›´æ–°UIï¼šå½“ `WarriorAttributeSet`ä¸­çš„å±æ€§å‘ç”Ÿå˜æ›´æ—¶ï¼ˆæ— è®ºç©å®¶æˆ–æ•Œäººï¼‰ï¼Œæˆ‘ä»¬ä¼šé€šè¿‡æ¥å£è·å–å…¶ `PwnUIComponent`ã€‚é€šè¿‡è¯¥ç»„ä»¶å¹¿æ’­å˜æ›´åçš„å±æ€§å€¼ã€‚å±å¹•ä¸Šç»˜åˆ¶çš„æ§ä»¶å°†ç›‘å¬æ¥è‡ª `PwnUIComponent`çš„å¹¿æ’­ï¼Œå¹¶æ®æ­¤æ›´æ–°UIæ•°å€¼ã€‚

![](./Lesson Images/4-23.png)

åˆ›å»ºä»¥**PawnExtensionComponentBase**ä¸ºçˆ¶ç±»çš„**PawnUIComponent**åŒæ—¶åˆ›å»ºå­ç±»**HeroUIComponent**å’Œ**EnemyUIComponent**

åˆ›å»º**PawnUIInterface**ï¼Œå¹¶å®Œæˆåˆå§‹åŒ–ã€‚

**å¹¿æ’­å€¼**

**PawnUIComponentç±»**

```c++
#pragma once
#include "CoreMinimal.h"
#include "Components/PawnExtensionComponentBase.h"  // ç»§æ‰¿è‡ªPawnæ‰©å±•ç»„ä»¶åŸºç±»
#include "PawnUIComponent.generated.h"  // å¿…éœ€çš„å¤´æ–‡ä»¶ï¼Œæ”¯æŒUCLASSå®

// å£°æ˜åŠ¨æ€å¤šæ’­å§”æ‰˜ï¼šç”¨äºä¼ é€’ç™¾åˆ†æ¯”å˜åŒ–ï¼ˆå¦‚è¡€æ¡/æ€’æ°”æ¡ï¼‰
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPercentChangedDelegate, float, NewPercent);

UCLASS()
class MYWARRIOR_API UPawnUIComponent : public UPawnExtensionComponentBase {
    GENERATED_BODY()
public:
    UPROPERTY(BlueprintAssignable)  // å…è®¸è“å›¾ç»‘å®šè¯¥å§”æ‰˜
    FOnPercentChangedDelegate OnCurrentHealthChanged;  // å½“å‰ç”Ÿå‘½å€¼å˜æ›´å§”æ‰˜
};
```

**HeroUIComponentåŒç†**

**WarriorAttributeSetç±»**æ·»åŠ UIéƒ¨åˆ†

```c++
//WarriorAttributeSet.h
class IPawnUIInterface;
private:
    TWeakInterfacePtr<IPawnUIInterface> CachedPawnUIInterface;
//WarriorAttributeSet.cpp
void UWarriorAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data) {
    // 1. è·å–PawnUIæ¥å£
    if (!CachedPawnUIInterface.IsValid()) {
        CachedPawnUIInterface = TWeakInterfacePtr<IPawnUIInterface>(Data.Target.GetAvatarActor());
    }
    checkf(CachedPawnUIInterface.IsValid(), TEXT("è§’è‰²æœªå®ç°IPawnUIInterfaceæ¥å£"));

    // 2. æå–UIç»„ä»¶
    UPawnUIComponent* PawnUIComponent = CachedPawnUIInterface->GetPawnUIComponent();
    checkf(PawnUIComponent, TEXT("æ— æ³•ä»è§’è‰²è·å–PawnUIComponent"));
    
    if (Data.EvaluatedData.Attribute == GetCurrentHealthAttribute()) {
    const float NewCurrentHealth = FMath::Clamp(GetCurrentHealth(), 0.f, GetMaxHealth());
    SetCurrentHealth(NewCurrentHealth);  // çº¦æŸç”Ÿå‘½å€¼èŒƒå›´
    PawnUIComponent->OnCurrentHealthChanged.Broadcast(GetCurrentHealth() / GetMaxHealth()); // å¹¿æ’­ç™¾åˆ†æ¯”
    }    
    if (Data.EvaluatedData.Attribute == GetCurrentRageAttribute()) {
    const float NewCurrentRage = FMath::Clamp(GetCurrentRage(), 0.f, GetMaxRage());
    SetCurrentRage(NewCurrentRage);
    // ä»…è‹±é›„è§’è‰²æ›´æ–°æ€’æ°”æ¡
    if (UHeroUIComponent* HeroUIComponent = CachedPawnUIInterface->GetHeroUIComponent()) {
        HeroUIComponent->OnCurrentRageChanged.Broadcast(GetCurrentRage() / GetMaxRage());
    }
    }
   if (Data.EvaluatedData.Attribute == GetDamageTakenAttribute()) {
    const float OldHealth = GetCurrentHealth();
    const float DamageDone = GetDamageTaken();
    const float NewCurrentHealth = FMath::Clamp(OldHealth - DamageDone, 0.f, GetMaxHealth());
    SetCurrentHealth(NewCurrentHealth);

    // å¹¿æ’­ç”Ÿå‘½å˜æ›´
    PawnUIComponent->OnCurrentHealthChanged.Broadcast(GetCurrentHealth() / GetMaxHealth());

    // æ­»äº¡åˆ¤å®š
    if (GetCurrentHealth() == 0.f) {
        UWarriorFunctionLibrary::AddGameplayTagToActorIfNone(
            Data.Target.GetAvatarActor(), 
            WarriorGameplayTags::Shared_Status_Dead
        );
    }
   }
}
```

