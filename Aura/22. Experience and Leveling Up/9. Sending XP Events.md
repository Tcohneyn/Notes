这段视频字幕详细讲解了如何在 C++ 中触发并发送 **Gameplay Event**，以实现敌人死亡时向攻击者奖励经验值（XP）的逻辑。

以下是按标题大纲形式进行的中文详细总结：

### 一、 核心逻辑与目标 [00:00 - 00:58]

- **背景**：在前一段中已创建了监听技能，现在需要实现“发送”逻辑。
- **工具**：使用 `UAbilitySystemBlueprintLibrary::SendGameplayEventToActor` 静态函数。
- **载荷内容（Payload）**：发送时需要包含 **Event Tag**（事件标签）和 **Magnitude**（经验值数值）。
- **触发时机**：当属性集检测到“致命伤害”（Fatal Damage）导致敌人死亡时触发。

### 二、 属性集中的函数定义 [00:59 - 02:27]

- **位置**：修改 `AuraAttributeSet` 类。
- **新增私有函数**：`SendXPEvent(const FEffectProperties& Props)`。
- **参数传递**：通过 `Props` 结构体获取目标（死亡者）和来源（攻击者）的相关信息。

### 三、 C++ 实现：计算经验奖励 [02:28 - 05:25]

- **获取目标数据**：
  1. 将目标 Actor 转换为 `ICombatInterface`（战斗接口）。
  2. 获取目标的**等级（Level）\**和\**职业（Character Class）**。
- **调用库函数**：使用自定义的 `UAuraAbilitySystemLibrary::GetXPRewardForClassAndLevel` 函数，根据敌人的职业和等级从数据表中查询具体的经验值奖励数。

### 四、 构建 Payload 并发送事件 [05:26 - 08:54]

- **目标对象**：事件发送给 **Source Character**（即造成伤害的攻击者），因为攻击者是获取 XP 的人。
- **设置标签**：使用 `Attributes.Meta.IncomingXP` 标签。
- **填充数据结构 (`FGameplayEventData`)**：
  - 设置 `EventTag`。
  - 将查询到的经验值赋给 `EventMagnitude`（幅度/数值）。
- **发送函数**：调用 `SendGameplayEventToActor`，将攻击者、标签和载荷数据一并送出。

### 五、 关键技术修复：BlueprintNativeEvent [10:16 - 10:50]

- **报错原因**：在 C++ 中直接调用了 `GetCharacterClass`，这是一个 `BlueprintNativeEvent`。
- **解决方案**：必须调用生成的 `Execute_GetCharacterClass(ActorPtr)` 静态版本。
- **注意**：普通的 C++ 函数（如 `GetPlayerLevel`）可以直接调用，但标记为蓝图原生的事件在 C++ 中有特定的调用规范。

### 六、 系统运行流程验证 [10:51 - 14:04]

1. **击杀触发**：玩家攻击并击杀敌人。
2. **事件接收**：被动技能 `GA_ListenForEvents` 成功接收到带有 `Attributes.Meta.IncomingXP` 标签的事件。
3. **数值传递**：技能通过 `SetByCaller` 将 XP 数值（例如 20 点）传递给 `GE_EventBasedEffect`。
4. **属性修改**：该 GE 应用于攻击者，修改其 `IncomingXP` 元属性。
5. **日志确认**：在 Output Log 中通过 `LogAura` 看到“Incoming XP 20”的记录，证明流程闭环。

### 七、 后续计划 [14:05 - 结束]

- **持久化 XP**：目前 XP 只到达了属性集的元属性中，下一步需要将其正式累加到 **Player State**（玩家状态）中存储。
- **UI 同步**：设置 UI 监听 XP 的变化，并在 HUD 上更新经验条。
- **等级提升**：随后将基于 XP 积累实现等级提升逻辑。