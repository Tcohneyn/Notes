# 🎯 Attribute Menu Widget Controller — 属性菜单控制器完整逻辑（00:00:00,240 ～ 00:16:01,890）

------

## 一、功能目标

- 实现角色属性菜单（Attribute Menu）界面：
  - 通过 **C++ 与蓝图结合**，动态读取角色属性值。
  - 将属性信息广播给 UI Widget，显示在各行文本组件上。
- 核心流程：
  - **绑定依赖 → 广播初始值 → 建立委托 → 按标签更新显示。**

------

## 二、基础结构与数据准备

### 1. 关联的类与数据

- **UAuraAttributeSet**
  - 存储角色基础与次级属性（力量、智力、防御等）。
- **UAttributeInfo（Data Asset）**
  - 按 GameplayTag 存储每个属性的名称、描述、图标等。
- **FAuraGameplayTags**
  - 统一定义所有属性标签（Primary / Secondary / Vital）。

------

## 三、初始化与广播初始属性值

### 1. 绑定依赖接口

```cpp
void UAttributeMenuWidgetController::BindCallbacksToDependencies()
{
    // 后续将绑定属性变化回调，目前留空。
}
```

### 2. 广播初始值逻辑

```cpp
void UAttributeMenuWidgetController::BroadcastInitialValues()
{
    UAuraAttributeSet* AS = CastChecked<UAuraAttributeSet>(AttributeSet);
    check(AttributeInfo);

    FAuraAttributeInfo Info = AttributeInfo->FindAttributeInfoForTag(
        FAuraGameplayTags::Get().Attributes_Primary_Strength
    );
    Info.AttributeValue = AS->GetStrength();
    AttributeInfoDelegate.Broadcast(Info);
}
```

#### 说明：

- 从 AttributeSet 读取当前属性值。
- 在 Data Asset 中查找对应属性信息。
- 更新结构体并广播委托。
- Widget 端接收后显示在 UI 上。

------

## 四、Blueprint 中的委托绑定

### 1. 在蓝图 Widget Controller 设置

- 在蓝图类中绑定 `AttributeInfo` 数据资产引用。
- 在 `Event Construct` 中调用 `BroadcastInitialValues`。
- 确保广播时数据资产已准备完毕。

### 2. 在 Widget 端绑定委托

- 在 UI Widget（如 TextValueButtonRow）中：
  - 获取 `AttributeMenuWidgetController`。
  - 绑定 `AttributeInfoDelegate`。
  - 使用 **Break Struct** 获取属性名与数值。
  - 调用 `SetLabelText()` 与 `SetValueText()` 更新界面。

------

## 五、父类组件封装（TextValueRow）

### 1. 提取公共逻辑

- 父类 `TextValueRow` 负责：

  - 基础文本控件（Label / Value）。

  - 设置文本的函数：

    ```cpp
    void SetLabelText(FText LabelText);
    void SetValueText(FText ValueText);
    ```

- 子类 `TextValueButtonRow`：

  - 在委托触发时调用父类接口更新内容。

------

## 六、为属性菜单设置 Gameplay Tag 区分

### 1. 在每行组件中添加变量

- 打开 **TextValueRow** 蓝图：
  - 新增变量：`AttributeTag`
  - 类型：Gameplay Tag
  - 勾选 **Instance Editable / Expose on Spawn**
  - 用于标识该行对应的属性。

### 2. 在主 Attribute Menu 中命名所有行

- 重命名每行控件（并勾选 Is Variable）：

  ```
  Row_Strength
  Row_Intelligence
  Row_Resilience
  Row_Vigor
  Row_Armor
  Row_ArmorPenetration
  Row_BlockChance
  Row_CriticalHitChance
  Row_CriticalHitDamage
  Row_CriticalHitResistance
  Row_HealthRegeneration
  Row_ManaRegeneration
  Row_MaxHealth
  Row_MaxMana
  ```

------

## 七、在蓝图中设置 Attribute Tag 初始化

### 1. 新建函数 `SetAttributeTags`

- 在主 Widget 蓝图中添加函数：

  - 依次设置每个 Row 的 AttributeTag：

    ```text
    Row_Strength → Attributes.Primary.Strength
    Row_Intelligence → Attributes.Primary.Intelligence
    Row_Resilience → Attributes.Primary.Resilience
    Row_Vigor → Attributes.Primary.Vigor
    ...
    ```

- 用 **Sequence Node** 分组执行主属性 / 次属性。

- 在主 Event Graph 中执行顺序：

  ```
  Sequence:
  ├─ Then 0：绑定关闭按钮
  ├─ Then 1：设置 WidgetController
  ├─ Then 2：SetAttributeTags（新建函数）
  └─ Then 3：BroadcastInitialValues（调用）
  ```

------

## 八、基于 Tag 的属性匹配与更新逻辑

### 1. 在 TextValueButtonRow 中实现匹配

- 当委托广播 `FAuraAttributeInfo`：

  - 使用 `MatchesTag(ExactMatch)` 检查是否是本行对应属性。

  - 匹配成功才更新显示：

    ```
    SetLabelText(Info.AttributeName)
    SetValueText(Info.AttributeValue)
    ```

- 测试结果：
   仅力量（Strength）行更新，逻辑正确。

------

## 九、将绑定逻辑上移至父类

- 将原本在 `TextValueButtonRow` 的绑定逻辑移至父类 `TextValueRow`：
  - 在 `Event Construct` 中绑定委托。
  - 所有继承自它的行（包括无按钮的次属性行）都能响应更新。
- 优化后：
  - 各行自动识别自身 Tag 并更新显示。

------

## 🔚 十、当前实现总结

| 功能                            | 实现状态 |
| ------------------------------- | -------- |
| 绑定 AttributeSet 与 Data Asset | ✅        |
| 广播初始属性信息                | ✅        |
| Delegate 机制建立               | ✅        |
| 每行 Widget 独立匹配属性        | ✅        |
| 蓝图批量设置 AttributeTag       | ✅        |
| 父类封装统一更新逻辑            | ✅        |

------

## 🧩 下节预告

- 扩展：**广播所有属性值（批量广播 Primary / Secondary / Vital）**
- 实现：**属性变化时实时更新 UI。**

