### 【Click to Move：自动寻路行为逻辑与完善】

#### 一、在 Tick 函数中实现自动寻路逻辑

- 在 `PlayerTick()` 中调用 `AutoRun()` 函数以处理自动移动。
- 使用 `GetPawn()` 获取受控 Pawn，并判断是否有效（包括 Pending Kill 状态）。

------

#### 二、计算样条曲线上的最近点与方向

1. **获取最近点：**
   - 使用 `Spline->FindLocationClosestToWorldLocation()`
   - 输入：`Pawn->GetActorLocation()`
   - 输出：`LocationOnSpline`（世界空间下的样条位置）。
2. **获取移动方向：**
   - 使用 `Spline->FindDirectionClosestToWorldLocation()`
   - 得到 `Direction`（沿曲线前进方向）。
3. **执行移动：**
   - `ControlledPawn->AddMovementInput(Direction)` 使角色沿曲线移动。

------

#### 三、终点检测与停止机制

- 计算到目标点的距离：

  ```cpp
  DistanceToDestination = (LocationOnSpline - CachedDestination).Length();
  ```

- 若距离 ≤ `AutoRunAcceptanceRadius`：

  - `bAutoRunning = false;`
  - 停止自动移动。

------

#### 四、代码重构

- 将自动移动逻辑封装为私有函数 `AutoRun()`；

- 在 Tick 中仅调用该函数，保持 Tick 函数整洁。

- 在 `AutoRun()` 开头添加：

  ```cpp
  if (!bAutoRunning) return;
  ```

  防止在非自动移动状态下执行逻辑。

------

#### 五、多人联机测试与常见问题

- 初次运行发现角色持续自动前进 → 因未正确重置 `bAutoRunning`。
- 修复后，单人与服务器端测试均可正常运行。

------

#### 六、客户端导航路径生成问题

- 若客户端无法生成路径（未出现调试球）：
  - 需启用：
     **Edit → Project Settings → Navigation System → Allow Client Side Navigation**
  - 否则 `FindPathToLocationSynchronously()` 在客户端无效。

------

#### 七、点击无效区域或障碍物处理

1. **点击障碍物（如柱子）**

   - 原因：碰撞体拦截了可见性射线（Visibility Channel）。
   - 解决：将柱体碰撞预设设为 **Custom**，并将 **Visibility → Ignore**。
   - 效果：点击柱子时光标可“穿透”检测到地面。

2. **点击非导航区域**

   - 原因：目标点不在 NavMesh 内。

   - 解决：将 `CachedDestination` 替换为路径中最后一个可达点：

     ```cpp
     CachedDestination = NavPath->PathPoints.Last();
     ```

   - 确保角色始终移动到可到达位置，避免“跑向远方”的错误行为。

------

#### 八、测试结果

- 角色能平滑地沿样条路径自动寻路；
- 能正确绕过障碍；
- 点击不可达区域时自动修正；
- 客户端与服务器均同步正常。

------

#### 九、阶段总结

✅ 完成多人可用的 Click to Move 系统。
 ✅ 自动寻路、路径平滑、停止机制均可正常工作。
 ➡️ 下一步：优化与重构输入系统，开始进入 **Gameplay Ability（技能系统）** 制作阶段。