# 【Click to Move：点击释放自动寻路功能实现】

#### 一、目标

- 从“点击并按住移动”扩展为“点击并释放自动寻路（Auto Run）”。
- 通过检测鼠标释放事件与按压时长区分行为。

------

#### 二、事件入口：Ability Input Tag Released

- 检查释放的输入是否为 **左键（Left Mouse Button）**。
  - 若不是 → 调用 `AbilityInputTagReleased()` 并返回。
  - 若是左键 → 继续执行 Click to Move 逻辑。

------

#### 三、目标判断与技能释放逻辑

- 若当前 `bTargeting == true` → 调用 `AbilityInputTagReleased()` 激活技能。
- 否则进入“移动逻辑”判断。

------

#### 四、短按检测与路径生成

- 检测是否为短按：

  ```cpp
  if (FollowTime <= ShortPressThreshold && ControlledPawn)
  ```

- 若为短按：

  1. 获取 Pawn 当前位置 `GetActorLocation()`。
  2. 使用 `UNavigationSystemV1::FindPathToLocationSynchronously()`
     - 起点：Pawn 位置
     - 终点：`CachedDestination`
  3. 得到 `UNavigationPath* NavPath`。

------

#### 五、路径点（Path Points）与样条曲线（Spline）

- 清空旧路径：`Spline->ClearSplinePoints()`
- 遍历 `NavPath->PathPoints`：
  - 使用 `Spline->AddSplinePoint(PointLocation, ESplineCoordinateSpace::World)` 添加曲线点；
  - 用 `DrawDebugSphere()` 绘制调试点（绿色、小圆球、持续 5 秒）。

------

#### 六、状态与变量重置

- 设置：

  ```cpp
  bAutoRunning = true;     // 启用自动寻路
  FollowTime = 0.f;        // 重置按下时长
  bTargeting = false;      // 取消目标锁定
  ```

------

#### 七、模块依赖修复

- 若出现 **Linker Error**（找不到导航系统），需在 `Aura.Build.cs` 中添加模块：

  ```cpp
  PrivateDependencyModuleNames.Add("NavigationSystem");
  ```

- 重新编译后正常运行。

------

#### 八、测试与调试

1. 在场景中放置 **Nav Mesh Bounds Volume** 并扩大覆盖范围；
2. 按 **P 键** 查看导航网格；
3. 点击地面可生成路径点（绿色球）；
4. 放置障碍物（如柱子）测试路径绕行功能。

------

#### 九、结果与下一步

- 当前成功生成路径点与样条曲线；
- 障碍物可正确避让；
- 下一步将在 Tick 函数中实现真正的 **自动运行（Auto Run）行为**。