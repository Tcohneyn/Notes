### 【Player Controller 优化与客户端消息同步修复】

#### 一、总体目标

- 清理与优化 Player Controller 结构；
- 减少重复逻辑、压缩代码；
- 修复客户端未显示 Gameplay Effect 消息的问题。

------

#### 二、光标检测优化（Cursor Trace）

- 问题：每帧重复调用 `GetHitResultUnderCursor()` 两次。
- 解决方案：
  - 新增成员变量 `FHitResult CursorHit`；
  - 在 `CursorTrace()` 中填充一次即可；
  - 其他函数（如 `AbilityInputTagHeld`）直接使用 `CursorHit`。
- 优势：减少重复 Trace，提高效率，可扩展（如显示光标贴花）。

------

#### 三、Cursor Trace 代码精简

- 移除冗余注释与空逻辑块；
- 合并条件判断：
  - 若 `LastActor` 有效且不等于当前 `Actor` → 调用 `UnHighlight()`；
  - 若当前 `Actor` 有效且不等于 `LastActor` → 调用 `Highlight()`；
- 结果：同样功能更紧凑、更易读。

------

#### 四、风格与结构整理

- 压缩单行 `if` 语句（仅执行一行逻辑时）；
- Unreal Coding Standards 虽建议始终加大括号，但此处按个人偏好简化；
- 清除多余空行、无用空格；
- 移除调试绘制代码（如 `DrawDebugSphere`）；
- 局部变量 `ControlledPawn` 加上 `const` 修饰符。

------

#### 五、测试与验证

- 进行多种输入测试：
  - 点击与长按 → Run、Auto Run 正常；
  - 点击障碍物 → 自动绕行；
  - 点击敌人 → 高亮正确切换。
- 多人联机测试通过（服务器与客户端动作一致）。

------

#### 六、客户端消息显示问题修复

- 问题：客户端未收到 Gameplay Effect 提示。

- 原因：`EffectApplied` 委托仅在服务器触发。

- 解决方案：

  1. 将回调函数改为 **Client RPC**：

     ```cpp
     UFUNCTION(Client, Reliable)
     void ClientEffectApplied(...);
     ```

  2. 实现函数命名为 `ClientEffectApplied_Implementation()`；

  3. 将绑定的委托由 `EffectApplied` 改为 `ClientEffectApplied`。

- 效果：

  - 服务器调用时，RPC 同步执行到客户端；
  - 服务器自身则本地执行一次，不重复发送。

------

#### 七、最终测试

- 在三人（两客户端 + 一服务器）环境下测试：
  - 所有客户端均正确接收并显示 HUD 消息；
  - Dedicated Server 模式下也正常同步。

------

#### 八、阶段总结

✅ Player Controller 结构更简洁高效；
 ✅ 消息同步完全修复；
 ✅ 点击移动与交互逻辑稳定；
 ➡️ 准备进入下一个功能模块开发。



## 补充

你在 `ClientEffectApplied`函数名后面加上 `_Implementation`后缀，这是 Unreal Engine 为特定类型的函数规定的**必须遵循的命名规则**。它主要与两种机制密切相关：**RPC（远程过程调用）** 和 **Blueprint Native Events（蓝图原生事件）**。

下面的表格清晰地展示了需要此后缀的主要场景及其含义：

| 场景                   | UFUNCTION 宏示例                  | 含义                                                         | 实现函数命名                  |
| ---------------------- | --------------------------------- | ------------------------------------------------------------ | ----------------------------- |
| **RPC (远程过程调用)** | `UFUNCTION(Client, Reliable)`     | 这是一个客户端RPC。函数在服务器上调用，但执行逻辑在客户端上运行。 | `FunctionName_Implementation` |
| **RPC (远程过程调用)** | `UFUNCTION(Server, Reliable)`     | 这是一个服务器RPC。函数在客户端上调用，但执行逻辑在服务器上运行。 | `FunctionName_Implementation` |
| **蓝图原生事件**       | `UFUNCTION(BlueprintNativeEvent)` | 函数在C++中有默认实现，同时允许在蓝图中被重写（Override）。  | `FunctionName_Implementation` |

### 🛠️ 工作机制与流程

这个命名规则是 Unreal Engine 反射系统和网络同步机制的核心组成部分。其工作流程可以概括如下：

1. **声明与生成**：当你在头文件中使用诸如 `UFUNCTION(Client, Reliable)`声明一个函数（例如 `ClientEffectApplied`）时，Unreal Header Tool (UHT) 这个工具会在处理你的代码时，在你的 `生成.h`文件中自动生成一个同名函数（即 `ClientEffectApplied`）。
2. **自动分发**：这个由UHT生成的函数是一个“分发器”。它的职责是处理网络通信等底层细节。当它收到远程调用请求后，会去查找并调用你亲手编写的、带 `_Implementation`后缀的实现函数。
3. **实现核心逻辑**：而你负责编写的 `ClientEffectApplied_Implementation`函数，则包含了这个RPC调用希望执行的**实际游戏逻辑**。在这个例子里，就是获取GameplayEffect的资产标签并将其广播出去。

简单来说，这是一种分工：**UHT生成的函数负责“传输”，你编写的 `_Implementation`函数负责“执行”**。

### 💡 结合你的代码分析

让我们具体看你的函数：

```
UFUNCTION(Client, Reliable)
void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);

// 对应的实现函数
void UAuraAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
{
    FGameplayTagContainer TagContainer;
    EffectSpec.GetAllAssetTags(TagContainer);
    EffectAssetTags.Broadcast(TagContainer); // 广播标签，很可能用于更新UI等客户端表现
```

这是一个非常典型的**客户端RPC**应用场景。它的执行流程是：

- **服务器** 上应用了一个Gameplay Effect。
- 服务器需要通知**客户端** 这个事件，以便客户端更新界面、播放音效或特效等。
- 服务器会调用 `ClientEffectApplied`这个RPC函数。
- Unreal Engine 的网络系统会保证这个调用被安全地发送到对应的客户端上。
- **客户端** 收到调用后，最终执行的是你写的 `ClientEffectApplied_Implementation`函数中的逻辑，从而完成客户端侧的响应。

### ⚠️ 重要规则

在使用这些特殊函数时，请务必记住以下几点：

- **命名是强制的**：如果你声明了一个 `UFUNCTION(Server)`或 `UFUNCTION(Client)`的RPC函数，或者一个 `UFUNCTION(BlueprintNativeEvent)`函数，**就必须**提供对应的 `_Implementation`版本的具体实现，否则在链接阶段会报错。
- **调用方式**：在你的C++代码中，你**应该直接调用没有后缀的函数名**（例如，在客户端调用 `Server_SomeFunction()`）。引擎会自动处理后续流程，最终执行到你的 `_Implementation`函数。你永远不应该直接去调用 `xxxx_Implementation`函数。
- **验证函数**：对于`Server`类型的RPC，你还可以额外定义一个 `_Validate`函数（例如 `Server_SomeFunction_Validate`），用于在服务器执行逻辑前进行安全验证，防止作弊。

希望这个解释能帮助你彻底理解 `_Implementation`后缀的作用和重要性。这对于在Unreal Engine中编写正确的网络同步和蓝图交互代码至关重要。