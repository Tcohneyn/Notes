这段视频教程重点介绍了如何通过 C++ 和蓝图协作，为 AI 敌人引入**“战斗目标（Combat Target）”**概念，并利用该目标驱动 **Motion Warping（运动扭曲）**，确保敌人在攻击时始终朝向玩家。

以下是内容的详细标题大纲式总结：

### 一、 问题背景与先决条件检查

- **根运动（Root Motion）确认**：强调 Motion Warping 必须配合根运动才能生效。需确保长矛兵的攻击动画中 `Enable Root Motion` 已勾选。
- **旋转偏差问题**：观察到 AI 在攻击时朝向不准，原因是 Motion Warping 缺少一个明确的“目标坐标”来计算旋转。
- **核心方案**：为敌人添加一个 `CombatTarget` 变量，动态记录其当前的攻击目标（通常是玩家角色 Aura）。

### 二、 C++ 层级：定义变量与接口函数

- **新增变量**：在 `AuraEnemy` 类中添加 `CombatTarget`（`AActor` 类型的指针），并设置为 `BlueprintReadWrite`，以便蓝图访问。
- **接口设计（Enemy Interface）**：
  - 在接口中定义 `SetCombatTarget` 和 `GetCombatTarget` 函数。
  - **关键技术点**：使用 **`BlueprintNativeEvent`**。
    - *优势*：既能提供 C++ 的默认实现，又允许在蓝图中重写或直接调用。
- **C++ 实现**：在敌人基类中重写 `_Implementation` 版本，实现简单的 Setter 和 Getter 逻辑。

### 三、 行为树（Behavior Tree）任务集成

- **黑板键选择器（Blackboard Key Selector）**：
  - 在 `BT_Attack`（行为树任务蓝图）中新增变量 `CombatTargetSelector`。
  - 在行为树编辑器中，将该变量关联至黑板上的 `TargetToFollow` 键。
- **节点逻辑重构**：
  - 重命名节点为 `Melee Attack` 和 `Ranged Attack` 以示区分。

### 四、 蓝图逻辑：同步战斗目标

- **设置战斗目标（任务端）**：
  - 在 `BT_Attack` 激活技能**之前**，从黑板获取 `TargetToFollow` 的 Actor。
  - 调用接口函数 `SetCombatTarget`，将该 Actor 传递给受控的 AI 角色。
- **有效性检查**：如果黑板中没有有效目标，则直接结束任务而不激活技能，避免报错。

### 五、 技能系统（GAS）与 Motion Warping 的联动

- **获取目标位置**：在 `GA_MeleeAttack` 技能激活时，通过接口调用 `GetCombatTarget` 获取目标。
- **更新扭曲目标（Update Facing Target）**：
  - 将 `Avatar Actor` 转换为战斗接口（Combat Interface）。
  - 调用 `UpdateFacingTarget` 函数，传入目标的 `ActorLocation`。
- **执行流程**：先更新扭曲坐标，再播放蒙太奇动画，从而触发动画中的 Motion Warping 通知。

### 六、 测试与优化建议

- **验证方法**：通过延长动画蒙太奇中的 Motion Warping 窗口时间，观察 AI 是否缓慢而精准地转向玩家来验证逻辑。
- **进阶思路**：
  - 目前的逻辑是攻击开始时“快照”一次位置。
  - **进阶挑战**：若需实现“持续追踪旋转”，可使用计时器（Timer）或时间轴（Timeline）在动画播放期间每帧更新扭曲坐标。

------

**总结**：这一节通过**接口（Interface）**解耦了行为树和技能系统，确保 AI 知道“我在打谁”，并利用 **Motion Warping** 解决了 AI 攻击朝向生硬的技术痛点。