# 初始化敌人属性

### 1. 🎯 决定数据资产 (Data Asset) 的存储位置

- **问题**：`Character Class Info` 数据资产应该存放在哪里？ 
- **分析**：放在每个角色上会很冗余 。
- **方案**：游戏模式 (Game Mode) 是一个理想的中心位置，因为它掌管游戏规则，而该资产也包含规则（如敌人属性） 。
- **C++ 实现**：
  - 在游戏模式 (AuraGameMode) 的头文件中，添加一个 `UCharacterClassInfo` 类型的 `TObjectPtr` 变量 。
  - 将其设为 `UPROPERTY`，并标记为 `EditDefaultsOnly`，以便在蓝图中设置 。



### 2. 🛠️ 创建一个静态的属性初始化函数



- **目标**：创建一个函数来访问游戏模式中的数据资产，并将其应用到敌人身上 。

- **位置**：在蓝图库 `AuraAbilitySystemLibrary` 中创建 。

- **C++ 实现**：

  - 创建一个名为 `InitializeDefaultAttributes` 的 `static void` 函数 。

  - 使其 `BlueprintCallable` 。

  - **函数参数**：

    1. `UObject* WorldContextObject`：用于获取游戏模式 。

    2. `ECharacterClass CharacterClass`：要应用的枚举类 。

    3. `float Level`：用于查询曲线表的等级 。

    4. `UAbilitySystemComponent* ASC`：要应用游戏效果 (GE) 的目标组件 。

       

------



### 3. ⚙️ 实现 `InitializeDefaultAttributes` 函数

- **获取数据**：

  - 使用 `UGameplayStatics::GetGameMode` (传入 `WorldContextObject`) 。

  - 将其投射 (Cast) 到 `AuraGameModeBase` 。

  - 添加一个空指针检查，如果投射失败则 `return` 。

  - 从游戏模式中获取 `CharacterClassInfo` 数据资产 。

    

- **应用主要属性 (Primary Attributes)**：

  - 从数据资产调用 `GetClassDefaultInfo` (传入 `CharacterClass`) 来获取特定职业的默认信息结构 (struct) 。

    

  - 从该结构中获取 `PrimaryAttributes` 游戏效果 (GE) 。

    

  - 调用 `ASC->MakeOutgoingSpec` 创建效果规格 (Spec)，传入 GE 类、`Level` 和一个 `EffectContextHandle` 。

    

  - 调用 `ASC->ApplyGameplayEffectSpecToSelf` 应用该效果 。

    

- **应用次要 (Secondary) 和 VItal 属性**：

  - 重复上述过程来应用 `SecondaryAttributes` 和 `VitalAttributes` 。

  - **关键区别**：这两个GE是直接存储在 `CharacterClassInfo` 数据资产的根上，而不是在特定职业的结构中 。

    

------



### 4. 🔌 将初始化逻辑连接到敌人 (Enemy)

- **添加职业属性**：

  - 在 `AuraEnemy.h` (敌人类头文件) 中，添加一个 `ECharacterClass` 类型的 `UPROPERTY` 属性 。

    

  - 设为 `EditAnywhere` 和 `BlueprintReadOnly`，并设置一个默认值 (如 `Warrior`) 。

    

- **覆盖初始化函数**：

  - 将基类 (`AuraCharacterBase`) 中的 `InitializeDefaultAttributes` 函数标记为 `virtual`（虚函数） 。

    

  - 在 `AuraEnemy.cpp` 中覆盖 (override) 此函数 。

    

  - 在覆盖的函数体中，调用新的库函数 `UAuraAbilitySystemLibrary::InitializeDefaultAttributes` 。

    

  - 传入敌人自己的 `this` (上下文)、`CharacterClass`、`Level` 和 `AbilitySystemComponent` 。

    

------



### 5. 🐞 调试和验证

- **步骤1：设置蓝图**

  - 编译并启动编辑器 。

    

  - 打开 `AuraGameMode` 蓝图，将 `CharacterClassInfo` 数据资产分配给之前创建的属性 。

    

- **步骤2：修复崩溃 (Bug 1)**

  - **问题**：运行时游戏崩溃 。

    

  - **原因**：应用 GE 时没有设置 `SourceObject`（源对象）。这对于使用 `ModMagCalc` (如次要属性) 的GE是必需的 。

    

  - **修复**：在 `InitializeDefaultAttributes` (库函数) 中：

    1. 获取 `AvatarActor` (即 `ASC->GetAvatarActor()`) 。

       

    2. 在调用 `MakeOutgoingSpec` 之前，先单独创建 `EffectContextHandle` (`ASC->MakeEffectContext()`) 。

       

    3. 调用 `ContextHandle.AddSourceObject(AvatarActor)` 将 Avatar 添加为源对象 。

       

    4. 将这个修改后的 `ContextHandle` 传入 `MakeOutgoingSpec` 。

       

    5. 对所有三个GE (Primary, Secondary, Vital) 重复此操作 。

       

- **步骤3：验证逻辑 (Bug 2)**

  - **问题**：游戏不再崩溃，但如何确认应用了正确的属性？ 。

  - **验证**：

    1. 在 `InitializeDefaultAttributes` (库函数) 中设置断点 。

    2. 运行游戏，检查 `PrimaryAttributesSpecHandle`。调试器显示它正在使用正确的GE (例如 `PrimaryAttributes_Warrior`) 和正确的曲线表 (例如 "strength row name") 。

    3. 在编辑器中，将场景里的“slingshot”敌人的 `Character Class` 更改为 `Ranger` 。

    4. 重新运行，断点命中时，`CharacterClass` 参数现在是 `Ranger` ，并且 Spec Handle 确认正在使用 `PrimaryAttributes_Ranger` 曲线表 。

       

- **结论**：属性初始化系统按预期工作 。

  

------



###  . ⏭️ 后续步骤

- 既然敌人的属性已正确初始化，接下来的重点将是处理对敌人造成伤害的逻辑 。

  

  