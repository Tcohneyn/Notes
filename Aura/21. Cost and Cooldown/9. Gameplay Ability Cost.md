这段视频主要介绍了如何在虚幻引擎的 Gameplay Ability System (GAS) 中实现**技能消耗（Cost）**机制。以下是内容的标题大纲式详细总结：

### 一、 引入技能消耗与冷却的概念 [00:00 - 01:26]

- **现状分析**：当前技能（如火球术）发射不消耗资源，且仅通过“延迟节点”而非正式的“冷却机制”来防止连发，这在正规开发中被视为一种临时方案（Hack）。
- **目标设定**：实现真正的资源消耗（Mana）和冷却，确保玩家无法在资源不足时施放技能。

### 二、 技能消耗的实现原理 [01:26 - 02:45]

- **核心载体**：在 GAS 中，消耗（Cost）和冷却（Cooldown）本质上都是通过 **Gameplay Effect (GE)** 来实现的。
- **GE 设置**：
  - 持续策略（Duration Policy）设为**立即（Instant）**。
  - 添加修改器（Modifier），选择对应的属性（如 `Mana`）。
  - 操作方式选择**相加（Add）**，数值设为**负值**（例如 `-20`），代表扣除资源。

### 三、 在技能蓝图中配置并激活消耗 [02:45 - 05:40]

- **指定 GE**：在 `GA_Firebolt` 的类默认设置（Class Defaults）中，将创建好的消耗 GE 分配给 `Cost Gameplay Effect Class` 栏位。
- **提交技能（Commit Ability）**：
  - 在技能激活（Activate Ability）逻辑中，必须调用 **`Commit Ability`** 节点。
  - 该节点会自动检查资源是否足够并应用消耗（同时也处理冷却）。
  - **逻辑阻断**：如果 `Commit Ability` 失败（资源不足），后续逻辑将不会执行，技能仿佛从未激活过一样。

### 四、 C++ 底层解析：消耗与技能等级的关联 [05:40 - 08:45]

- **源码探究**：通过查看 `GameplayAbility.cpp` 源码发现，`ApplyCost` 函数在应用 GE 时会调用 `GetAbilityLevel()`。
- **结论**：消耗 GE 会自动根据当前**技能等级**来应用。这意味着可以使用“可缩放浮点数（Scalable Float）”根据等级动态调整蓝耗。

### 五、 实战练习：使用曲线表（Curve Table） [08:45 - 12:29]

- **创建曲线表**：
  - 创建 `Curve Table` 并命名为 `CT_Cost`。
  - 设置不同等级对应的消耗数值（如 1 级消耗 20，等级越高消耗越大）。
- **配置 GE 缩放**：
  - 在消耗 GE 中，将数值类型改为 `Scalable Float`。
  - 引用曲线表中的对应行，并将系数设为 `-1`（因为表中是正数，消耗需要负数）。
- **等级测试**：
  - 在 C++ 中临时修改 `AddCharacterAbilities` 时的技能等级（从 1 级改为 5 级）。
  - 运行游戏观察到 Mana 扣除量明显增加，证实了消耗随等级缩放的逻辑生效。

### 六、 总结与回顾 [12:29 - 12:54]

- **成果**：成功建立了基于等级缩放的技能蓝耗系统。
- **后续**：下一阶段将继续利用相似的 GE 机制来实现技能的**冷却（Cooldown）**。