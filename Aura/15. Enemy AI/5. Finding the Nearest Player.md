这段视频字幕详细讲解了如何在 C++ 中完善行为树服务（BT Service）的逻辑，通过算法计算并确定最近的玩家目标，并将其写入黑板，最终实现 AI 追踪玩家的功能。

以下是全部内容的标题大纲式详细总结：

------

### 一、 逻辑验证与初步调试

- **遍历标签 Actor**：通过 `for` 循环遍历带有特定标签（如 "Player"）的 Actor 数组。
- **屏幕调试信息**：使用 `GEngine->AddOnScreenDebugMessage` 在屏幕上实时打印搜索到的 Actor 名称，验证数组中是否包含玩家角色（Aura）。
- **确认搜索结果**：验证结果显示数组中确实包含玩家，为后续计算距离奠定了基础。

### 二、 C++ 变量与黑板键的映射

- **选择器命名规范**：在 C++ 中使用 `Selector` 后缀（如 `TargetToFollowSelector`）来命名变量，以区分 C++ 逻辑变量与黑板上的实际键（Key）。
- **建立链接**：展示了如何在虚幻引擎编辑器的详情面板中，手动将 C++ 定义的 `BlackboardKeySelector` 与黑板中对应的键进行关联（类似指针或引用）。
- **黑板键的灵活性**：强调了通过这些选择器，C++ 代码可以直接修改黑板上存储的数据。

### 三、 查找最近目标的算法实现

- **核心思路**：
  1. **初始化极值**：设置一个 `ClosestDistance` 浮点数，初始值设为 `TNumericLimits<float>::Max()`（浮点数的最大值）。
  2. **初始化目标指针**：创建一个 `ClosestActor` 指针，初始设为空（nullptr）。
- **循环对比逻辑**：
  - 遍历所有带标签的 Actor。
  - 增加安全性检查（使用 `IsValid` 检查 Pawn 和目标 Actor）。
  - 调用 `GetDistanceTo` 计算 AI 与目标之间的距离。
  - **动态更新**：如果当前计算的距离小于 `ClosestDistance`，则更新 `ClosestDistance` 为新值，并将 `ClosestActor` 指向该目标。

### 四、 在 C++ 中更新黑板值

- **引入函数库**：使用 `UbtFunctionLibrary`（行为树函数库）提供的静态函数。
- **写入数据**：
  - `SetBlackboardValueAsObject`：将计算出的最近 Actor 写入 `TargetToFollow` 键。
  - `SetBlackboardValueAsFloat`：将最短距离数值写入 `DistanceToTarget` 键。
- **执行频率**：该逻辑在 `TickNode` 中每 0.5 秒左右执行一次，平衡了性能与 AI 的反应速度。

### 五、 行为树测试：实现 AI 追踪

- **实时黑板观察**：运行游戏时，可以在行为树编辑器中实时看到黑板键的值随着玩家移动而不断更新。
- **添加 "Move To" 任务**：在行为树中添加引擎内置的 `Move To` 节点。
- **设置移动目标**：将 `Move To` 的目标黑板键设为 `TargetToFollow`。
- **Actor 类型的必要性**：解释了为什么移动目标必须是 Actor 或 Location 类型，因为它们具有世界坐标，而普通的 Object 类型没有。

### 六、 实验结果与后续优化方向

- **成功实现追踪**：AI 现在可以识别玩家并持续向玩家靠近。
- **发现意外行为**：
  - AI 可能会意外捡起场景中的药水（Overlap 冲突）。
  - AI 在追踪过程中会受到环境伤害（如站在火堆中掉血）。
  - 受击反应（Hit Reaction）逻辑生效：当 AI 被火球击中时，其最大移动速度设为 0，会暂时停止移动。
- **总结**：虽然 AI 的基本追踪逻辑已通，但仍需在后续视频中针对药水拾取、受击流畅度等细节进行“抛光”处理。