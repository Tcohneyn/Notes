这份视频字幕详细介绍了虚幻引擎（Unreal Engine）行为树中**选择器节点（Selector Node）**的工作原理，以及如何通过 C++ 创建一个自定义的**行为树服务（Behavior Tree Service）**来寻找最近的玩家。

以下是全部内容的详细标题大纲式总结：

------

### 一、 行为树基础：选择器节点 (Selector Node)

- **核心逻辑**：
  - **执行顺序**：从左到右依次执行其子节点（任务或子树）。
  - **成功中断机制**：只要有一个子节点返回“成功（Success）”，选择器就会立即停止执行后续子节点，并将“成功”信号向上返回给根节点，随后整棵树重新开始运行。
  - **失败继续机制**：如果当前子节点返回“失败（Failure）”，选择器才会尝试执行下一个子节点。
- **任务节点示例**：如 `Wait`（等待）、`Move To`（移动至）、`Play Animation`（播放动画）等。

### 二、 行为树服务 (BT Service) 概述

- **定义与位置**：服务是附加在复合节点（如选择器）或任务节点上的特殊节点。
- **执行频率**：
  - 不同于每帧执行的 `Tick`，服务以设定的**时间间隔（Interval）**运行（例如每 0.5 秒一次）。
  - 只要该节点所在的“分支（Branch）”处于活动状态，服务就会持续运行。
- **应用场景**：通常用于定期检查状态、寻找目标或更新黑板（Blackboard）变量，这种非每帧执行的方式极大优化了 AI 性能。

### 三、 C++ 自定义服务开发：寻找最近玩家

- **类创建**：
  - 基类选择：`UBTService_BlueprintBase`（选择此基类是为了方便在 C++ 中编写逻辑，同时保留在蓝图中扩展的能力）。
  - 类命名：`UBTService_FindNearestPlayer`。
- **关键函数重写 (TickNode)**：
  - 重写 `TickNode` 函数来实现自定义逻辑。
  - **参数介绍**：
    1. `OwnerComp`：拥有此行为树的组件引用。
    2. `NodeMemory`：节点内存指针。
    3. `DeltaSeconds`：自上次执行后的时间间隔。
- **访问拥有者信息**：
  - 通过内置的 `AIOwner` 获取 AI 控制器。
  - 通过 `ActorOwner` 获取受控的 Actor。

### 四、 蓝图配置与资源集成

- **创建蓝图子类**：基于 C++ 类创建 `BTService_FindNearestPlayer` 蓝图。
- **节点参数设置**：
  - **Node Name**：设置在行为树编辑器中显示的名称（如 "Find Nearest Player"）。
  - **Interval**：设置执行频率（如 0.5s）及其随机偏差（Random Deviation），防止大量 AI 在同一时间点执行逻辑。
- **关联行为树**：在行为树编辑器中右键点击选择器节点，通过 "Add Service" 将自定义服务挂载上去。

### 五、 调试与验证

- **C++ 调试信息**：使用 `GEngine->AddOnScreenDebugMessage` 在屏幕上输出 `AIOwner` 和 `ActorOwner` 的名称。
- **蓝图触发逻辑**：视频中提到一个细节，在使用 `UBTService_BlueprintBase` 作为基类时，可能需要在蓝图中保留 `ReceiveTickAI` 事件节点，才能确保 C++ 的 `TickNode` 正常被调用。
- **运行结果**：启动游戏后，可以看到 AI 控制器名称以设定的频率（每 0.5s）在屏幕上持续跳动，证明服务已成功运行。

------

**核心总结**：本节课实现了 AI 控制逻辑的“感知层”基础。通过建立一个低频触发的服务节点，AI 现在拥有了定期检索战场信息（如寻找最近玩家）的能力，这比直接在 `Tick` 中检索要高效得多。