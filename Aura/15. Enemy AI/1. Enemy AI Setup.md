这份视频字幕标志着游戏开发进入了**敌人AI（人工智能）系统**的构建阶段。视频主要介绍了为何需要AI、为何选择行为树（Behavior Tree）以及实现AI控制的逻辑架构。

以下是全部内容的详细标题大纲式总结：

### 一、 敌人AI开发的背景与动机

- **开发阶段回顾**：已完成属性系统和基础技能（如Firebolt火球术、敌人的受击反应）。
- **功能扩展需求**：敌人不能只停留于“受击”，需要具备主动性。
  - **主动行为**：追踪玩家、发动攻击。
  - **游戏性闭环**：玩家杀死敌人后应获得经验值（XP）、升级并获得奖励。
- **逻辑核心**：敌人需要一种“做决策”的能力，根据战场情况处理逻辑。

### 二、 行为树（Behavior Tree）的优势

- **逻辑封装**：行为树能将复杂的AI逻辑封装在可视化的树状蓝图中，清晰展示AI的控制流。
- **系统交互性**：
  - 通过接口（Interface）调用函数。
  - 发送 **Gameplay Events** 触发 **GAS（技能系统）** 技能。
- **灵活性与复用性**：不同的敌人可以共用同一个行为树，也可以轻松更换特定的行为树资源，实现差异化行为。

### 三、 AI 控制系统的技术架构

- **AI Controller（AI控制器）**：作为敌人的“大脑”，负责拥有和管理核心组件。
- **核心组件关系**：
  - **Behavior Tree Component（行为树组件）**：运行具体逻辑的容器。
  - **Blackboard Component（黑板组件）**：作为AI的“记忆体”，存储逻辑运行所需的数据（如玩家位置、状态等）。
- **职责分配**：
  - **AI控制器**：持有黑板和行为树组件。
  - **敌人角色（AuraEnemy）**：持有具体的行为树资产（Asset）引用。
  - **初始化逻辑**：敌人角色需告知AI控制器去运行其特定的行为树资产。

### 四、 后续实施步骤（Roadmap）

1. **创建 AI Controller 类**：在 C++ 中构建基础控制器类。
2. **创建资源资产**：在编辑器中创建行为树（Behavior Tree）和黑板（Blackboard）资源。
3. **配置组件**：向 AI Controller 添加黑板组件和行为树组件。
4. **关联敌人资产**：在 `AuraEnemy` 中添加行为树引用变量，并支持在蓝图中配置。
5. **启动 AI 逻辑**：调用 `RunBehaviorTree` 函数，正式让 AI 开始控制敌人行为。

------

**核心总结**：本节视频为敌人从“木桩”进化为“动态对手”奠定了理论和架构基础，重点在于利用虚幻引擎的行为树架构配合 GAS 系统，实现可扩展且灵活的 AI 逻辑。