这份视频字幕详细介绍了如何在 Unreal Engine 5 的 **Gameplay Ability System (GAS)** 中，将抗性属性（Resistances）集成到伤害计算组件（Execution Calculation）中。

以下是全部内容的详细标题大纲式中文总结：

------

### 一、 伤害计算逻辑的升级目标

- **背景回顾**：目前已在 `CalcDamage` 中通过 `SetByCaller` 获取了基础伤害数值。
- **核心任务**：将新创建的抗性属性（火、电、秘法、物理）引入计算公式，使目标的抗性能减少对应的伤害。
- **实现位置**：在 C++ 的 `ExecCalc_Damage` 类中进行修改。

------

### 二、 属性捕获（Attribute Capture）的配置

在 `DamageStatics` 结构体中添加样板代码，以便捕获抗性数值：

- **定义捕获定义（Capture Definitions）**：
  - 为 **火（Fire）**、**闪电（Lightning）**、**秘法（Arcane）** 和 **物理（Physical）** 分别创建捕获定义变量。
  - **关键设置**：必须从 **Target（目标）** 处捕获，且通常不使用快照（Snapshot）。
- **注册属性**：将这四个抗性定义添加到 `RelevantAttributesToCapture` 数组中，告知系统在计算时需要提取这些数据。

------

### 三、 标签与捕获定义的映射（Tags to Capture Defs Map）

为了避免为每种抗性编写重复的硬编码逻辑，引入了通用的映射机制：

- **创建 TMap**：在 `AuraDamageStatics` 中建立一个从 `FGameplayTag`（属性标签）到 `FGameplayAttributeCaptureDefinition`（捕获定义）的映射表。
- **构造函数初始化**：在构造函数中，通过样板代码将所有的次要属性（防御力等）和抗性属性标签与它们的捕获定义一一对应。
- **设计意义**：通过这种映射，后续可以使用循环（For Loop）根据伤害类型自动查找对应的抗性，极大提高了代码的可扩展性。

------

### 四、 伤害计算循环中的抗性应用

在伤害计算的核心循环（Looping through Damage Types）中实现以下逻辑：

- **获取抗性标签**：通过当前循环的伤害类型，在 `DamageTypesToResistances` 映射中找到对应的抗性标签。
- **提取属性值**：
  - 使用 `TagsToCaptureDefs` 查找该抗性标签对应的捕获定义。
  - 调用 `AttemptCalculateCapturedAttributeMagnitude` 提取目标当前的抗性数值。
- **安全性校验**：加入 `checkf` 断言和崩溃日志（Crash Log），确保如果某个抗性标签未注册，开发者能立即发现错误。

------

### 五、 减伤数学公式与限制

- **数值钳制（Clamping）**：将提取出的抗性数值限制在 **0 到 100** 之间。
- **计算公式**：
  - 假设每 1 点抗性代表 1% 的减伤。
  - **公式**：`最终伤害 = 基础伤害 * (100 - 抗性) / 100`。
  - 例如：抗性为 10，则伤害乘以 0.9，相当于减少了 10% 的伤害。
- **累加计算**：处理完单种伤害类型的抗性减免后，将其累加到总伤害值中。

------

### 六、 测试与调试验证

- **断点调试**：在 C++ 中设置断点，观察 fireball（火球术）命中敌人时，系统如何循环识别不同的伤害类型。
- **测试配置**：
  - 由于敌人默认抗性为 0，创建一个测试用的 Gameplay Effect，手动为敌人赋予 **50 点火抗（Fire Resistance）**。
- **验证结果**：
  - 原本造成 10 点伤害的火球，现在只造成 5 点伤害（减少了 50%）。
  - 验证了系统能够正确区分伤害类型并应用对应的抗性减免。

------

### 七、 总结与展望

- **系统灵活性**：目前的框架不仅适用于玩家，也适用于敌人。虽然玩家的抗性在 UI 中可见，但敌人的抗性同样在后台生效。
- **后续工作**：尽管系统已就绪，但由于属性之间存在复杂的数学关联（如韧性影响抗性），后续需要根据实际手感进行精细的数值平衡调整。