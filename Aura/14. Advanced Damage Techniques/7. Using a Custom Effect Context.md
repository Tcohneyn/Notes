这段视频深入探讨了如何利用之前创建的自定义 **Gameplay Effect Context** 来传递战斗信息（如“格挡”和“暴击”），并将其从底层的伤害计算传递到前端的视觉表现（飘字伤害）。

以下是内容的标题大纲式详细总结：

------

### 一、 在伤害执行计算 (ExecCalc) 中设置自定义数据

- **定位关键环节**：`UExecCalc_Damage` 是计算格挡（Blocked）和暴击（Critical）逻辑的地方，因此也是设置这些布尔值的最佳时机。
- **获取上下文句柄**：通过 `EffectSpec.GetContext()` 获取当前的 `FGameplayEffectContextHandle`。
- **C++ 中的类型转换 (Static Cast)**：
  - 默认的 `Handle.Get()` 返回的是基类指针。
  - 必须使用 `static_cast<FAuraGameplayEffectContext*>` 将其转换为自定义类型，才能访问新增的 `SetIsBlockedHit` 等函数。

### 二、 封装蓝图函数库 (AuraAbilitySystemLibrary)

为了简化操作并让蓝图也能使用这些功能，讲师在函数库中创建了静态辅助函数：

1. **获取器 (Getters)**：
   - 函数：`IsBlockedHit` 和 `IsCriticalHit`。
   - 标记为 `BlueprintPure`，方便在蓝图中直接读取。
   - **内部逻辑**：内部执行 `static_cast`，如果转换失败则安全返回 `false`。
2. **设置器 (Setters)**：
   - 函数：`SetIsBlockedHit` 和 `SetIsCriticalHit`。
   - 标记为 `BlueprintCallable`，因为它们会产生副作用（修改数据）。

### 三、 关键技术点：解决蓝图输入引脚问题 (UPARAM)

- **默认行为**：在虚幻引擎中，函数参数如果是“非常量引用”（Non-const Reference），蓝图节点会默认将其识别为**输出引脚**。
- **解决方案**：在参数前添加 `UPARAM(ref)` 宏。
- **视觉变化**：添加该宏后，引脚在蓝图中会从圆形的输出点变为**菱形的输入/输出点**，确保开发者能将现有的 Context Handle 传入函数进行修改。

### 四、 完善数据流转管道 (The Pipeline)

讲师演示了数据是如何跨越不同类进行传递的：

1. **ExecCalc (生产者)**：调用库函数 `SetIsBlockedHit(Handle, bBlocked)`。
2. **AttributeSet (消费者)**：在 `PostGameplayEffectExecute` 阶段：
   - 使用库函数 `IsBlockedHit(Handle)` 提取布尔值。
   - 将这些布尔值传递给 `ShowFloatingText` 函数。
3. **视觉层 (视觉表现)**：`ShowFloatingText` 现在接收到了“是否格挡”和“是否暴击”的信息，为后续根据结果改变文字颜色（如暴击显红色）做好了准备。

### 五、 调试与验证

- **修改测试数据**：在 `SecondaryAttributes` 的数据资产中，将敌人的“格挡几率”修改为 **100%**。
- **断点检查**：运行调试模式并攻击敌人。
- **结果证明**：在 `AttributeSet` 的断点处，成功观察到 `bIsBlockedHit` 变为 `true`。这证明自定义数据已经成功通过 GAS 的 Effect 管道完整地从攻击方传递到了受击方。

### 六、 总结与优势

- **代码整洁**：通过函数库封装，避免了在属性集和执行计算类中到处写 `static_cast`。
- **架构解耦**：属性集不再需要关心具体的计算过程，只需通过 Context Handle 询问“这一下出暴击了吗？”。
- **蓝图友好**：非程序员也能在蓝图能力脚本中轻松设置或读取这些高级战斗状态。

------

核心里程碑：

本节课完成了“数据埋点”到“数据提取”的完整闭环，标志着自定义 GAS 数据同步系统的正式启用。