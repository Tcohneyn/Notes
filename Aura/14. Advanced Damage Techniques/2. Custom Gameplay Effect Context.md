在这段视频中，讲师详细演示了如何在虚幻引擎的 **Gameplay Ability System (GAS)** 中通过 C++ 创建一个自定义的 **Gameplay Effect Context** 结构体，以便在效果传递过程中携带更多自定义信息（如暴击、格挡等）。

以下是内容的标题大纲式详细总结：

------

### 一、 自定义 Context 的动机与文件准备

- **扩展需求**：原生 `FGameplayEffectContext` 功能有限，无法记录特定项目的逻辑数据。本课目标是添加“是否暴击”和“是否格挡”的布尔值。
- **新建类型文件**：
  - **头文件**：在 `Public` 文件夹创建 `AuraAbilityTypes.h`，用于存储所有自定义能力系统相关的类型。
  - **源文件**：在 `Private` 文件夹创建 `AuraAbilityTypes.cpp`，处理函数定义。
- **基础配置**：添加 `pragma once` 防止重复包含，并引入必要的生成的头文件（`.generated.h`）。

### 二、 结构体定义与继承关系

- **继承原生类**：定义 `FAuraGameplayEffectContext`，并公开继承自原生结构体 `FGameplayEffectContext`。
- **宏与反射系统**：
  - 使用 `USTRUCT(BlueprintType)` 宏使其能暴露给蓝图。
  - 使用 `GENERATED_BODY()` 生成样板代码。
  - 尽管结构体成员默认公开，讲师仍显式划分了 `public` 和 `protected` 区域以提高代码可读性。

### 三、 必须重写的两个关键虚函数

为了让自定义结构体在 GAS 系统中正常运作，必须重写两个核心函数：

1. **GetScriptStruct()**：
   - **作用**：返回该结构体的 `UScriptStruct`（类似于 UObject 的 `StaticClass`）。
   - **重要性**：它是结构体在引擎**反射系统**中的“身份证”，允许引擎识别并处理这个特定的派生类型。
   - **实现**：简单调用并返回 `StaticStruct()`。
2. **NetSerialize() (网络序列化)**：
   - **作用**：定义该结构体如何转换成二进制流（比特）在网络上传输，或者在保存游戏时进行序列化。
   - **参数解析**：
     - `FArchive& Ar`：核心对象，用于读取或写入数据流。
     - `UPackageMap* Map`：用于处理对象引用的映射。
     - `bool& bOutSuccess`：返回序列化是否成功。
   - **状态**：目前仅搭建了重写框架并返回 `true`，具体的“魔法逻辑”将在下节课深入讨论。

### 四、 添加自定义数据字段与访问器 (Getters & Setters)

讲师在 `protected` 区域添加了具体的逻辑变量，并在 `public` 区域提供接口：

- **成员变量**：
  - `bIsCriticalHit`：记录是否为暴击。
  - `bIsBlockedHit`：记录是否被格挡。
  - 均初始化为 `false`。
- **访问器实现**：
  - **Getters**：如 `IsCriticalHit()`，标记为 `const` 确保安全访问。
  - **Setters**：如 `SetIsCriticalHit(bool bInIsCritical)`，用于在计算逻辑中修改状态。

### 五、 源码解析与未来展望

- **原生 NetSerialize 分析**：讲师简要展示了原生 `FGameplayEffectContext::NetSerialize` 的实现。它通过判断 `Ar.IsSaving()` 来决定是向归档写入数据（发送）还是从中读取数据（接收）。
- **后续计划**：目前的代码虽已通过编译，但尚未实现自定义字段的网络传输逻辑。下一节课将深入探讨如何手动编写 `NetSerialize` 的内部代码，以确保“暴击”和“格挡”等自定义信息能准确地在服务器和客户端之间同步。

------

**核心总结图示：**