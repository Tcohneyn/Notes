这段视频讲解了如何将自定义的 `GameplayEffectContext` 注入到虚幻引擎 GAS 系统中，使其在整个项目中生效。这是实现自定义战斗逻辑（如暴击、格挡）并在属性集中提取这些数据的关键步骤。

以下是内容的标题大纲式详细总结：

------

### 一、 核心任务：从“定义”转向“应用”

- **现状回顾**：已创建 `FAuraGameplayEffectContext` 结构体，并实现了网络序列化（NetSerialize）和特征声明（Struct Ops Traits）。
- **当前问题**：虽然定义了类，但 GAS 系统默认仍在使用原生的上下文类。
- **解决目标**：告诉项目全局使用我们自定义的 `AuraGameplayEffectContext`。

### 二、 自定义 Ability System Globals 类

为了改变全局 GAS 行为，需要子类化 `AbilitySystemGlobals`：

- **类名定义**：创建名为 `UAuraAbilitySystemGlobals` 的 C++ 类。
- **Globals 类的作用**：它管理 GAS 的全局变量、插件配置以及某些核心对象的分配逻辑。
- **关键函数重写**：
  - **`AllocGameplayEffectContext()`**：这是系统分配新上下文对象的入口。
  - **实现逻辑**：在重写的函数中返回 `new FAuraGameplayEffectContext()`。
  - **原理说明**：当调用 `MakeEffectContext` 时，系统底层会调用此分配器，由于返回了自定义子类，后续所有创建的句柄（Handle）都将持有我们的自定义数据。

### 三、 项目配置文件（DefaultGame.ini）的设置

仅仅编写代码是不够的，必须在配置文件中指定该全局类：

- **修改位置**：项目的 `Config/DefaultGame.ini`。

- **配置项添加**：

  Ini, TOML

  ```
  [/Script/GameplayAbilities.AbilitySystemGlobals]
  AbilitySystemGlobalsClassName="/Script/Aura.AuraAbilitySystemGlobals"
  ```

- **注意事项**：

  - 路径格式需包含模块名（如 `Aura`）。
  - 必须在编辑器关闭的情况下修改并保存。

### 四、 调试与验证（Breakpoint Verification）

讲师通过调试模式证明了配置的成功：

- **断点观察**：在 `AuraProjectileSpell` 创建上下文的地方设置断点。
- **数据检查**：观察 `EffectContextHandle` 中的 `Data` 指针。
- **结果确认**：在调试窗口中可以直接看到 `bIsBlockedHit` 和 `bIsCriticalHit` 两个新增布尔值。这证明系统已经成功实例化了自定义结构体。

### 五、 实际应用场景：属性集（Attribute Set）

一旦全局生效，这些数据可以在 GAS 管道的任何地方被提取：

- **提取位置**：例如在 `AuraAttributeSet` 的 `PostGameplayEffectExecute` 函数中。
- **逻辑扩展**：
  - 通过 `EffectProperties` 获取上下文句柄。
  - 检查是否为“暴击”或“格挡”。
- **视觉呈现**：可以根据这些布尔值改变**飘字伤害（Floating Damage Text）**的颜色（例如：格挡显示蓝色，暴击显示红色）。

### 六、 总结与里程碑意义

- **灵活性提升**：现在可以向上下文类中添加任何自定义数据（不仅限于布尔值），并确保它们能跨网络同步。
- **架构完善**：通过自定义 Globals 类，项目获得了对 GAS 底层对象分配的完全控制权。
- **下一步计划**：学习如何通过代码正确地设置（Set）这些数据，而不仅仅是读取（Get）。

------

技术要点总结表：

| 步骤 | 操作对象 | 核心操作 |

| :--- | :--- | :--- |

| 1. 分配器 | AllocGameplayEffectContext | 返回 new 出来的自定义结构体实例 |

| 2. 引擎映射 | DefaultGame.ini | 注册自定义的 Globals 类路径 |

| 3. 属性集交互 | EffectContextHandle | 转换并读取自定义布尔标志位 |