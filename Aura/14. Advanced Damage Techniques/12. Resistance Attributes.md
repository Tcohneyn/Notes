这份视频字幕详细记录了在 Unreal Engine 5 的插件式开发中，如何通过 **C++ 和蓝图** 为角色增加“抗性属性（Resistance Attributes）”并集成到 UI 菜单的完整过程。

以下是全部内容的详细标题大纲式总结：

------

### 一、 任务目标与挑战概述

- **核心任务**：创建四个抗性属性：**火（Fire）**、**闪电（Lightning）**、**秘法（Arcane）** 和 **物理（Physical）**。
- **属性定位**：将抗性设计为“次要属性（Secondary Attributes）”，即它们的数值基于其他基础属性（如韧性 Resilience）计算得出。
- **集成目标**：完成底层代码后，需同步更新属性菜单 UI，使玩家能直观查看数值变化。

------

### 二、 C++ 层面的底层属性构建

在 `AuraAttributeSet` 类中完成以下样板代码（Boilerplate）：

- **属性声明**：
  - 定义四个 `FGameplayAttributeData` 类型的变量。
  - 使用宏生成属性访问器（Accessors）和 `OnRep` 回调声明。
- **同步与通知（RepNotifies）**：
  - 在 `.cpp` 中实现 `OnRep` 函数，确保在网络环境下属性更新能正确同步。
  - 在 `GetLifetimeReplicatedProps` 中注册这四个新属性。
- **标签映射（Gameplay Tags Mapping）**：
  - 将 **Gameplay Tags**（如 `Attributes.Resistance.Fire`）映射到对应的 **属性访问器**。
  - 这是数据驱动 UI 的关键步骤，确保 UI 能通过标签找到正确的数值。

------

### 三、 游戏效果（Gameplay Effect）逻辑配置

在 Unreal 编辑器中配置 `GE_SecondaryAttributes`，确定抗性的数学公式：

- **依赖关系**：选择 **韧性（Resilience）** 作为抗性属性的底层支撑。
- **系数设定**：
  - **基础值（Post-multiply Additive）**：设置为 **3.0**。
  - **系数（Coefficient）**：设置为 **0.5**（即每增加 1 点韧性，增加 0.5 点抗性）。
- **设计思路**：通过将抗性挂钩到韧性，增加了韧性属性的价值，使其对生存能力的影响更加多元化。

------

### 四、 UI 界面集成与重构

在属性菜单（Attribute Menu）中展示新属性：

- **UI 行添加**：
  - 在 `WBP_AttributeMenu` 的滚动框中，通过复制现有属性行创建四个新行（Row）。
  - 重命名为对应的抗性行。
- **标签绑定逻辑**：
  - 在蓝图图中，为每个 UI 行分配对应的抗性 Gameplay Tag。
- **代码清理与重构**：
  - 将原本臃肿的标签设置节点折叠为三个清晰的子函数：
    1. `SetPrimaryAttributeTags`（设置主要属性标签）
    2. `SetSecondaryAttributeTags`（设置次要属性标签）
    3. `SetResistanceAttributeTags`（设置抗性属性标签）

------

### 五、 数据驱动信息完善

通过数据资产（Data Asset）定义 UI 显示内容：

- **更新 `DA_AttributeInfo`**：
  - 为四个抗性添加条目。
  - 设置 **显示名称**（如 "Fire Resistance"）和 **属性描述**（说明该属性如何减少对应伤害）。
- **结果验证**：只有在数据资产中填充了信息，UI 菜单才不会显示默认的“Attribute”占位文本，而是显示正确的名称。

------

### 六、 测试验证与架构总结

- **实时更新**：在游戏中提升韧性，观察 UI 中的四个抗性数值是否同步按 0.5 的比例提升。
- **架构优势**：
  - 由于之前的 **Widget Controller** 架构设计稳健（解耦良好），本次增加属性**完全不需要修改 C++ 逻辑层**（控制器代码），只需更新数据配置即可。
- **后续计划**：目前抗性仅有数值显示，下一阶段将把这些抗性数值引入到战斗伤害计算公式中，实现真正的减伤效果。

------

**您是否需要我为您列出在 C++ 中添加这些属性所需的具体宏代码示例？**