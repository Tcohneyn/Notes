这篇字幕主要讲述了在游戏开发中实现**击退（Knockback）**功能的详细过程，包括逻辑定义、参数设置、数据传输以及最终的物理触发。

以下是该段字幕的详细总结大纲：

### 一、 击退功能的逻辑定义

- **功能描述**：当敌人受到非致命伤害时，将其发射到空中，类似于死亡冲量（Death Impulse）但用于非死亡状态 。
- **触发条件**：
  - 伤害必须是非致命的（非 fatal） 。
  - 通过“击退概率”（Knockback Chance）参数进行随机判定，并非每次攻击都会触发 。
- **技术实现建议**：推荐使用 `LaunchCharacter` 函数而非 `AddImpulse`，因为前者无需开启物理模拟或布娃娃系统即可实现角色位移 。

### 二、 参数与数据结构配置

- **新增能力参数** (`AuraDamageGameplayAbility`)：

  - **KnockbackForceMagnitude**：击退强度，默认值设为 1000（原设定的 60 太低） 。

  - **KnockbackChance**：击退概率，默认为 0，需手动开启 。

    

- **伤害结构体更新** (`DamageEffectParams`)：

  - 添加击退强度（Magnitude）和击退力向量（Vector） 。

    

  - 添加击退概率参数 。

    

- **效果上下文同步** (`EffectContext`)：

  - 在效果上下文中添加 `KnockbackForce` 字段 。

    

  - 更新 `NetSerialize`（网络序列化），确保击退数据能在网络中正确传输（涉及第 15 位比特位的翻转与序列化） 。

    

  - 为上下文添加 Getter 和 Setter 访问器 。

    

### 三、 核心代码实现逻辑

1. **库函数封装** (`AuraAbilitySystemLibrary`)：封装设置和获取击退力的静态函数，方便在不同类中调用 。

   

2. **发射物逻辑处理** (`AuraProjectile`)：

   - **随机判定**：通过 `FMath::RandRange(1, 100)` 生成随机数，判断是否小于击退概率 。

     

   - **计算方向**：如果判定成功，根据当前发射物的前向向量（Forward Vector）计算击退力 。

     

   - **优化视觉**：建议对击退方向进行俯仰角（Pitch）旋转，使敌人向上飞起，视觉效果更佳 。

     

3. **属性集响应** (`AuraAttributeSet`)：

   - 在处理传入伤害（`HandleIncomingDamage`）的逻辑中，找到非致命伤害的分支 。

     

   - 检查击退力是否接近零（使用容差判断） 。

     

   - **执行击退**：直接调用目标角色的 `LaunchCharacter` 函数，传入计算好的速度向量 。

     

   - **轴向控制**：通过 `LaunchCharacter` 的布尔参数（XYOverride 和 ZOverride）控制是否覆盖角色原有的水平或垂直速度 。

     

### 四、 开发总结

- 击退功能的实现涉及从 UI 配置到底层物理触发的完整流水线 。

  

- 通过将击退力集成到现有的伤害流程（EffectContext）中，可以保持代码结构的一致性 。

  

  