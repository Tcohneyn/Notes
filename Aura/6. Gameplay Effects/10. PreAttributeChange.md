# 视频总结：PreAttributeChange 与属性值 Clamping

## 1. 问题背景

- 当前属性（Health、Mana）可以超出上限或降到负数。
- 没有任何 Clamping（数值限制）。

## 2. Clamping 的一种方法：PreAttributeChange

- 在 **AttributeSet** 中重写 `PreAttributeChange` 函数。
- 该函数在属性值实际改变 **之前** 被调用。
- 参数：
  - `GameplayAttribute`：正在被修改的属性。
  - `float& NewValue`：新值（可修改，因为是引用传入）。
- Epic 官方推荐：**只在这里做 Clamping，不要做复杂逻辑或事件触发**。

## 3. 使用方法

- 比较传入的 `GameplayAttribute` 是否等于目标属性（如 Health、Mana）。
- 使用 `FMath::Clamp(NewValue, 0, MaxValue)` 来限制属性范围。
  - Health 限制在 `[0, MaxHealth]`。
  - Mana 限制在 `[0, MaxMana]`。

## 4. Debug 与测试

- Potion（药水）= **Instant Gameplay Effect** → 永久改变 Base Value。
- Crystals（水晶）、Fire Area = **Duration + Periodic** → 本质上也永久改变 Base Value。
- 在 Debug Log 中验证：
  - Mana 不会超过 MaxMana（50）。
  - Health 不会超过 MaxHealth，也不会小于 0。

## 5. PreAttributeChange 的局限性

- 它在修改前调用，但 **最终值会在后续重新计算**。
- 因此，PreAttributeChange 并不是“最终” Clamping 的最佳位置。
- 如果要保证最终数值被限制，需要用到 **PostGameplayEffectExecute**（下个视频讲解）。