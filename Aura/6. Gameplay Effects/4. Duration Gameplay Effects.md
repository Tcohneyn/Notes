## Duration Gameplay Effect 

### 1. Instant Gameplay Effect 回顾

- C++ 实现：
  - 获取目标的 **AbilitySystemComponent (ASC)**
  - 创建 **EffectContext**
  - 添加 **SourceObject** (仅 C++ 可调用，Blueprint 无法直接调用)
  - 创建 **Outgoing Spec**
  - 调用 `ApplyGameplayEffectSpecToSelf` 应用效果
- Blueprint 实现：
  - `GetAbilitySystemComponent(Actor)`
  - `MakeEffectContext`
  - `MakeOutgoingSpec` (传入 GameplayEffectClass, Level, Context)
  - `ApplyGameplayEffectSpecToSelf`
  - 逻辑更简洁，但功能不如 C++ 全面

------

### 2. Blueprint 的局限

- 某些函数（如 `AddSourceObject`、`GetSourceObject`）**非 BlueprintCallable**
- 需要通过 **AbilitySystemBlueprintLibrary** 里的静态函数间接访问
- 可以自建 **Blueprint Function Library** 来暴露更多 C++ 功能给 Blueprint

------

### 3. 为什么用 C++？

- Blueprint 虽然更简洁，但节点会堆积 → 难以管理
- C++ 可以：
  - 暴露自定义节点
  - 提供更完整的 API
  - 保持 Blueprint 面板干净，只留一个函数调用

------

### 4. Gameplay Effect Duration Policy

GameplayEffect 有三种持续时间类型：

1. **Instant** → 立刻生效，立刻结束
2. **Has Duration** → 有时长，自动到期失效
3. **Infinite** → 一直存在，直到手动移除

------

### 5. 示例：Crystal Heal (Has Duration)

- 新建 `G_CrystalHeal` GameplayEffect
- 设置 **Duration Policy = Has Duration**
- Duration Magnitude = **2 秒**
- 修改 MaxHealth：+100
- 效果：
  - 原本 MaxHealth = 100 → 临时变成 200 (持续 2 秒)
  - 当前 Health 不变 → 看起来血条百分比下降
  - 2 秒后恢复原状

------

### 6. Blueprint 应用 Duration Effect

- 新建 Blueprint：`BP_HealthCrystal` (继承 AuraEffectActor)
- 设置 `DurationGameplayEffectClass = CrystalHeal`
- OnOverlap → `ApplyEffectToTarget`
- 传入 **OtherActor** + **DurationEffect**
- 最后 `DestroyActor`

------

### 7. 测试效果

- 拾取水晶 → MaxHealth 变成 200 → 血条下降
- 2 秒后 → 自动恢复到 100
- 不需要额外 Timer，GE 系统自动管理时效

------

👉 结论：

- **Instant 适合一次性效果**（如回血、加蓝）
- **Has Duration 适合 Buff/Debuff**（临时加速、加血上限）
- Blueprint 简单快速，但受限 → **推荐复杂逻辑写在 C++，Blueprint 只负责调用**

·