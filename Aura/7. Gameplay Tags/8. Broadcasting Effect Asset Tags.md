# 使用 Delegate 广播 Asset Tags 并在 WidgetController 中绑定

## 1. 需求与目标

- **现状**：我们能获取 Gameplay Effect 的 Asset Tags。
- **目标**：这些 Tags 需要广播到 **WidgetController**。
- **解决方案**：使用 **Delegate**。

------

## 2. 在 Ability System Component 中定义 Delegate

- **Delegate 类型**：Multicast Delegate（非动态）。

- **参数**：

  - 可选择单个 **Gameplay Tag** 或一个 **Gameplay Tag Container**。
  - 实际使用：**const FGameplayTagContainer&**。

- **命名**：`FEffectAssetTags`。

- **可见性**：

  - 需要 **public**，因为 WidgetController 要绑定。

- **广播时机**：

  - 在 `EffectApplied` 时调用：

    ```cpp
    EffectAssetTags.Broadcast(TagContainer);
    ```

------

## 3. WidgetController 绑定 Delegate

- **绑定位置**：`OverlayWidgetController::BindCallbacksToDependencies`。
- **步骤**：
  1. 将 AbilitySystemComponent **转换为 AuraAbilitySystemComponent**。
  2. 访问 `EffectAssetTags`。
  3. 使用 **Lambda** 绑定回调。

------

## 4. 使用 Lambda 简化回调

- **Lambda 特点**：
  - 匿名函数，不需要单独声明成员函数。
  - 适合简单逻辑。
- **Lambda 签名**：
  - 输入参数：`const FGameplayTagContainer& AssetTags`。
  - 函数体：循环遍历 `AssetTags`，打印 Debug 信息。
- **优势**：
  - 避免声明一堆单独的回调函数。
  - 代码更简洁、直观。

------

## 5. Debug 验证流程

- **准备工作**：
  - Potion Mana 含有 **2 个 Tags**。
  - Potion Heal 含有 **1 个 Tag**。
  - Crystal Heal 含有 **1 个 Tag**。
- **验证步骤**：
  - 运行游戏 → 拾取物品 → 打印对应 Tags。
  - 在 Lambda 中成功输出 Debug 信息。
- **额外验证**：
  - 设置断点，确认 Lambda 回调被触发。

------

## 6. 总结与扩展

- **结果**：
  - AbilitySystemComponent **广播 Tags**。
  - WidgetController **接收并处理 Tags**（通过 Lambda）。
- **意义**：
  - 简化了 Delegate 回调逻辑。
  - 更加灵活，可扩展到其他 UI 更新逻辑。
- **下一步**：
  - 将 Asset Tags 从 **WidgetController** 传递到具体 Widgets。

