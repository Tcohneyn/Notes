# 从数据表中检索行

## 一、回顾与数据表设置

- 打开蓝图中新建的数据表 **UI Data**
- 已添加一行但尚未填写内容
- 项目中新增了四个新的 **Gameplay Tags**

## 二、第一行数据配置（Health Crystal）

- 设置 **Message Tag**：`message.health_crystal`
- 设置 **Row Name** 与标签一致：`message.health_crystal`
- 指定 **Message 文本**：Picked up a health crystal
- 指定 **图片**：`T_HealthCrystal`
- 注意：此方法依赖**名称匹配**，容易因拼写错误而出错
- 作者习惯更常用 **Data Assets**，但这里演示 **Data Tables**

## 三、继续添加四行数据

1. **Health Potion**
   - Row Name：`message.health_potion`
   - Message：Picked up a health potion
   - 图片：`T_Potion_Red`
2. **Mana Crystal**
   - Row Name：`message.mana_crystal`
   - Message：Picked up a mana crystal
   - 图片：`T_ManaCrystal`
3. **Mana Potion**
   - Row Name：`message.mana_potion`
   - Message：Picked up a mana potion
   - 图片：`T_Potion_Blue`

- 最终统一调整：所有文本前都加上 **“Picked up a …”** 保持一致
- 四行数据完整配置，Row Name 与 Tag 完全对应

## 四、在 Gameplay Effect 中应用标签

- 打开蓝图目录 `Actor/Crystal` 与 `Actor/Potion`
- 修改对应的 **Gameplay Effect**：
  1. `G_Potion_Heal` → 添加 `message.health_potion`
  2. `G_Potion_Mana` → 添加 `message.mana_potion`
  3. `Crystal_Heal` → 添加 `message.health_crystal`
  4. `Crystal_Mana` → 添加 `message.mana_crystal`
- 清除旧标签，重新编译后可见新标签已生效
- Play 测试 → 拾取物品能成功触发对应消息标签

## 五、准备在 C++ 中查找数据表行

- 当前在 **Overlay Widget Controller** 内进行逻辑处理
- 在 Lambda 中接收 **Gameplay Tag Container**（Asset Tags）
- 原先仅是 **打印消息**，现在要实现：
  - **通过 Tag 查找数据表行并返回结果**

## 六、实现通用函数 GetDataTableRowByTag

- 在头文件中定义 **模板函数**：
  - 泛型类型 `T*`（可返回任意数据表行类型指针）
  - 输入：`UDataTable*` 与 `FGameplayTag`
  - 调用 `DataTable->FindRow<T>(Tag.GetTagName(), Context, true)`
  - 返回对应行（若不存在返回 `nullptr`）
- 模板函数通常写在头文件中
- 这种函数更适合放入 **静态函数库**（而非单一 Controller）

## 七、在 Lambda 中使用模板函数

- 调用：`GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag)`
- 注意：Lambda 需要 **捕获 this** 才能调用成员函数
  - 在方括号 `[this]` 中捕获当前对象
- 成功后即可获取 `FUIWidgetRow* row`
- 下一步：将数据通过 **委托（Delegate）广播到 Widget**

