# 绑定 GameplayEffect 应用委托回调

## 1. 委托基础

- **目标委托**：OnGameplayEffectAppliedDelegateToSelf
- **函数签名**：
  - UAbilitySystemComponent*（能力系统组件指针）
  - FGameplayEffectSpec（效果规格）
  - FActiveGameplayEffectHandle（效果句柄）
- **特点**：当 GameplayEffect 应用到自身时，广播并传递这三个参数给回调函数。

------

## 2. 定义回调函数

- **函数位置**：AuraAbilitySystemComponent.h
- **访问权限**：protected
- **函数原型**：`void EffectApplied(UAbilitySystemComponent* ASC, const FGameplayEffectSpec& Spec, FActiveGameplayEffectHandle Handle)`
- **参数命名**：为了可读性，给参数加上描述性名字（abilitySystemComponent, effectSpec, activeEffectHandle）。

------

## 3. 绑定时机

- **不在构造函数**：构造阶段太早。
- **合适时机**：AbilityActorInfo 初始化之后。
- **方法**：
  1. 在 AuraCharacterBase 中声明虚函数 `InitAbilityActorInfo()`。
  2. 在 AuraCharacter 与 AuraEnemy 中分别 override。
  3. 在 `BeginPlay` 中调用 `InitAbilityActorInfo()`，让 AbilitySystemComponent 执行委托绑定。

------

## 4. AbilitySystemComponent 新增接口

- **新增函数**：`void AbilityActorInfoSet()`
- **用途**：当角色设置完 AbilityActorInfo 后调用，用于触发委托绑定。
- **调用位置**：
  - AuraCharacter 的 `InitAbilityActorInfo` 中。
  - AuraEnemy 的 `InitAbilityActorInfo` 中。

------

## 5. 委托绑定

- **委托类型**：`MulticastDelegate_ThreeParams`（非 dynamic）。
- **绑定方式**：使用 `AddUObject(this, &ClassName::EffectApplied)`。
- **绑定结果**：当效果应用时会触发回调函数 `EffectApplied`。

------

## 6. 调试验证

- **调试信息**：
  - `GEngine->AddOnScreenDebugMessage(...)` 输出 "Effect Applied"。
  - 设置断点，查看三个输入参数的值。
- **测试步骤**：
  1. 运行游戏，拾取生命水晶（持续效果）。
  2. 输出 "Effect Applied" 信息。
  3. 再拾取一次，效果叠加。
  4. 拾取即时效果，也会触发回调。

------

## 7. 运行时信息获取

- **AbilitySystemComponent**：归属对象为 BP_AuraPlayerState。
- **GameplayEffectSpec**：包含效果的完整信息（如 GE_CrystalHeal）。
- **ActiveEffectHandle**：可用于追踪或移除效果。

------

## 8. 总结

- 回调机制让我们可以 **在运行时获取效果应用的详细信息**。
- 后续开发中可以利用这一点实现复杂逻辑（如自定义处理、特效触发、统计等）。

