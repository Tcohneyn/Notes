# 🎬 UE5 游戏能力系统：可扩展伤害实现总结（大纲式）

## 1. 引入问题

- 目前硬编码伤害值（50），缺乏可扩展性。
- 目标：根据技能等级自动调整伤害值。

------

## 2. 使用 Scalable Float 实现可扩展伤害

- **FScalableFloat**：可在蓝图或 C++ 中定义的可扩展浮点属性。
- 功能：
  - 允许设置基础数值。
  - 可绑定 **Curve Table** 根据等级动态缩放。
  - 提供属性面板预览（Preview Slider）。

------

## 3. 将 FScalableFloat 添加到 Gameplay Ability

- 创建 `FScalableFloat Damage` 成员变量。
- 设置属性：
  - `EditDefaultsOnly`（蓝图默认值可编辑）。
  - `BlueprintReadOnly`（蓝图只读）。
  - 分类 `Damage`。
- 优势：
  - 公共属性，可被所有继承类使用。
  - 不使用的能力消耗的内存可忽略。

------

## 4. Curve Table 使用

- 用于根据能力等级动态调整伤害。
- 创建方法：
  1. CSV/JSON 文件导入或直接在编辑器创建。
  2. 为不同能力创建独立 Curve Table（例如 Firebolt）。
  3. 设置等级对应的伤害数值：
     - Level 1 → 5
     - Level 5 → 10
     - Level 10 → 15
     - Level 15 → 27
     - Level 20 → 41
     - Level 40 → 120
- 曲线插值类型选择：Cubic / Constant 等。

------

## 5. 在 Gameplay Ability 中绑定 Curve Table

- 将 FScalableFloat 的 Magnitude 设置为 1。
- 在 Dropdown 中选择对应 Curve Table。
- 选择具体曲线（例如 Firebolt）。

------

## 6. 获取可扩展伤害值

- 获取能力等级：`GetAbilityLevel()` → 返回 `int32`。

- 使用 FScalableFloat 提供的方法：

  - `GetValueAtLevel(Level)` → 返回对应等级的伤害（float）。
  - 可选择 `AsInteger()`、`AsBool()` 等转换。

- 示例：

  ```cpp
  const float ScaledDamage = Damage.GetValueAtLevel(GetAbilityLevel());
  ```

------

## 7. 调试与验证

- 使用 `GEngine->AddOnScreenDebugMessage()` 输出计算后的伤害。
- 测试不同等级，确认曲线生效：
  - Level 1 → 5
  - Level 20 → 41
- 确认即时打印位置：
  - 在创建 Gameplay Effect Spec 时打印，而不是击中时。

------

## 8. 应用到实际逻辑

- 替换硬编码伤害值：
  - 原本：`SetByColorMagnitude(50)`
  - 改为：`SetByColorMagnitude(ScaledDamage)`
- 结果：伤害随技能等级动态变化。

------

## 9. 总结与复用

- 可扩展伤害实现：
  - FScalableFloat + Curve Table。
- 优点：
  - 公共属性，可复用。
  - 可针对不同技能设置不同曲线。
- 可复用方案：
  - Firebolt 的 Curve Table 可用于其他伤害类型能力。

------

