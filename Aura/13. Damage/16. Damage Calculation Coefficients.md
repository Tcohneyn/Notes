### **I. 问题：伤害计算中的硬编码魔术数字**



- **现状**：当前的伤害计算逻辑（`exec calc damage`）使用了“魔术数字”（如 0.25 和 0.333 这样的系数）来缩放属性值 。
- **局限性**：这些硬编码的系数在游戏初期（低等级）可能适用，但随着角色等级提升（例如 10 级后），数值可能会失衡 。
- **目标**：使用曲线表（Curve Table）代替硬编码值，实现基于数据驱动的数值缩放，使系数能随等级变化 。



### **II. 解决方案：实现系数曲线表**



- **存储位置**：将曲线表的引用存储在 `CharacterClassInfo` 数据资产中，因为这里已经存储了职业默认值 。
- **创建曲线表**：
  - 在 `AbilitySystem/Data` 文件夹下创建名为 `CT_DamageCalculationCoefficients` 的曲线表资源 。
  - 插值类型选择“Constant”（常量/阶梯图），这意味着数值在特定的等级区间内保持不变，而不是平滑过渡 。
- **定义曲线**：
  - **护甲穿透曲线 (`ArmorPenetration`)**：
    - 命名为 `ArmorPenetration` 。
    - 1-10 级：0.25（原始值）。
    - 10-20 级：0.15（增加穿透难度）。
    - 20-40 级：0.085 。
    - 40 级以上：0.035 。
  - **有效护甲曲线 (`EffectiveArmor`)**：
    - 命名为 `EffectiveArmor` 。
    - 1 级：0.333 。
    - 10 级：0.25 。
    - 20 级：0.15 。
    - 40 级：0.085 。



### **III. C++ 实现：访问曲线数据**



- **更新数据资产 (`CharacterClassInfo`)**：
  - 在头文件中添加 `UCurveTable*` 类型的属性 `DamageCalculationCoefficients` 。
  - 在编辑器中将创建好的曲线表赋值给该属性 。
- **创建辅助函数 (`AuraAbilitySystemLibrary`)**：
  - 在函数库中创建静态函数 `GetCharacterClassInfo`，用于直接从 GameMode 获取数据资产，避免重复的转换代码 。
  - 重构 `GiveStartupAbilities` 和 `InitializeDefaultAttributes` 函数，使用此新辅助函数 。
- **在 `ExecCalc_Damage` 中获取系数**：
  - 调用 `GetCharacterClassInfo` 获取数据资产 。
  - 从数据资产中获取曲线表，并使用 `FindCurve` 通过行名（如 `ArmorPenetration`）查找曲线 。
  - 使用 `Eval` 函数，根据传入的等级获取具体的系数值 。



### **IV. 获取角色等级与接口调整**



- **需求**：`Eval` 函数需要角色的等级作为输入参数 。
- **接口调用**：通过 `ICombatInterface` 接口的 `GetPlayerLevel` 函数来获取等级 。
- **代码调整**：
  - 由于 `GetPlayerLevel` 不是 `const` 函数，因此不能在 `const` 指针上调用 。
  - 必须去掉 `SourceAvatar`、`TargetAvatar` 以及接口指针的 `const` 限定符，以便成功调用获取等级的函数 。



### **V. 测试与验证**



- **验证步骤**：
  - 设置断点检查获取到的系数值 。
  - 验证 1 级时的数值是否为 0.25 和 0.333 。注意浮点数可能会有微小的精度误差（如 0.33300004），这是正常的 。
- **等级缩放测试**：
  - 在编辑器中修改敌人的等级（例如改为 11、39、40 级）。
  - 确认系数是否根据曲线表的定义发生了变化（例如变为 0.15 或 0.085）。
- **结果**：系统现在实现了数据驱动，允许开发者在不修改代码的情况下精确控制战斗机制的数值缩放 。