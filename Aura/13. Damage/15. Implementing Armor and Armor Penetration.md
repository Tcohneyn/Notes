## 标题大纲式总结：UExecCalc_Damage - 护甲与护甲穿透计算

### I. 伤害计算的优先级

- **原则**: 计算顺序至关重要，决定了后续计算的基数。
- **确定顺序**: **先判定格挡 (Block)**，**后计算护甲 (Armor)**。
  - 如果格挡成功，伤害基数减半，后续的护甲计算将基于这个减半后的数值。



### II. 属性捕获设置（Armor & Armor Penetration）

- **目的**: 捕获攻击者和目标的属性，用于后续的复杂计算。
- **在 `AuraDamageStatics` 结构体中定义**:
  1. **护甲 (Armor)**:
     - **属性**: `Armor`。
     - **来源**: `EGameplayEffectAttributeCaptureSource::Target` (目标的防御属性)。
     - **快照**: `false`。
  2. **护甲穿透 (Armor Penetration)**:
     - **属性**: `ArmorPenetration`。
     - **来源**: `EGameplayEffectAttributeCaptureSource::Source` (攻击者的穿透属性)。
     - **快照**: `false`。
- **在 Exec Calc 构造函数中关联**:
  - 将 `ArmorDef` 和 `ArmorPenetrationDef` 添加到 `RelevantAttributesToCapture` 数组中。

------



### III. 在 `Execute_Implementation` 中执行计算

#### A. 捕获属性值

- **Target Armor**: 捕获目标的护甲值，并使用 `FMath::Max(0.f, ...)` 确保其不为负数。
- **Source Armor Penetration**: 捕获来源的护甲穿透值，并使用 `FMath::Max(0.f, ...)` 确保其不为负数。



#### B. 步骤 1: 计算有效护甲 (Effective Armor)



- **逻辑**: 护甲穿透百分比地忽略目标的护甲。

- **护甲穿透缩放 (Scaling)**: 穿透值通常需要缩放（例如乘以 **0.25f**）来控制其强度。

  - *示例*：`SourceArmorPenetration * 0.25f`

- **有效护甲公式**:

  C++

  ```
  const float EffectiveArmor = TargetArmor * (100.f - ScaledArmorPenetration) / 100.f;
  ```

  - **目的**: 计算出攻击者实际需要面对的（未被穿透忽略的）护甲值。



#### C. 步骤 2: 计算护甲减伤 (Armor Damage Reduction)



- **逻辑**: 有效护甲值以百分比形式减少伤害值。

- **护甲减伤缩放**: 减伤百分比通常也需要缩放（例如乘以 **0.333f**），以确保每点护甲不会减少太多伤害。

  - *示例*：`EffectiveArmor * 0.333f`

- **最终伤害公式**:

  C++

  ```
  Damage *= (100.f - ScaledEffectiveArmor) / 100.f;
  ```

  - **目的**: 将当前 `Damage` 值乘以一个（小于或等于 1.0 的）减伤乘数。

------



### IV. 测试与验证



- **验证方式**: 通过修改敌人的二级属性 Gameplay Effect (`GE_SecondaryAttributes_Enemy` 或 `GE_SecondaryAttributes_Test`)，将 **Armor** 属性值设为 Scalable Float (如 45 或 90)。
- **预期结果**: 随着敌人护甲值的增加，火球术造成的最终伤害数值（如从 16 降到 7，再降到 6）会相应减少，证明护甲减伤计算逻辑正确。
- **结论**: Exec Calc 成功地将 Block Chance、Armor Penetration 和 Armor 的复杂逻辑整合到伤害计算流程中。