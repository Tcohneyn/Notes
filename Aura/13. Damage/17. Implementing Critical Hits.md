这是对这段字幕内容的详细标题大纲式总结，重点围绕着**暴击（Critical Hit）**机制在 `UExecCalc_Damage` 中的实现，以及如何将其系数数据驱动化。

------



## 暴击系统（Critical Hit）的实现与数据驱动

### I. 任务目标与属性决策

- **核心目标**：实现暴击几率判定、暴击抵抗修正和暴击伤害加成。
- **属性归属判定**：
  - **暴击几率 (`CritHitChance`)**：捕获自 **Source（攻击者）**。
  - **暴击抵抗 (`CritHitResistance`)**：捕获自 **Target（目标/受击者）**。
  - **暴击伤害 (`CritHitDamage`)**：捕获自 **Source（攻击者）**。

### II. C++ 属性捕获设置

- **定义宏**：在 `AuraDamageStatics` 结构体中，声明 `CritHitChanceDef`、`CritHitResistanceDef` 和 `CritHitDamageDef` 三个属性捕获定义。
- **关联属性**：在 Exec Calc 的构造函数中，将上述三个属性添加到 `RelevantAttributesToCapture` 数组中。

### III. 暴击计算核心逻辑

#### A. 捕获与验证数值

1. 声明并捕获三个浮点数变量：`SourceCriticalHitChance`、`TargetCriticalHitResistance` 和 `SourceCriticalHitDamage`。
2. 使用 `FMath::Max(Value, 0.f)` 确保所有捕获值均不为负数。

#### B. 计算有效暴击几率 (Effective Critical Hit Chance)



- **目的**：计算暴击抵抗削减后的实际暴击几率。

- **初始公式**：

  C++

  ```
  EffectiveCritHitChance = SourceCritHitChance - (TargetCritHitResistance * 0.15f);
  ```

  - 初始阶段使用硬编码系数 `0.15f` 降低暴击抵抗的效能。

#### C. 暴击判定与伤害修正

1. **暴击判定**：
   - 使用 `FMath::RandRange(1, 100)` 生成随机数。
   - `const bool bIsCriticalHit = RandomValue < EffectiveCriticalHitChance;`
2. **伤害修正**：使用三元运算符（Ternary Operator）对伤害进行修正：
   - **如果暴击**：`Damage = Damage * 2.f + SourceCriticalHitDamage`
     - 基础伤害翻倍 (`* 2.f`)，并加上攻击者额外的暴击伤害加成。
   - **如果不暴击**：`Damage = Damage` (伤害不变)。



### IV. 【挑战奖励】暴击抵抗系数的数据驱动

- **痛点**：硬编码的 `0.15f` 系数缺乏灵活性。
- **Curve Table 配置**：
  1. 打开 `CT_DamageCalculationCoefficients` 曲线表。
  2. 添加新曲线，命名为 **`CriticalHitResistance`**。
  3. 配置随等级变化的系数（降低在高等级时的抵抗效果）：
     - Level 1: 0.15
     - Level 10: 0.1
     - Level 20: 0.08
     - Level 40: 0.06
- **C++ 整合**：
  1. 在 `ExecCalc_Damage` 中，通过 `CharacterClassInfo` 获取新的 **`CriticalHitResistance` 曲线**。
  2. 使用 `TargetCombatInterface->GetPlayerLevel()` 获取**目标（受击者）**的等级。
  3. 通过 `Curve->Eval(TargetLevel)` 动态获取 `CriticalHitResistanceCoefficient`。
  4. 用该动态系数替换掉原公式中的硬编码 `0.15f`。

### V. 测试与后续展望

- **测试结果**：通过降低 Block Chance 并进行多次攻击，成功观察到伤害值出现翻倍的暴击数值（例如，常规 8 点伤害出现 21 点伤害）。
- **未来的挑战**：
  - 当前只能在 `Exec Calc` 中判断是否暴击或格挡，但在 `PostGameplayEffectExecute`（实际显示伤害数字的地方）无法得知这些信息。
  - **下一阶段目标**：找到一种机制，将 **暴击状态** 或 **格挡状态** 等战斗结果信息从计算环节传递到 UI 显示环节，实现伤害数字的颜色变化、**"BLOCK"** 或 **"CRITICAL HIT"** 的浮动文本等视觉反馈。