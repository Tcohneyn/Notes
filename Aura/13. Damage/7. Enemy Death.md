# **🎯 敌人死亡系统实现（本段字幕大纲）**

## **1. 引入死亡机制的需求**

- 已有 Hit React（受击反应）能力。
- 当生命值降至 0 时需要触发死亡逻辑（Death）。

------

## **2. 在 Combat Interface 中新增死亡函数**

### 2.1 新增接口函数

- 添加 `virtual void Die()`（纯虚函数）。
- 保证所有实现此接口的类都必须实现死亡逻辑。

### 2.2 在角色基类中实现 Die

- 打开 AuraCharacterBase 进行 override。
- 在 Die 中需要做：
  - 丢武器（Detach Weapon）
  - Ragdoll（布娃娃物理）

------

## **3. Ragdoll 与网络同步设计**

### 3.1 为什么需要 Multicast RPC

- 死亡效果（ragdoll / drop weapon）必须在所有客户端同步显示。
- 因此创建 `MulticastHandleDeath()`，使用 **NetMulticast + Reliable**。

### 3.2 Die 与 MulticastHandleDeath 的职责拆分

- **Die（仅服务器）**：
  - 负责服务端逻辑
  - Detach 武器
  - 调用 MulticastHandleDeath
- **MulticastHandleDeath（所有端）**：
  - 武器模拟物理 + 启用重力
  - 设置武器碰撞
  - Mesh 启用物理 + 重力
  - Mesh 设置碰撞
  - Capsule 禁用碰撞（角色尸体可被穿过）

------

## **4. 敌人专属死亡行为（AuraEnemy）**

### 4.1 覆盖 Die

- 在 AuraEnemy 中 override Die
- 调用 Super::Die()（保留 ragdoll 等功能）
- 设置 Lifespan（默认 5 秒，可调）

### 4.2 新增参数

- 在 AuraEnemy 中增加：
  - `float Lifespan = 5.0f;` （EditAnywhere）

------

## **5. AttributeSet 触发死亡**

### 5.1 检测伤害是否致命

- 在 AttributeSet.cpp 中，当 `bFatal = true` 时：
  - 获取 Target Actor
  - 检查是否实现 CombatInterface
  - 调用 `Die()`

### 5.2 非致命伤害仍触发 Hit React

------

## **6. 测试死亡逻辑**

### 6.1 调整数值方便测试

- 提高 Firebolt 伤害（ScaledDamage = 10）

### 6.2 实际测试结果

- 敌人掉武器
- Mesh ragdoll
- Lifespan 到达后尸体消失

------

## **7. 后续将加入的 RPG 系统内容**

- 经验值获取机制（敌人死亡后）。
- 溶解（Dissolve）死亡特效。

------

