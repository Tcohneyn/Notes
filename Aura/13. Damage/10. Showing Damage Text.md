###   I. 伤害数值组件的创建与调用 (Component Instantiation and Invocation)



------

- **回顾组件状态**：`BP_DamageTextComponent` (Widget Component) 已经设置好 Widget Class (`BP_DamageText`)，后者包含动画且在构造时自动播放。
- **部署策略**：在 C++ `PostGameplayEffectExecute` 函数中，当发生伤害且伤害值大于零时，需要创建并显示该组件。
- **网络同步设计**：
  - 在 **`AuraPlayerController`** 中创建 **`ShowDamageNumber`** 函数。
  - 该函数设计为 **Client RPC** (`ClientReliable`)，确保在服务器调用时，远程客户端也能正确执行显示逻辑。
  - RPC 接收参数：`float DamageAmount` 和 `ACharacter* TargetCharacter` (被击中目标)。



### II. `AuraPlayerController` 中的组件生成与管理 (Component Spawning and Management in PC)



------

- **C++ 属性定义**：在 `AuraPlayerController.h` 中定义一个 UCLASS 属性 (`TSubclassOf<UDamageTextComponent>`)，命名为 `DamageTextComponentClass`，用于在蓝图中指定要生成的组件类型。
- **组件生成逻辑 (`ShowDamageNumber_Implementation`)**：
  1. **验证**：检查 `TargetCharacter` 和 `DamageTextComponentClass` 是否有效。
  2. **动态创建**：使用 `NewObject<UDamageTextComponent>` 动态创建组件实例，并将 **TargetCharacter** 设置为 **Outer**（所有者）。
  3. **注册**：调用 **`RegisterComponent()`** 将动态创建的组件注册到 Unreal Engine。
  4. **定位与附加**：调用 **`AttachToComponent`**，将其附着到 `TargetCharacter` 的根组件 (`RootComponent`)，规则选择 **Keep Relative Transform**。
  5. **分离**：立即调用 **`DetachFromComponent`** (使用 **Keep World Transform** 规则)，使其脱离父级，自由飘浮，不受目标移动影响。
  6. **设置数值**：调用组件的 C++ 函数 **`SetDamageText(DamageAmount)`**，将伤害值传递给蓝图。



### III. 伤害事件触发与 C++ 通信 (Damage Event Trigger and C++ Communication)



------

- **调用封装**：在 `AuraAttributeSet` 中，将显示逻辑封装为私有函数 **`ShowFloatingText(const FEffectProperties& Props, float Damage)`**。
- **显示条件**：仅在以下情况调用 `ShowFloatingText`：
  1. `LocalIncomingDamage` > 0。
  2. 伤害来源（`SourceCharacter`）与目标（`TargetCharacter`）不相等（排除自残伤害）。
- **Controller 获取与调用**：
  1. 使用 `UGameplayStatics::GetPlayerController` 获取本地 Player Controller。
  2. **Cast** 到 `AAuraPlayerController`。
  3. 调用 `PC->ShowDamageNumber(LocalIncomingDamage, TargetCharacter)` (RPC)。
- **【重要 Bug 修复】**：发现 C++ 代码在 `SetEffectProperties` 中未正确设置 `Props.SourceCharacter`，导致自伤判断失败。修复方法是将本地变量赋值改为 `Props.SourceCharacter = ...`。



### IV. 蓝图组件清理与优化 (Blueprint Cleanup and Optimization)



------

- **生命周期管理**：为防止大量组件残留，在 `BP_DamageTextComponent` 的事件图表中添加清理逻辑：
  1. 在 `Event SetDamageText` 之后添加 **Delay (1.0秒)**。
  2. 调用 **`Destroy Component`** (1.0秒恰好与 Widget 动画时长匹配)。
- **Widget 显示空间修正**：
  1. **问题**：初始组件在 **World Space** 下显示，导致数值倾斜且不清晰。
  2. **修正**：在 `BP_DamageTextComponent` 的 Class Defaults 中，将 **Space** 属性从 World 改为 **Screen Space**。
- **动画视觉优化**：
  1. **问题**：缩放动画导致 Text 字体在放大时出现像素化。
  2. **原理**：避免 Text 的 Scale 值超过 1.0。
  3. **调整**：
     - 将 Text 字体大小从 26 放大到 **58** (约为 26 * 2.25)。
     - 将动画 Scale 的最大值从 2.25 调整为 **1.0**，将起始值从 1.0 调整为 **0.44** (保持相同的放大比例)。
  4. **最终效果**：数字清晰且具有动态的弹出效果。