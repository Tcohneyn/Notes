这段字幕的标题和内容主要围绕着如何在 `UExecCalc_Damage` 类中实现属性捕获（Attribute Capture）的机制，这是执行计算（Exec Calc）的核心步骤。

------



## 标题大纲式总结：UExecCalc_Damage - 属性捕获的实现

### I. 属性捕获的架构：AuraDamageStatics 结构体

- **目的**: 使用一种常见的技术，创建一个私有的 C++ 结构体来定义和存储所有属性捕获定义（Attribute Capture Definitions），确保它们只被初始化一次。

- **结构体定义**: 声明一个普通的 C++ `struct` 命名为 `AuraDamageStatics` (非 `UStruct`，不暴露给蓝图) 。

- **静态单例访问**:

  - 实现一个静态函数 `DamageStatics()`，它返回一个 `const AuraDamageStatics&` 引用 。

  - 该函数内部声明一个 `static AuraDamageStatics statics` 变量，确保该结构体只实例化一次（静态存储期）。

    

### II. 声明与定义属性捕获

- **声明捕获定义 (在 AuraDamageStatics 内)**:

  - 使用宏 `DECLARE_ATTRIBUTE_CAPTURE_DEF(Armor)` 。

  - 该宏会自动创建 `FGameplayEffectAttributeCaptureDefinition ArmorDef` 和一个属性指针 。

    

- **定义捕获细节 (在 AuraDamageStatics 构造函数内)**:

  - 使用宏 `DEFINE_ATTRIBUTE_CAPTURE_DEF(S, P, T, B)` 。

    

    

  - **参数设置 (以 Armor 为例)**:

    - **S (Attribute Set Class)**: `UAuraAttributeSet` 。

      

    - **P (Attribute Name)**: `Armor` 。

      

    - **T (Capture Source)**: `EGameplayEffectAttributeCaptureSource::Target`（捕获目标的护甲，用于伤害计算）。

      

    - **B (Snapshot)**: `false`（不进行快照）。

      

### III. 关联捕获定义到 Exec Calc 类



- **在 Exec Calc 构造函数中**:

  - 将 `ArmorDef` 添加到 `UExecCalc_Damage` 类的 `RelevantAttributesToCapture` 数组中 。

    

  - 调用方式：`RelevantAttributesToCapture.Add(DamageStatics().ArmorDef)` 。

    

### IV. 在 `Execute_Implementation` 中执行捕获和修改 

- **1. 准备评估参数**:

  - 从 `ExecutionParams.GetOwningSpec()` 获取 Effect Spec 。

    

  - 从 Effect Spec 获取 Source Tags 和 Target Tags 。

    

  - 创建 `FAggregatorEvaluateParameters` 结构体，并设置其 `SourceTags` 和 `TargetTags` 成员 。

    

- **2. 捕获属性数值**:

  - 使用 `ExecutionParams.AttemptCalculateCapturedAttributeMagnitude()` 。

    

    

  - 传入 `ArmorDef` 和已设置好的评估参数，结果存储在一个本地 `float` 变量（如 `Armor`）中 。

    

    

  - **安全检查**: 对捕获的属性值进行边界限制，例如确保护甲不为负值：`FMath::Max(0.f, Armor)` 。

    

    

- **3. 输出结果到属性 (Output Modifier)**:

  - 使用 `OutExecutionOutput` 参数（输出参数）来修改属性值 。

    

  - 调用 `OutExecutionOutput.AddOutputModifier()` 。

    

    - **输入 1**: 要修改的属性（例如 `UAuraAttributeSet::GetArmorAttribute()`） 。

      

    - **输入 2**: 运算类型（例如 `EGameplayModOp::Additive`） 。

      

    - **输入 3**: 最终计算得到的数值（`float` 类型，例如计算后的 `Armor` 值） 。

      

- **结果验证**: 通过在编辑器中应用 Gameplay Effect 并设置断点，证明 Exec Calc 成功执行并修改了目标角色的护甲属性 。最终的目的是使用此机制进行复杂的伤害计算 。

  

  