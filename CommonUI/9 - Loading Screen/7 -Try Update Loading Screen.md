### 一、 性能优化：动态 Tick 管理机制

为了避免不必要的资源消耗，子系统不应该始终处于 Tick 状态。

- **启用时机**：仅在地图**开始加载**时启用 Tick。
- **禁用时机**：在加载界面**彻底移除**后禁用 Tick。
- **实现方式**：调用 `SetTickableTickType()` 函数，在 `Conditional`（有条件的执行）和 `Never`（从不执行）之间切换。

------

### 二、 地图加载状态跟踪

为了精准判断当前的加载阶段，我们在头文件中引入了一个关键变量：

- **`bIsCurrentlyLoadingMap`** (Boolean):
  - **True**: 表示地图正在加载中。
  - **False**: 表示地图资源已加载完毕，进入后续处理阶段（如等待纹理流送）。

------

### 三、 实现地图加载生命周期回调

#### 1. 开始加载：`OnMapPreloaded`

当引擎触发预加载委托时，执行以下操作：

1. **安全校验**：验证拥有该上下文的 `GameInstance` 是否与当前子系统匹配。
2. **开启 Tick**：将 Tick 类型设置为 `Conditional`。
3. **状态更新**：设置 `bIsCurrentlyLoadingMap = true`。
4. **立即触发更新**：调用 `TryUpdateLoadingScreen()` 尝试立即显示 UI。

#### 2. 加载完成：`OnMapPostLoaded`

当引擎通知地图加载完毕时：

1. **安全校验**：验证加载的世界及其 `GameInstance` 是否正确。
2. **状态更新**：设置 `bIsCurrentlyLoadingMap = false`。
3. **注意点**：此处**不直接移除** UI，因为可能还需要根据设置额外显示几秒。

------

### 四、 核心逻辑函数：`TryUpdateLoadingScreen`

这是子系统的“大脑”，负责决定加载界面的生死。其逻辑架构（伪代码阶段）如下：

| **逻辑分支**           | **对应动作**                                                 |
| ---------------------- | ------------------------------------------------------------ |
| **检查启动动画**       | 如果初次启动的视频还在播放，则继续等待。                     |
| **如果满足显示条件**   | 在视口中**显示 (Display)** 加载界面 UI。                     |
| **如果不满足显示条件** | **移除 (Remove)** 当前激活的加载界面。                       |
| **扫尾工作**           | 通知其他监听对象加载已完成，并执行 `SetTickableTickType(Never)` **禁用 Tick**。 |

------

### 五、 将逻辑接入 Tick 循环

为了确保每一帧都能准确判断是否该移除加载界面，我们在 `Tick` 函数中移除了之前的调试打印信息，并替换为对 `TryUpdateLoadingScreen()` 的持续调用。

------

### 总结与核心结论

- **解耦设计**：通过 `bIsCurrentlyLoadingMap` 将“资源加载”与“UI 显示”逻辑解耦。
- **性能优先**：通过动态开关 Tick，确保子系统在非加载期间零开销。

下一步建议：

目前的 TryUpdateLoadingScreen 还是伪代码。您想了解如何编写具体的 C++ 代码来检查“启动动画（Startup Movie）”是否已经结束，从而决定何时切入游戏内加载界面吗？