### 一、 加载界面子系统概述与设计方案

在虚幻引擎中管理加载界面，选择合适的架构至关重要：

- **选择 `UGameInstanceSubsystem` 的原因**：
  - **生命周期一致性**：该子系统与 `GameInstance` 共享生命周期。这意味着只要游戏在运行，子系统就一直存在。
  - **全局访问性**：在项目的任何地方都能轻松获取引用，非常适合管理跨关卡的加载逻辑。
- **核心逻辑流程**：
  1. **监听开始加载**：通过虚幻核心委托捕获地图加载开始的信号。
  2. **显示 UI**：在加载开始时立即弹出我们在上节课制作的 `WBP_LoadingScreen`。
  3. **监听加载完成**：捕获地图加载结束的信号。
  4. **延迟移除**：加载完成后并不立即消失，而是利用“额外秒数”配置项，等待纹理流送（Texture Streaming）完成，避免玩家进入关卡时看到模糊的贴图。

------

### 二、 创建 C++ 加载子系统类

1. **类继承**：在 C++ 类浏览器中，创建一个继承自 `UGameInstanceSubsystem` 的新类，命名为 `UFrontEndLoadingScreenSubsystem`。
2. **基础函数重写**：
   - `ShouldCreateSubsystem`：控制子系统的实例化条件。
   - `Initialize`：用于在系统启动时绑定委托。
   - `Deinitialize`：用于在系统销毁时解绑委托，防止内存泄漏或无效回调。

------

### 三、 核心委托 (Delegates) 的绑定与处理

为了精准掌握地图加载的时机，我们需要操作 `FCoreUObjectDelegates` 提供的底层委托：

| **委托名称**                | **触发时机**                 | **用途**                         |
| --------------------------- | ---------------------------- | -------------------------------- |
| **`PreLoadMapWithContext`** | 引擎准备加载新地图之前       | **显示**加载界面                 |
| **`PostLoadMapWithWorld`**  | 地图资源加载完毕并创建世界后 | **标记**加载完成（开始计时移除） |

#### 实现细节：

- **回调函数签名**：
  - `OnMapPreloaded`：需要匹配委托签名，接受 `const FString& MapName`。
  - `OnMapPostLoaded`：接受一个 `UWorld*` 指针。
- **绑定操作**：在 `Initialize` 中使用 `AddUObject` 进行绑定。
- **清理操作**：在 `Deinitialize` 中使用 `RemoveAll(this)` 确保解绑。

------

### 四、 代码逻辑实现 (C++ 代码要点)

- **服务器过滤**：在 `ShouldCreateSubsystem` 中，我们检查当前是否为**专用服务器 (Dedicated Server)**。加载界面仅对客户端有意义，因此在服务器上应返回 `false` 以节省资源。
- **回调函数占位**：目前在回调函数中添加了调试打印信息（`DebugPrint`），以便验证委托是否成功触发。

> **关键提示**：虚幻引擎的地图加载委托在编辑器内运行（PIE）时可能表现不一致。为了确保测试的准确性，必须使用 **Standalone Game（独立游戏）** 模式进行验证。

------

### 五、 运行测试与验证

- **步骤**：点击运行按钮，选择“Standalone Game”。
- **观察结果**：
  - 游戏启动时，由于会加载默认地图，日志中应先后出现 `OnMapPreloaded` 和 `OnMapPostLoaded` 的调试消息。
  - 这证明了我们的子系统已经成功“钩入”了引擎的加载流程。

------

总结与下一步：

目前我们的子系统已经能够感知地图加载状态。你想了解如何在该子系统中使用 Tick 机制，结合我们之前在开发者设置中定义的“额外等待秒数”，来实现加载界面的平滑淡出吗？